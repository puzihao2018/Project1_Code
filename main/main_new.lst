                  2   $LIST
0000              4   
0000              5   ;-------------------;
0000              6   ;    Const Define   ;
0000              7   ;-------------------; 
0000              8   XTAL EQU 7373000
0000              9   BAUD EQU 115200
0000             10   BRVAL EQU ((XTAL/BAUD)-16)
0000             11   
0000             12   CCU_RATE      EQU 22050
0000             13   CCU_RELOAD    EQU ((65536-((XTAL/(2*CCU_RATE)))))
0000             14   
0000             15   ;TIMER0_RATE   EQU 4096    ; 4096Hz
0000             16   ;TIMER0_RELOAD EQU ((65536-(XTAL/(2*TIMER0_RATE))))
0000             17   TIMER1_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             18   TIMER1_RELOAD EQU ((65536-(XTAL/(2*TIMER1_RATE))))
0000             19   QUITTIME      EQU 60
0000             20   QUITTEMP      EQU 50
0000             21   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             22   
0000             23   number_off_set EQU 17200 ;the distance between each number
0000             24   ;number start at ff
0000             25   
0000             26   ;starting addressed of different sound tracks
0000             27   decimal_start  EQU 360000
0000             28   decimal_off_set EQU 24100
0000             29   decimal_playtime EQU 50000
0000             30   
0000             31   special_dec_start EQU 174000 ;numbers from 10 to 19
0000             32   special_off_set EQU 21500
0000             33   special_playtime EQU 21500;19000
0000             34   
0000             35   hundreds_start EQU 563000
0000             36   hundreds_off_set EQU 36000
0000             37   
0000             38   current_temp_is_start EQU 674000
0000             39   current_temp_playtime EQU 35000
0000             40   
0000             41   degree_start EQU 710000
0000             42   degree_playtime EQU 11018
0000             43   
0000             44   celsius_start EQU 732236
0000             45   celsius_playtime EQU 17000
0000             46   
0000             47   current_process_is_start EQU 757000
0000             48   current_process_is_playtime EQU 27000
0000             49            
0000             50   ramp_to_soak_start EQU 790000
0000             51   ramp_to_soak_playtime EQU 25000
0000             52   
0000             53   preheat_and_soak_start EQU 822000
0000             54   preheat_and_soak_playtime EQU 27000
0000             55   
0000             56   ramp_to_peak_start EQU 857000
0000             57   ramp_to_peak_playtime EQU 19000
0000             58   
0000             59   reflow_start EQU 885000
0000             60   reflow_playtime EQU 15000
0000             61   
0000             62   cooling_start EQU 906000
0000             63   cooling_playtime EQU 14000
0000             64   ;-------------------;
0000             65   ;    Ports Define   ;
0000             66   ;-------------------; 
0000             67   ;ADC01 equ P0.0; Read Room Temperature
0000             68   LCD_RS equ P0.1
0000             69   LCD_RW equ P0.2
0000             70   LCD_E  equ P0.3
0000             71   ;Soundout  P0.4
0000             72   LCD_D4 equ P0.5
0000             73   LCD_D5 equ P0.6
0000             74   LCD_D6 equ P0.7
0000             75   LCD_D7 equ P3.0
0000             76   ;          P3.1
0000             77   ;          P1.2
0000             78   Start  equ P1.3
0000             79   Stop   equ P1.4
0000             80   LED    equ P1.6
0000             81   ;ADC00 equ P1.7; Read Oven Temperature
0000             82   ;ADC03 equ P2.0; Read Keyboard1
0000             83   ;ADC02 equ P2.1; Read Keyboard0
0000             84   ;MOSI  equ P2.2
0000             85   ;MISO  equ P2.3
0000             86   FLASH_CE EQU P2.4
0000             87   ;SPICK equ P2.5
0000             88   ;WAVEOUT   P2.6
0000             89   OVEN   equ P2.7
0000             90   
0000             91   ;------------------------;
0000             92   ;    Interrupt Vectors   ;
0000             93   ;------------------------; 
0000             94   ; Reset vector
0000             95   org 0x0000
0000 020C5F      96       ljmp MainProgram
0003             97   
0003             98   ; External interrupt 0 vector, start
0003             99   org 0x0003
0003 020E15     100            ljmp EI0_ISR
0006            101   
0006            102   ; Timer/Counter 0 overflow interrupt vector
000B            103   org 0x000B
000B 32         104            reti
000C            105   
000C            106   ; External interrupt 1 vector, stop
0013            107   org 0x0013
0013 020E1B     108            ljmp EI1_ISR
0016            109   
0016            110   ; Timer/Counter 1 overflow interrupt vector
001B            111   org 0x001B
001B 020DEE     112            ljmp Timer1_ISR
001E            113   
001E            114   ; Serial port receive/transmit interrupt vector
0023            115   org 0x0023 
0023 32         116            reti
0024            117   
0024            118   ; CCU interrupt vector
005B            119   org 0x005b 
005B 020782     120            ljmp CCU_ISR
005E            121   
005E            122   ;-----------------------;
005E            123   ;    Variables Define   ;
005E            124   ;-----------------------; 
005E            125   ;Variable_name: ds n
0030            126   dseg at 0x30
0030            127       Count10ms:    ds 1 ; Used to determine when half second has passed
0031            128       Time_Global:  ds 1 ; to store the time of whole process
0032            129       Time_Counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            130   
0033            131       FSM0_State: ds 1
0034            132       FSM1_State: ds 1
0035            133   
0035            134       Profile_Num: ds 1
0036            135   
0036            136       TEMP_SOAK:  ds 4
003A            137       TIME_SOAK:  ds 4
003E            138       TEMP_RFLW:  ds 4
0042            139       TIME_RFLW:  ds 4
0046            140       TEMP_SAFE:  ds 4
004A            141       Current_Room_Temp: ds 4
004E            142            Current_Oven_Temp: ds 4
0052            143   
0052            144       Cursor:     ds 1
0053            145       NEW_BCD:    ds 3    ; 3 digit BCD used to store current entered number
0056            146       NEW_HEX:    ds 4    ; 32 bit number of new entered number
005A            147       ;for math32.inc
005A            148       x: ds 4
005E            149       y: ds 4
0062            150       bcd: ds 5
0067            151       Count5s: ds 1
0068            152       ;z
0068            153       w:   ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
006B            154            number: ds 1;
006C            155       digits: ds 1;
006D            156            tenth: ds 1;
006E            157            individual_offest: ds 1;
006F            158       ;key
006F            159       keyin: ds 1
0070            160   
0070            161   
0070            162   ;-------------------;
0070            163   ;    Flags Define   ;
0070            164   ;-------------------; 
0070            165   ;Flag_name: dbit 1
0000            166   bseg
0000            167       FSM0_State_Changed:  dbit 1
0001            168       Main_State:          dbit 1 ; 0 for setting, 1 for reflowing
0002            169       ;for math32.inc
0002            170       mf: dbit 1
0003            171       enable_time_global: dbit 1
0004            172       half_seconds_flag: dbit 1 ; 500ms in double rate mode
0005            173           nodigit: dbit 1 ; if playing from 10 to 19 then we don't need to
0006            174                       ;play the last digit
0006            175            skiphundred: dbit 1
0007            176            skiptenth: dbit 1
0008            177       speak_enable: dbit 1
0009            178   ;-----------------------;
0009            179   ;     Include Files     ;
0009            180   ;-----------------------; 
0009            181   ;$NOLIST
                 -1       $include(lcd_4bit.inc) 
005E              1   cseg
005E              2   
005E 30313233     3   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
006E 30313233     4   hex: db '0123456789abcdef',0
     34353637
     38396162
     63646566
     00
007F              5   
007F              6   ;LCD                '1234567890123456'
007F 57454C43     7   WELCOME1:        db 'WELCOME!        '   ,0
     4F4D4521
     20202020
     20202020
     00
0090 53757065     8   WELCOME2:        db 'Super Reflow!   '   ,0
     72205265
     666C6F77
     21202020
     00
00A1 53657474     9   MAIN_FACE1:      db 'Setting: Prof   '   ,0
     696E673A
     2050726F
     66202020
     00
00B2 53746172    10   MAIN_FACE2: db 'Start       Stop'   ,0
     74202020
     20202020
     53746F70
     00
00C3 53544D50    11   SETTING1:        db 'STMP:   STM:   s'   ,0
     3A202020
     53544D3A
     20202073
     00
00D4 52544D50    12   SETTING2:   db 'RTMP:   RTM:   s'   ,0
     3A202020
     52544D3A
     20202073
     00
00E5 4F4C443A    13   MODIFY_DOWN:db 'OLD:    NEW:    '   ,0
     20202020
     4E45573A
     20202020
     00
00F6 4D4F4449    14   MODIFY1:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
0107 4D4F4449    15   MODIFY2:         db 'MODIFY:TIME_SOAK'   ,0
     46593A54
     494D455F
     534F414B
     00
0118 4D4F4449    16   MODIFY3:         db 'MODIFY:TEMP_RFLW'   ,0
     46593A54
     454D505F
     52464C57
     00
0129 4D4F4449    17   MODIFY4:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
013A 4D4F4449    18   MODIFY5:    db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
014B 54454D50    19   WORKING:    db 'TEMP:   TIME:   '   ,0
     3A202020
     54494D45
     3A202020
     00
015C 53544D50    20   STEP1:           db 'STMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
016D 53544D3A    21   STEP2:      db 'STM:   s SOAKING'   ,0
     20202073
     20534F41
     4B494E47
     00
017E 52544D50    22   STEP3:      db 'RTMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
018F 52544D3A    23   STEP4:      db 'RTM:   s REFLOW '   ,0
     20202073
     20524546
     4C4F5720
     00
01A0 5346543A    24   STEP5:      db 'SFT:     COOLING'   ,0
     20202020
     20434F4F
     4C494E47
     00
01B1 20202020    25   STEP6:      db '         FINISH '   ,0
     20202020
     2046494E
     49534820
     00
01C2 4572726F    26   WARNING1:   db 'Error Warning!  '   ,0
     72205761
     726E696E
     67212020
     00
01D3 54454D50    27   WARNING2:   db 'TEMP Sensing ERR'   ,0
     2053656E
     73696E67
     20455252
     00
01E4             28   ;---------------------------------;
01E4             29   ;           Basic Macros          ;
01E4             30   ;---------------------------------;
                 31   LCD_Initailize mac
                 32   	lcall LCD_4BIT
                 33   endmac
01E4             34   
                 35   LCD_WriteData mac
                 36   	mov a, %0
                 37   	lcall ?LCD_WriteData
                 38   endmac
01E4             39            
                 40   LCD_WriteCommand mac
                 41   	mov a, %0
                 42   	lcall ?LCD_WriteCommand
                 43   endmac
01E4             44   
                 45   LCD_Send_Constant_String mac
                 46   	push dph
                 47   	push dpl
                 48   	push acc
                 49   	mov dptr, %0
                 50   	lcall ?Send_Constant_String
                 51   	pop acc
                 52   	pop dpl
                 53   	pop dph
                 54   endmac
01E4             55   
                 56   LCD_Set_Cursor mac
                 57   	push acc
                 58   	mov a, #%1
                 59   	dec a
                 60   	lcall ?Set_Cursor_%0 ; Select column and row
                 61   	pop acc
                 62   endmac
01E4             63   
                 64   LCD_Display_BCD mac
                 65   	push ar0
                 66   	mov r0, %0
                 67   	lcall ?Display_BCD
                 68   	pop ar0
                 69   endmac
01E4             70   
                 71   LCD_Display_NUM mac
                 72   	push ar0
                 73   	mov r0, %0
                 74   	lcall ?Display_NUM
                 75   	pop ar0
                 76   endmac
01E4             77   
                 78   LCD_Display_Char mac
                 79   	push acc
                 80   	mov a, %0
                 81   	lcall ?LCD_WriteData
                 82   	pop acc
                 83   endmac
01E4             84   
                 85   Wait_Milli_Seconds mac
                 86   	push AR2
                 87   	mov R2, %0
                 88   	lcall ?Wait_Milli_Seconds
                 89   	pop AR2
                 90   endmac
01E4             91   
01E4             92   ;---------------------------------;
01E4             93   ;         Interface Macros        ;
01E4             94   ;---------------------------------;
01E4             95   
                 96   LCD_INTERFACE_WELCOME mac
                 97   	LCD_Set_Cursor(1,1)
                 98   	LCD_Send_Constant_String(#WELCOME1)
                 99   	LCD_Set_Cursor(2,1)
                100   	LCD_Send_Constant_String(#WELCOME2)
                101   endmac
01E4            102   
                103   LCD_INTERFACE_MAIN mac
                104   	LCD_Set_Cursor(1,1)
                105   	LCD_Send_Constant_String(#MAIN_FACE1)
                106   	LCD_Set_Cursor(2,1)
                107   	LCD_Send_Constant_String(#MAIN_FACE2)
                108   	LCD_Set_Cursor(1,15); Profile number
                109   	LCD_Display_BCD(Profile_Num)
                110   endmac
01E4            112   
                113   LCD_INTERFACE_SETTING mac
                114   	LCD_Set_Cursor(1,1)
                115   	LCD_Send_Constant_String(#SETTING1)
                116   	LCD_Set_Cursor(2,1)
                117   	LCD_Send_Constant_String(#SETTING2)
                118   endmac
01E4            119   
                120   LCD_INTERFACE_MODIFY1 mac
                121   	LCD_Set_Cursor(1,1)
                122   	LCD_Send_Constant_String(#MODIFY1)
                123   	LCD_Set_Cursor(2,1)
                124   	LCD_Send_Constant_String(#MODIFY_DOWN)
                125   endmac
01E4            126   
                127   LCD_INTERFACE_MODIFY2 mac
                128   	LCD_Set_Cursor(1,1)
                129   	LCD_Send_Constant_String(#MODIFY2)
                130   	LCD_Set_Cursor(2,1)
                131   	LCD_Send_Constant_String(#MODIFY_DOWN)
                132   endmac
01E4            133   
                134   LCD_INTERFACE_MODIFY3 mac
                135   	LCD_Set_Cursor(1,1)
                136   	LCD_Send_Constant_String(#MODIFY3)
                137   	LCD_Set_Cursor(2,1)
                138   	LCD_Send_Constant_String(#MODIFY_DOWN)
                139   endmac
01E4            140   
                141   LCD_INTERFACE_MODIFY4 mac
                142   	LCD_Set_Cursor(1,1)
                143   	LCD_Send_Constant_String(#MODIFY4)
                144   	LCD_Set_Cursor(2,1)
                145   	LCD_Send_Constant_String(#MODIFY_DOWN)
                146   endmac
01E4            147   
                148   LCD_INTERFACE_MODIFY5 mac
                149   	LCD_Set_Cursor(1,1)
                150   	LCD_Send_Constant_String(#MODIFY5)
                151   	LCD_Set_Cursor(2,1)
                152   	LCD_Send_Constant_String(#MODIFY_DOWN)
                153   endmac
01E4            154   
                155   LCD_INTERFACE_STEP1 mac
                156   	LCD_Set_Cursor(1,1)
                157   	LCD_Send_Constant_String(#WORKING)
                158   	LCD_Set_Cursor(2,1)
                159   	LCD_Send_Constant_String(#STEP1)
                160   endmac
01E4            161   
                162   LCD_INTERFACE_STEP2 mac
                163   	LCD_Set_Cursor(1,1)
                164   	LCD_Send_Constant_String(#WORKING)
                165   	LCD_Set_Cursor(2,1)
                166   	LCD_Send_Constant_String(#STEP2)
                167   endmac
01E4            168   
                169   LCD_INTERFACE_STEP3 mac
                170   	LCD_Set_Cursor(1,1)
                171   	LCD_Send_Constant_String(#WORKING)
                172   	LCD_Set_Cursor(2,1)
                173   	LCD_Send_Constant_String(#STEP3)
                174   endmac
01E4            175   
                176   LCD_INTERFACE_STEP4 mac
                177   	LCD_Set_Cursor(1,1)
                178   	LCD_Send_Constant_String(#WORKING)
                179   	LCD_Set_Cursor(2,1)
                180   	LCD_Send_Constant_String(#STEP4)
                181   endmac
01E4            182   
                183   LCD_INTERFACE_STEP5 mac
                184   	LCD_Set_Cursor(1,1)
                185   	LCD_Send_Constant_String(#WORKING)
                186   	LCD_Set_Cursor(2,1)
                187   	LCD_Send_Constant_String(#STEP5)
                188   endmac
01E4            189   
                190   LCD_INTERFACE_STEP6 mac
                191   	LCD_Set_Cursor(1,1)
                192   	LCD_Send_Constant_String(#WORKING)
                193   	LCD_Set_Cursor(2,1)
                194   	LCD_Send_Constant_String(#STEP6)
                195   endmac
01E4            196   
                197   LCD_INTERFACE_WARNING mac
                198   	LCD_Set_Cursor(1,1)
                199   	LCD_Send_Constant_String(#WARNING1)
                200   	LCD_Set_Cursor(2,1)
                201   	LCD_Send_Constant_String(#WARNING2)
                202   endmac
01E4            203   
01E4            204   
01E4            205   Wait10us:
01E4 7812       206       mov R0, #18
01E6 D8FE       207       djnz R0, $ ; 2 machine cycles-> 2*0.27126us*18=10us
01E8 22         208            ret
01E9            209   ;---------------------------------;
01E9            210   ; Wait 40 microseconds            ;
01E9            211   ;---------------------------------;
01E9            212   Wait40uSec:
01E9 C000       213            push AR0
01EB 784A       214            mov R0, #74
01ED            215   L0: 
01ED D8FE       216            djnz R0, L0 ; 2 cycles->2*271.26ns*74=40us
01EF D000       217            pop AR0
01F1 22         218       ret
01F2            219   
01F2            220   ;---------------------------------;
01F2            221   ; Wait 500 microseconds           ;
01F2            222   ;---------------------------------;
01F2            223   WaitHalfSec:
01F2 7A28       224       mov R2, #40
01F4 79FA       225   H3: mov R1, #250
01F6 78B8       226   H2: mov R0, #184
01F8 D8FE       227   H1: djnz R0, H1 ; 2 machine cycles-> 2*0.27126us*184=100us
01FA D9FA       228       djnz R1, H2 ; 100us*250=0.025s
01FC DAF6       229       djnz R2, H3 ; 0.025s*20=0.5s
01FE 22         230       ret
01FF            231   
01FF            232   ;---------------------------------;
01FF            233   ; Wait 'R2' milliseconds          ;
01FF            234   ;---------------------------------;
01FF            235   ?Wait_Milli_Seconds:
01FF C000       236            push AR0
0201 C001       237            push AR1
0203 790A       238   L3: mov R1, #10
0205 78B8       239   L2: mov R0, #184
0207 D8FE       240   L1: djnz R0, L1 ; 2 cycles->2*271.26ns*184=100us
0209 D9FA       241       djnz R1, L2 ; 100us*10=1ms
020B DAF6       242       djnz R2, L3 ; number of millisecons to wait passed in R2
020D D001       243       pop AR1
020F D000       244       pop AR0
0211 22         245       ret
0212            246            
0212            247   ;---------------------------------;
0212            248   ; Toggles the 'E' pin in the LCD  ;
0212            249   ;---------------------------------;
0212            250   LCD_pulse:
0212 D283       251            setb LCD_E
0214 1201E9     252            lcall Wait40uSec
0217 C283       253            clr LCD_E
0219 1201E9     254       lcall Wait40uSec
021C 22         255       ret
021D            256   
021D            257   ;---------------------------------;
021D            258   ; Writes acc to LCD in 4-bit mode ;
021D            259   ;---------------------------------;
021D            260   LCD_byte:
021D            261            ; Write high 4 bits first
021D A2E7       262            mov c, ACC.7
021F 92B0       263            mov LCD_D7, c
0221 A2E6       264            mov c, ACC.6
0223 9287       265            mov LCD_D6, c
0225 A2E5       266            mov c, ACC.5
0227 9286       267            mov LCD_D5, c
0229 A2E4       268            mov c, ACC.4
022B 9285       269            mov LCD_D4, c
022D 120212     270       lcall LCD_pulse
0230            271            ; Write low 4 bits next
0230 A2E3       272            mov c, ACC.3
0232 92B0       273            mov LCD_D7, c
0234 A2E2       274            mov c, ACC.2
0236 9287       275            mov LCD_D6, c
0238 A2E1       276            mov c, ACC.1
023A 9286       277            mov LCD_D5, c
023C A2E0       278            mov c, ACC.0
023E 9285       279            mov LCD_D4, c
0240 120212     280       lcall LCD_pulse
0243 22         281            ret
0244            282   
0244            283   ;---------------------------------;
0244            284   ; Write data to LCD               ;
0244            285   ;---------------------------------;
0244            286   ?LCD_WriteData:
0244 D281       287            setb LCD_RS
0246 02021D     288            ljmp LCD_byte
0249            289   
0249            290   ;---------------------------------;
0249            291   ; Write command to LCD            ;
0249            292   ;---------------------------------;
0249            293   ?LCD_WriteCommand:
0249 C281       294            clr LCD_RS
024B 02021D     295            ljmp LCD_byte
024E            296   
024E            297   ;---------------------------------;
024E            298   ; Configure LCD in 4-bit mode     ;
024E            299   ;---------------------------------;
024E            300   LCD_4BIT:
024E C283       301            clr LCD_E   ; Resting state of LCD's enable pin is zero
0250 C282       302            clr LCD_RW  ; We are only writing to the LCD in this program
0252            303            
0252            304            ; After power on, let the LCD start up before initializing
0252 C002       305            push AR2
0254 7A28       305            mov R2, #40
0256 1201FF     305            lcall ?Wait_Milli_Seconds
0259 D002       305            pop AR2
025B            306            
025B            307            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
025B 7433       308            mov a, #0x33
025D 120249     308            lcall ?LCD_WriteCommand
0260 7433       309            mov a, #0x33
0262 120249     309            lcall ?LCD_WriteCommand
0265 7432       310            mov a, #0x32
0267 120249     310            lcall ?LCD_WriteCommand ; change to 4-bit mode
026A            311   
026A            312            ; Configure the LCD
026A 7428       313            mov a, #0x28
026C 120249     313            lcall ?LCD_WriteCommand
026F 740C       314            mov a, #0x0c
0271 120249     314            lcall ?LCD_WriteCommand
0274 7401       315            mov a, #0x01
0276 120249     315            lcall ?LCD_WriteCommand ;  Clear screen command (takes some time)
0279            316   
0279            317       ;Wait for the clear screen command to finish.
0279 C002       318            push AR2
027B 7A02       318            mov R2, #2
027D 1201FF     318            lcall ?Wait_Milli_Seconds
0280 D002       318            pop AR2
0282 22         319       ret
0283            320   
0283            321   ;---------------------------------;
0283            322   ; Send a constant string to LCD   ;
0283            323   ;---------------------------------;
0283            324   ?Send_Constant_String:
0283 E4         325       clr a
0284 93         326       movc a, @a+dptr
0285 6006       327       jz ?Send_Constant_String_Done
0287 120244     328       lcall ?LCD_WriteData
028A A3         329       inc dptr
028B 80F6       330       sjmp ?Send_Constant_String
028D            331   ?Send_Constant_String_Done:
028D 22         332       ret  
028E            333   
028E            334   ;---------------------------------;
028E            335   ; Set LCD cursor at row, column   ;
028E            336   ;---------------------------------;
028E            337   ?Set_Cursor_2:
028E 4440       338            orl a, #01000000B
0290            339   ?Set_Cursor_1:
0290 4480       340            orl a, #10000000B
0292 020249     341            ljmp ?LCD_WriteCommand ; Select column and row
0295            342   
0295            343   ;---------------------------------;
0295            344   ; Display a BCD number in the LCD ;
0295            345   ;---------------------------------;
0295            346   ?Display_BCD:
0295 C0E0       347            push acc
0297            348            ; Write most significant digit
0297 E8         349            mov a, r0
0298 C4         350            swap a
0299 540F       351            anl a, #0fh
029B 4430       352            orl a, #30h
029D 120244     353            lcall ?LCD_WriteData
02A0            354            ; write least significant digit
02A0 E8         355            mov a, r0
02A1 540F       356            anl a, #0fh
02A3 4430       357            orl a, #30h
02A5 120244     358            lcall ?LCD_WriteData
02A8 D0E0       359            pop acc
02AA 22         360            ret
02AB            361   
02AB            362   ?Display_NUM:
02AB C0E0       363            push acc
02AD E8         364            mov a, R0
02AE 540F       365            anl a, #0fh
02B0 4430       366            orl a, #30h
02B2 120244     367            lcall ?LCD_WriteData
02B5 D0E0       368            pop acc
02B7            369   
02B7 22         370            ret
                 -1       $include(math32.inc)
                559   $LIST
                 -1       $include(LPC9351.inc)
0528              1   cseg
0528              2   
0528              3   ;---------------------------------;
0528              4   ;           Basic Macros          ;
0528              5   ;---------------------------------;
                  6   Ports_Initialize mac
                  7       lcall Ports_Init
                  8   endmac
0528              9   
                 10   Clock_Double mac
                 11       lcall _Clock_Double
                 12   endmac
0528             13   
                 14   ADC_Initialize mac
                 15       lcall InitADC
                 16   endmac
0528             17   
0528             18   ;---------------------------------;
0528             19   ;            Functions            ;
0528             20   ;---------------------------------;
0528             21   _Clock_Double:
0528 C0E0        22       push acc
052A 90FFDE      23       mov dptr, #CLKCON
052D E0          24       movx a, @dptr
052E 4408        25       orl a, #00001000B ; double the clock speed to 14.746MHz
0530 F0          26       movx @dptr,a
0531 D0E0        27       pop acc
0533 22          28       ret
0534             29   
0534             30   ;---------------------------------;
0534             31   ; Initial configuration of ports. ;
0534             32   ; After reset the default for the ;
0534             33   ; pins is 'Open Drain'.  This     ;
0534             34   ; routine changes them pins to    ;
0534             35   ; Quasi-bidirectional like in the ;
0534             36   ; original 8051.                  ;
0534             37   ; Notice that P1.2 and P1.3 are   ;
0534             38   ; always 'Open Drain'. If those   ;
0534             39   ; pins are to be used as output   ;
0534             40   ; they need a pull-up resistor.   ;
0534             41   ;---------------------------------;
0534             42   Ports_Init:
0534             43       ; Configure all the ports in bidirectional mode:
0534 758400      44       mov P0M1, #00H
0537 758500      45       mov P0M2, #00H
053A 759100      46       mov P1M1, #00H
053D 759200      47       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0540 75A400      48       mov P2M1, #00H
0543 75A500      49       mov P2M2, #00H
0546 75B100      50       mov P3M1, #00H
0549 75B200      51       mov P3M2, #00H
054C 22          52            ret
054D             53   
054D             54   InitADC:
054D             55            ; ADC0_0 is connected to P1.7
054D             56            ; ADC0_1 is connected to P0.0
054D             57            ; ADC0_2 is connected to P2.1
054D             58            ; ADC0_3 is connected to P2.0
054D             59       ; Configure pins P1.7, P0.0, P2.1, and P2.0 as inputs
054D 438401      60       orl P0M1, #00000001b
0550 5385FE      61       anl P0M2, #11111110b
0553 439180      62       orl P1M1, #10000000b
0556 53927F      63       anl P1M2, #01111111b
0559 43A403      64       orl P2M1, #00000011b
055C 53A5FC      65       anl P2M2, #11111100b
055F             66            ; Setup ADC0
055F D2C2        67            setb BURST0 ; Autoscan continuos conversion mode
0561 75A120      68            mov     ADMODB,#0x20 ;ADC0 clock is 7.3728MHz/2
0564 75A30F      69            mov     ADINS,#0x0f ; Select the four channels of ADC0 for conversion
0567 758E05      70            mov     ADCON0,#0x05 ; Enable the converter and start immediately
056A             71            ; Wait for first conversion to complete
056A             72   InitADC_L1:
056A E58E        73            mov     a,ADCON0
056C 30E3FB      74            jnb     acc.3,InitADC_L1
056F 22          75            ret
                 76   DO_NOTHING mac
                 77   	NOP
                 78   endmac
                 78   $LIST
                 -1       $include(serial.inc)
0570              1   CSEG
0570              2   
0570              3   
0570              4   ;---------------------------------;
0570              5   ;           Basic Macros          ;
0570              6   ;---------------------------------;
                  7   Serial_Initialize mac
                  8   	;Serial_Initialize()
                  9       lcall _Serial_Initialize
                 10   endmac
0570             11   
                 12   Serial_Send_Char mac
                 13       mov a, %0
                 14       lcall putchar
                 15   endmac
0570             16   
                 17   Serial_Read_Char mac
                 18   	;Serial_Read_Char(direct)
                 19       lcall getchar
                 20       mov %0, a
                 21   endmac
0570             22   
                 23   Serial_Send_Newline mac
                 24   	lcall Send_NewLine
                 25   endmac
0570             26   
                 27   Serial_Send_BCD mac
                 28   	push ar0
                 29   	mov r0, %0
                 30   	lcall ?Send_BCD
                 31   	pop ar0
                 32   endmac
0570             33   
                 34   Serial_Send_Constant_String mac
                 35   	mov dptr, %0
                 36   	lcall SendString
                 37   endmac
0570             38   
0570             39   ;---------------------------------;
0570             40   ; Initialize the serial port      ;
0570             41   ;---------------------------------;
0570             42   _Serial_Initialize:
0570 75BD00      43            mov     BRGCON,#0x00
0573 75BF00      44            mov     BRGR1,#high(BRVAL)
0576 75BE30      45            mov     BRGR0,#low(BRVAL)
0579 75BD03      46            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
057C 759852      47            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
057F             48            ; Make sure that TXD(P1.0) and RXD(P1.1) are configured as bidrectional I/O
057F 5391FC      49            anl     P1M1,#11111100B
0582 5392FC      50            anl     P1M2,#11111100B
0585 22          51            ret
0586             52   
0586             53   ;---------------------------------;
0586             54   ; Sends a byte via serial port    ;
0586             55   ;---------------------------------;
0586             56   putchar:
0586 109902      57            jbc     TI,putchar_L1
0589 80FB        58            sjmp putchar
058B             59   putchar_L1:
058B F599        60            mov     SBUF,a
058D 22          61            ret
058E             62   
058E             63   SendString:
058E E4          64       clr a
058F 93          65       movc a, @a+dptr
0590 6006        66       jz SendString_L1
0592 120586      67       lcall putchar
0595 A3          68       inc dptr
0596 80F6        69       sjmp SendString  
0598             70   SendString_L1:
0598 22          71            ret
0599             72   
0599             73   ;---------------------------------;
0599             74   ; Send a BCD number to PuTTY      ;
0599             75   ;---------------------------------;
0599             76   ?Send_BCD:
0599 C0E0        77            push acc
059B             78            ; Write most significant digit
059B E8          79            mov a, r0
059C C4          80            swap a
059D 540F        81            anl a, #0fh
059F 4430        82            orl a, #30h
05A1 120586      83            lcall putchar
05A4             84            ; write least significant digit
05A4 E8          85            mov a, r0
05A5 540F        86            anl a, #0fh
05A7 4430        87            orl a, #30h
05A9 120586      88            lcall putchar
05AC D0E0        89            pop acc
05AE 22          90            ret
05AF             91   
05AF             92   Send_NewLine:
05AF 740D        93            mov a, #'\r'
05B1 120586      94            lcall putchar
05B4 740A        95            mov a, #'\n'
05B6 120586      96            lcall putchar   
05B9 22          97            ret
05BA             98   
05BA             99   
05BA            100   SendTemp0:
05BA 90005E     101            mov dptr, #HexAscii 
05BD            102            
05BD            103            
05BD            104            
05BD E565       105            mov a, bcd+3
05BF C4         106            swap a
05C0 540F       107            anl a, #0xf
05C2 93         108            movc a, @a+dptr
05C3 120586     109            lcall putchar
05C6 E565       110            mov a, bcd+3
05C8 540F       111            anl a, #0xf
05CA 93         112            movc a, @a+dptr
05CB 120586     113            lcall putchar
05CE            114            
05CE E564       115            mov a, bcd+2
05D0 C4         116            swap a
05D1 540F       117            anl a, #0xf
05D3 93         118            movc a, @a+dptr
05D4 120586     119            lcall putchar
05D7 E564       120            mov a, bcd+2
05D9 540F       121            anl a, #0xf
05DB 93         122            movc a, @a+dptr
05DC 120586     123            lcall putchar
05DF            124            
05DF E563       125            mov a, bcd+1
05E1 C4         126            swap a
05E2 540F       127            anl a, #0xf
05E4 93         128            movc a, @a+dptr
05E5 120586     129            lcall putchar
05E8 E563       130            mov a, bcd+1
05EA 540F       131            anl a, #0xf
05EC 93         132            movc a, @a+dptr
05ED 120586     133            lcall putchar
05F0            134   
05F0            135   
05F0 E562       136            mov a, bcd+0
05F2 C4         137            swap a
05F3 540F       138            anl a, #0xf
05F5 93         139            movc a, @a+dptr
05F6 120586     140            lcall putchar
05F9 E562       141            mov a, bcd+0
05FB 540F       142            anl a, #0xf
05FD 93         143            movc a, @a+dptr
05FE 120586     144            lcall putchar
0601 22         145            ret
                 -1       $include(temperature.inc)
0602              1   cseg
0602              2   
0602              3   
0602              4   
0602              5   Read_Oven_Temp:
0602              6            ; Take 256 (4^4) consecutive measurements of ADC0 channel 0 at about 10 us intervals and accumulate in x
0602 755A00       7            mov x+0, #low (0 % 0x10000) 
0605 755B00       7            mov x+1, #high(0 % 0x10000) 
0608 755C00       7            mov x+2, #low (0 / 0x10000) 
060B 755D00       7            mov x+3, #high(0 / 0x10000) 
060E 85C75A       8       mov x+0, ad0dat2
0611 7FFF         9            mov R7, #255
0613 1201E4      10       lcall Wait10us
0616             11   accumulate_loop0:
0616 85C75E      12       mov y+0, ad0dat2
0619 755F00      13       mov y+1, #0
061C 756000      14       mov y+2, #0
061F 756100      15       mov y+3, #0
0622 12037D      16       lcall add32
0625 1201E4      17       lcall Wait10us
0628 DFEC        18            djnz R7, accumulate_loop0
062A             19            
062A             20            ; Now divide by 16 (2^4)
062A 755E10      21            mov y+0, #low (16 % 0x10000) 
062D 755F00      21            mov y+1, #high(16 % 0x10000) 
0630 756000      21            mov y+2, #low (16 / 0x10000) 
0633 756100      21            mov y+3, #high(16 / 0x10000) 
0636 1204BF      22            lcall div32
0639             23            ; x has now the 12-bit representation of the temperature
0639             24            
0639             25            ; Convert to temperature (C)
0639 755EE8      26            mov y+0, #low (33000 % 0x10000) 
063C 755F80      26            mov y+1, #high(33000 % 0x10000) 
063F 756000      26            mov y+2, #low (33000 / 0x10000) 
0642 756100      26            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
0645 120432      27            lcall mul32
0648 755E00      28            mov y+0, #low (((1<<12)) % 0x10000) 
064B 755F10      28            mov y+1, #high(((1<<12)) % 0x10000) 
064E 756000      28            mov y+2, #low (((1<<12)) / 0x10000) 
0651 756100      28            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
0654 1204BF      29            lcall div32
0657 755E3C      30            mov y+0, #low (60 % 0x10000) 
065A 755F00      30            mov y+1, #high(60 % 0x10000) 
065D 756000      30            mov y+2, #low (60 / 0x10000) 
0660 756100      30            mov y+3, #high(60 / 0x10000) 
0663 12039E      31            lcall sub32
0666             32   
0666             33            ;mov32(Current_Oven_Volt,x); store the hex value of voltage
0666             34            
0666 755E0E      35            mov y+0, #low (7438 % 0x10000) 
0669 755F1D      35            mov y+1, #high(7438 % 0x10000) 
066C 756000      35            mov y+2, #low (7438 / 0x10000) 
066F 756100      35            mov y+3, #high(7438 / 0x10000) 
0672 120432      36            lcall mul32
0675 755E10      37            mov y+0, #low (10000 % 0x10000) 
0678 755F27      37            mov y+1, #high(10000 % 0x10000) 
067B 756000      37            mov y+2, #low (10000 / 0x10000) 
067E 756100      37            mov y+3, #high(10000 / 0x10000) 
0681 1204BF      38            lcall div32
0684 755EB4      39            mov y+0, #low (180 % 0x10000) 
0687 755F00      39            mov y+1, #high(180 % 0x10000) 
068A 756000      39            mov y+2, #low (180 / 0x10000) 
068D 756100      39            mov y+3, #high(180 / 0x10000) 
0690 12039E      40            lcall sub32
0693             41            ;now we got the relateive temp number in hex
0693             42   
0693             43       ;mov(dst, src)
0693 854D61      43            mov y+3, Current_Room_Temp+3
0696 854C60      43       mov y+2, Current_Room_Temp+2
0699 854B5F      43       mov y+1, Current_Room_Temp+1
069C 854A5E      43       mov y,   Current_Room_Temp
069F 12037D      44            lcall add32
06A2             45            ;now we got the true value of oven in hex
06A2 1202B8      46            lcall hex2bcd
06A5 1205BA      47            lcall SendTemp0; send to PC through serial port
06A8 1205AF      48            lcall Send_Newline
06AB 755E64      49            mov y+0, #low (100 % 0x10000) 
06AE 755F00      49            mov y+1, #high(100 % 0x10000) 
06B1 756000      49            mov y+2, #low (100 / 0x10000) 
06B4 756100      49            mov y+3, #high(100 / 0x10000) 
06B7 1204BF      50            lcall div32;divide by 100 to get the value in integer
06BA             51            ; now x contains the value in hex
06BA 755E5E      52            mov y+0, #low (350 % 0x10000) 
06BD 755F01      52            mov y+1, #high(350 % 0x10000) 
06C0 756000      52            mov y+2, #low (350 / 0x10000) 
06C3 756100      52            mov y+3, #high(350 / 0x10000) 
06C6 1203C0      53            lcall x_lt_y
06C9 200203      54            jb mf, Temp_OK
06CC             55            ;if not ok
06CC 020602      56            ljmp Read_Oven_Temp;re-read the value
06CF             57   
06CF             58            Temp_OK:
06CF             59       ;mov(dst, src)
06CF 855D51      59            mov Current_Oven_Temp+3, x+3
06D2 855C50      59       mov Current_Oven_Temp+2, x+2
06D5 855B4F      59       mov Current_Oven_Temp+1, x+1
06D8 855A4E      59       mov Current_Oven_Temp,   x
06DB 22          60            ret
06DC             61   
06DC             62   Read_Room_Temp:
06DC             63            
06DC 755A00      64            mov x+0, #low (0 % 0x10000) 
06DF 755B00      64            mov x+1, #high(0 % 0x10000) 
06E2 755C00      64            mov x+2, #low (0 / 0x10000) 
06E5 755D00      64            mov x+3, #high(0 / 0x10000) 
06E8 85C75A      65       mov x+0, ad0dat2
06EB 7FFF        66            mov R7, #255
06ED 1201E4      67       lcall Wait10us
06F0             68       
06F0             69   accumulate_loop1:
06F0 85F45E      70       mov y+0, ad0dat3
06F3 755F00      71       mov y+1, #0
06F6 756000      72       mov y+2, #0
06F9 756100      73       mov y+3, #0
06FC 12037D      74       lcall add32
06FF 1201E4      75       lcall Wait10us
0702 DFEC        76            djnz R7, accumulate_loop1
0704             77            
0704             78            ; Now divide by 16 (2^4)
0704 755E10      79            mov y+0, #low (16 % 0x10000) 
0707 755F00      79            mov y+1, #high(16 % 0x10000) 
070A 756000      79            mov y+2, #low (16 / 0x10000) 
070D 756100      79            mov y+3, #high(16 / 0x10000) 
0710 1204BF      80            lcall div32
0713             81            ; x has now the 12-bit representation of the temperature
0713             82            
0713             83            ; Convert to temperature (C)
0713 755EE8      84            mov y+0, #low (33000 % 0x10000) 
0716 755F80      84            mov y+1, #high(33000 % 0x10000) 
0719 756000      84            mov y+2, #low (33000 / 0x10000) 
071C 756100      84            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
071F 120432      85            lcall mul32
0722 755E00      86            mov y+0, #low (((1<<12)) % 0x10000) 
0725 755F10      86            mov y+1, #high(((1<<12)) % 0x10000) 
0728 756000      86            mov y+2, #low (((1<<12)) / 0x10000) 
072B 756100      86            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
072E 1204BF      87            lcall div32
0731 755E3C      88            mov y+0, #low (60 % 0x10000) 
0734 755F00      88            mov y+1, #high(60 % 0x10000) 
0737 756000      88            mov y+2, #low (60 / 0x10000) 
073A 756100      88            mov y+3, #high(60 / 0x10000) 
073D 12039E      89            lcall sub32
0740             90            
0740             91            ;now we got the voltage value
0740             92            ;mov32(Current_Room_Volt,x)
0740             93            
0740 755EA4      94            mov y+0, #low (27300 % 0x10000) 
0743 755F6A      94            mov y+1, #high(27300 % 0x10000) 
0746 756000      94            mov y+2, #low (27300 / 0x10000) 
0749 756100      94            mov y+3, #high(27300 / 0x10000) 
074C 12039E      95            lcall sub32
074F 755EF4      96            mov y+0, #low (500 % 0x10000) 
0752 755F01      96            mov y+1, #high(500 % 0x10000) 
0755 756000      96            mov y+2, #low (500 / 0x10000) 
0758 756100      96            mov y+3, #high(500 / 0x10000) 
075B 12039E      97            lcall sub32
075E             98            ;now we got the temperature
075E             99       ;mov(dst, src)
075E 855D4D      99            mov Current_Room_Temp+3, x+3
0761 855C4C      99       mov Current_Room_Temp+2, x+2
0764 855B4B      99       mov Current_Room_Temp+1, x+1
0767 855A4A      99       mov Current_Room_Temp,   x
076A            100            
076A 22         101            ret
                 -1       $include(speaker.inc)
                458   $LIST
                 -1       $include(key.inc)
0BAF              1   cseg
0BAF              2   
0BAF              3   
0BAF              4   ;-----------------------;
0BAF              5   ;    Functions Define   ;
0BAF              6   ;-----------------------; 
0BAF              7   
0BAF              8   ;Key_Read: if read, return the button readed.
0BAF              9   ;Return 0 if read nothing.
0BAF             10   Key_Read:
0BAF C0E0        11       push acc
0BB1 120BC0      12       lcall ADC_to_PB; read lower 8 button
0BB4 E56F        13       mov a, keyin
0BB6 B40001      14       cjne a, #0, Continue_Read_Key; if nothing, continue read key
0BB9 22          15       ret; if read successfully, return
0BBA             16       Continue_Read_Key:
0BBA 120C11      17       lcall ADC_to_PB_1
0BBD D0E0        18            pop acc
0BBF 22          19       ret
0BC0             20   
0BC0             21   ADC_to_PB:
0BC0 756F00      22       mov keyin, #0;clear input
0BC3             23            ; Check PB6
0BC3 C3          24            clr c
0BC4 E5C5        25            mov a, AD0DAT0
0BC6 94A3        26            subb a, #(173-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
0BC8 4004        27            jc ADC_to_PB_L6
0BCA 756F07      28       mov keyin, #7
0BCD 22          29            ret
0BCE             30   ADC_to_PB_L6:
0BCE             31            ; Check PB5
0BCE C3          32            clr c
0BCF E5C5        33            mov a, AD0DAT0; P1.7
0BD1 9491        34            subb a, #(155-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
0BD3 4004        35            jc ADC_to_PB_L5
0BD5 756F06      36            mov keyin, #6
0BD8 22          37            ret
0BD9             38   ADC_to_PB_L5:
0BD9             39            ; Check PB4
0BD9 C3          40            clr c
0BDA E5C5        41            mov a, AD0DAT0
0BDC 9478        42            subb a, #(130-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
0BDE 4004        43            jc ADC_to_PB_L4
0BE0 756F05      44            mov keyin, #5
0BE3 22          45            ret
0BE4             46   ADC_to_PB_L4:
0BE4             47            ; Check PB3
0BE4 C3          48            clr c
0BE5 E5C5        49            mov a, AD0DAT0
0BE7 9462        50            subb a, #(108-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
0BE9 4004        51            jc ADC_to_PB_L3
0BEB 756F04      52            mov keyin, #4
0BEE 22          53            ret
0BEF             54   ADC_to_PB_L3:
0BEF             55            ; Check PB2
0BEF C3          56            clr c
0BF0 E5C5        57            mov a, AD0DAT0
0BF2 9444        58            subb a, #(78-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
0BF4 4004        59            jc ADC_to_PB_L2
0BF6 756F03      60            mov keyin, #3
0BF9 22          61            ret
0BFA             62   ADC_to_PB_L2:
0BFA             63            ; Check PB1
0BFA C3          64            clr c
0BFB E5C5        65            mov a, AD0DAT0
0BFD 9433        66            subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
0BFF 4004        67            jc ADC_to_PB_L1
0C01 756F02      68            mov keyin, #2
0C04 22          69            ret
0C05             70   ADC_to_PB_L1:
0C05             71            ; Check PB1
0C05 C3          72            clr c
0C06 E5C5        73            mov a, AD0DAT0
0C08 9413        74            subb a, #(29-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
0C0A 4004        75            jc ADC_to_PB_L0
0C0C 756F01      76            mov keyin, #1
0C0F 22          77            ret
0C10             78   ADC_to_PB_L0:
0C10             79            ; No pusbutton pressed  
0C10 22          80            ret
0C11             81   
0C11             82   ADC_to_PB_1:
0C11             83            ; Check PB6
0C11 C3          84            clr c
0C12 E5C6        85            mov a, AD0DAT1
0C14 94C4        86            subb a, #(206-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
0C16 4004        87            jc ADC_to_PB_L6_2
0C18 756F0E      88            mov keyin, #14
0C1B 22          89            ret
0C1C             90   ADC_to_PB_L6_2:
0C1C             91            ; Check PB5
0C1C C3          92            clr c
0C1D E5C6        93            mov a, AD0DAT1
0C1F 94AF        94            subb a, #(185-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
0C21 4004        95            jc ADC_to_PB_L5_2
0C23 756F0D      96            mov keyin, #13
0C26 22          97            ret
0C27             98   ADC_to_PB_L5_2:
0C27             99            ; Check PB4
0C27 C3         100            clr c
0C28 E5C6       101            mov a, AD0DAT1
0C2A 9490       102            subb a, #(154-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
0C2C 4004       103            jc ADC_to_PB_L4_2
0C2E 756F0C     104            mov keyin, #12
0C31 22         105            ret
0C32            106   ADC_to_PB_L4_2:
0C32            107            ; Check PB3
0C32 C3         108            clr c
0C33 E5C6       109            mov a, AD0DAT1
0C35 9471       110            subb a, #(123-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
0C37 4004       111            jc ADC_to_PB_L3_2
0C39 756F0B     112            mov keyin, #11
0C3C 22         113            ret
0C3D            114   ADC_to_PB_L3_2:
0C3D            115            ; Check PB2
0C3D C3         116            clr c
0C3E E5C6       117            mov a, AD0DAT1
0C40 9452       118            subb a, #(92-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
0C42 4004       119            jc ADC_to_PB_L2_2
0C44 756F0A     120            mov keyin, #10
0C47 22         121            ret
0C48            122   ADC_to_PB_L2_2:
0C48            123            ; Check PB1
0C48 C3         124            clr c
0C49 E5C6       125            mov a, AD0DAT1
0C4B 9433       126            subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
0C4D 4004       127            jc ADC_to_PB_L1_2
0C4F 756F09     128            mov keyin, #9
0C52 22         129            ret
0C53            130   ADC_to_PB_L1_2:
0C53            131            ; Check PB1
0C53 C3         132            clr c
0C54 E5C6       133            mov a, AD0DAT1
0C56 9414       134            subb a, #(30-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
0C58 4004       135            jc ADC_to_PB_L01
0C5A 756F08     136            mov keyin, #8
0C5D 22         137            ret
0C5E            138   ADC_to_PB_L01:
0C5E            139            ; No pusbutton pressed  
0C5E 22         140            ret
0C5F            189   ;$LIST
0C5F            190   
0C5F            191   cseg
0C5F            192   
0C5F            193   MainProgram:
0C5F 75817F     194       mov SP, #0x7F
0C62 120534     195       lcall Ports_Init
0C65 12024E     196            lcall LCD_4BIT
0C68            197            ;Serial_Initialize()
0C68 120570     197       lcall _Serial_Initialize
0C6B 12054D     198       lcall InitADC
0C6E C0E0       199            push acc
0C70 7401       199            mov a, #1
0C72 14         199            dec a
0C73 120290     199            lcall ?Set_Cursor_1 ; Select column and row
0C76 D0E0       199            pop acc
0C78 C083       199            push dph
0C7A C082       199            push dpl
0C7C C0E0       199            push acc
0C7E 90007F     199            mov dptr, #WELCOME1
0C81 120283     199            lcall ?Send_Constant_String
0C84 D0E0       199            pop acc
0C86 D082       199            pop dpl
0C88 D083       199            pop dph
0C8A C0E0       199            push acc
0C8C 7401       199            mov a, #1
0C8E 14         199            dec a
0C8F 12028E     199            lcall ?Set_Cursor_2 ; Select column and row
0C92 D0E0       199            pop acc
0C94 C083       199            push dph
0C96 C082       199            push dpl
0C98 C0E0       199            push acc
0C9A 900090     199            mov dptr, #WELCOME2
0C9D 120283     199            lcall ?Send_Constant_String
0CA0 D0E0       199            pop acc
0CA2 D082       199            pop dpl
0CA4 D083       199            pop dph
0CA6 120D49     200       lcall Data_Initialization
0CA9 1207B3     201       lcall InitDAC
0CAC 12076B     202       lcall CCU_Init
0CAF 1207C3     203            lcall Init_SPI
0CB2 120CEC     204       lcall External_Interrupt0_Init
0CB5 120CEF     205       lcall External_Interrupt1_Init
0CB8 C2C8       206       clr TMOD20 ; Stop CCU timer
0CBA D2AF       207       setb EA   ; Enable Global interrupts
0CBC C2A7       208       clr OVEN
0CBE            209   
0CBE            210   Main_Loop:
0CBE 200101     211       jb Main_State,loop_b
0CC1            212   loop_a:; for FSM0
0CC1 00         213            NOP
0CC2            214   
0CC2            215   
0CC2            216   loop_b: ; for FSM1
0CC2 3004F9     217       jnb half_seconds_flag, Main_Loop
0CC5 C204       218       clr half_seconds_flag
0CC7 0567       219       inc Count5s
0CC9 E567       220       mov a, Count5s
0CCB B40509     221       cjne a, #5, skip3
0CCE 756700     222       mov Count5s, #0
0CD1 300803     223       jnb speak_enable, skip3
0CD4 120DDE     224       lcall Speak_Process
0CD7            225       skip3:
0CD7 80E5       226            sjmp Main_Loop
0CD9            227   
0CD9            228   
0CD9            229   
0CD9            230   
0CD9            231   ;----------------------------;
0CD9            232   ;           Macros           ;
0CD9            233   ;----------------------------; 
                234   Display_3BCD_from_x mac
                235       lcall hex2bcd
                236       ;now the bcd num of time is stored in bcd
                237       LCD_Display_NUM(bcd+1);
                238       LCD_Display_BCD(bcd);
                239   endmac
0CD9            240   
                241   Update_Temp mac
                242       lcall Read_Room_Temp
                243       lcall Read_Oven_Temp
                244       mov32(x, Current_Oven_Temp)
                245       mov32(y, %0)
                246       lcall x_lt_y
                247   endmac
0CD9            249   
0CD9            250   ;----------------------------;
0CD9            251   ;         Functions          ;
0CD9            252   ;----------------------------; 
0CD9            253   
0CD9            254   Timer1_Init:
0CD9 E589       255            mov a, TMOD
0CDB 540F       256            anl a, #0x0f ; Clear the bits for timer 1
0CDD 4410       257            orl a, #0x10 ; Configure timer 1 as 16-timer
0CDF F589       258            mov TMOD, a
0CE1 758D6F     259            mov TH1, #high(TIMER1_RELOAD)
0CE4 758BFF     260            mov TL1, #low(TIMER1_RELOAD)
0CE7            261            ; Enable the timer and interrupts
0CE7 D2AB       262       setb ET1  ; Enable timer 1 interrupt
0CE9 D28E       263       setb TR1  ; Start timer 1
0CEB 22         264            ret
0CEC            265   
0CEC            266   External_Interrupt0_Init:
0CEC            267            ; Enable the external interrupt
0CEC D2A8       268       setb EX0  ; Enable timer 1 interrupt
0CEE 22         269            ret
0CEF            270   
0CEF            271   External_Interrupt1_Init:
0CEF            272            ; Enable the external interrupt
0CEF D2AA       273       setb EX1  ; Enable timer 1 interrupt
0CF1 22         274            ret
0CF2            275   
0CF2            276   Display_Working_Status:
0CF2 C0E0       277            push acc
0CF4 7406       277            mov a, #6
0CF6 14         277            dec a
0CF7 120290     277            lcall ?Set_Cursor_1 ; Select column and row
0CFA D0E0       277            pop acc
0CFC            278       ;mov(dst, src)
0CFC 85515D     278            mov x+3, Current_Oven_Temp+3
0CFF 85505C     278       mov x+2, Current_Oven_Temp+2
0D02 854F5B     278       mov x+1, Current_Oven_Temp+1
0D05 854E5A     278       mov x,   Current_Oven_Temp
0D08 1202B8     279       lcall hex2bcd
0D0B            279       ;now the bcd num of time is stored in bcd
0D0B C000       279            push ar0
0D0D A863       279            mov r0, bcd+1
0D0F 1202AB     279            lcall ?Display_NUM
0D12 D000       279            pop ar0;
0D14 C000       279            push ar0
0D16 A862       279            mov r0, bcd
0D18 120295     279            lcall ?Display_BCD
0D1B D000       279            pop ar0;
0D1D            280   
0D1D C0E0       281            push acc
0D1F 740E       281            mov a, #14
0D21 14         281            dec a
0D22 120290     281            lcall ?Set_Cursor_1 ; Select column and row
0D25 D0E0       281            pop acc
0D27 755D00     282       mov x+3, #0
0D2A 755C00     283       mov x+2, #0
0D2D 755B00     284       mov x+1, #0
0D30 85315A     285       mov x, Time_Global
0D33 1202B8     286       lcall hex2bcd
0D36            286       ;now the bcd num of time is stored in bcd
0D36 C000       286            push ar0
0D38 A863       286            mov r0, bcd+1
0D3A 1202AB     286            lcall ?Display_NUM
0D3D D000       286            pop ar0;
0D3F C000       286            push ar0
0D41 A862       286            mov r0, bcd
0D43 120295     286            lcall ?Display_BCD
0D46 D000       286            pop ar0;
0D48 22         287       ret
0D49            288   
0D49            289   Data_Initialization:
0D49 753100     290       mov Time_Global, #0x00
0D4C 753900     291       mov TEMP_SOAK+3, #0x00
0D4F 753800     292       mov TEMP_SOAK+2, #0x00
0D52 753700     293       mov TEMP_SOAK+1, #0x00
0D55 753696     294       mov TEMP_SOAK, #150
0D58 754100     295       mov TEMP_RFLW+3, #0
0D5B 754000     296       mov TEMP_RFLW+2, #0
0D5E 753F00     297       mov TEMP_RFLW+1, #0
0D61 753ED9     298       mov TEMP_RFLW, #217
0D64 753D00     299       mov TIME_SOAK+3, #0
0D67 753C00     300       mov TIME_SOAK+2, #0
0D6A 753B00     301       mov TIME_SOAK+1, #0
0D6D 753A3C     302       mov TIME_SOAK, #60
0D70 754500     303       mov TIME_RFLW+3, #0
0D73 754400     304       mov TIME_RFLW+2, #0
0D76 754300     305       mov TIME_RFLW+1, #0
0D79 75424B     306       mov TIME_RFLW, #75
0D7C 754900     307       mov TEMP_SAFE+3, #0
0D7F 754800     308       mov TEMP_SAFE+2, #0
0D82 754700     309       mov TEMP_SAFE+1, #0
0D85 75463C     310       mov TEMP_SAFE, #60
0D88 753300     311       mov FSM0_State, #0
0D8B 753400     312       mov FSM1_State, #0
0D8E 756B00     313       mov number, #0x0 ;;not needed
0D91 756E00     314       mov individual_offest, #0x0
0D94 756700     315       mov Count5s, #0x00
0D97            316       
0D97 C296       317       clr LED
0D99 C208       318       clr speak_enable
0D9B C203       319       clr enable_time_global
0D9D C205       320       clr nodigit
0D9F C206       321            clr skiphundred
0DA1 C207       322            clr skiptenth
0DA3 C201       323       clr Main_State
0DA5            324   
0DA5 C0E0       325            push acc
0DA7 7401       325            mov a, #1
0DA9 14         325            dec a
0DAA 120290     325            lcall ?Set_Cursor_1 ; Select column and row
0DAD D0E0       325            pop acc
0DAF C083       325            push dph
0DB1 C082       325            push dpl
0DB3 C0E0       325            push acc
0DB5 90007F     325            mov dptr, #WELCOME1
0DB8 120283     325            lcall ?Send_Constant_String
0DBB D0E0       325            pop acc
0DBD D082       325            pop dpl
0DBF D083       325            pop dph
0DC1 C0E0       325            push acc
0DC3 7401       325            mov a, #1
0DC5 14         325            dec a
0DC6 12028E     325            lcall ?Set_Cursor_2 ; Select column and row
0DC9 D0E0       325            pop acc
0DCB C083       325            push dph
0DCD C082       325            push dpl
0DCF C0E0       325            push acc
0DD1 900090     325            mov dptr, #WELCOME2
0DD4 120283     325            lcall ?Send_Constant_String
0DD7 D0E0       325            pop acc
0DD9 D082       325            pop dpl
0DDB D083       325            pop dph
0DDD 22         326       ret
0DDE            327   
0DDE            328   Speak_Process:
0DDE 120A6D     329       lcall current_temp_is
0DE1 854E6B     330       mov number, Current_Oven_Temp+0
0DE4 120A50     331       lcall playnumbers
0DE7 120A8C     332       lcall degree
0DEA 120AAB     333       lcall celsius
0DED 22         334       ret
0DEE            335   
0DEE            336   ;----------------------------;
0DEE            337   ;     Interrupt Services     ;
0DEE            338   ;----------------------------; 
0DEE            339   Timer1_ISR:
0DEE 758D6F     340            mov TH1, #high(TIMER1_RELOAD)
0DF1 758BFF     341            mov TL1, #low(TIMER1_RELOAD)
0DF4 B2A6       342            cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0DF6            343            
0DF6            344            ; The two registers used in the ISR must be saved in the stack
0DF6 C0E0       345            push acc
0DF8 C0D0       346            push psw
0DFA            347            
0DFA            348            ; Increment the 8-bit 10-mili-second counter
0DFA 0530       349            inc Count10ms
0DFC            350   
0DFC            351   Inc_Done:
0DFC            352            ; Check if half second has passed
0DFC E530       353            mov a, Count10ms
0DFE B4640F     354            cjne a, #100, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
0E01            355            
0E01            356            ; 500 milliseconds have passed.  Set a flag so the main program knows
0E01 D204       357            setb half_seconds_flag ; Let the main program know half second had passed
0E03            358       
0E03 300302     359       jnb enable_time_global, skip1
0E06 0531       360       inc Time_Global
0E08            361            skip1:
0E08 753000     362       mov Count10ms, #0
0E0B            363   
0E0B B296       364       cpl LED
0E0D 120E52     365       lcall FSM1;call FSM1 here
0E10            366   
0E10            367   Timer1_ISR_done:
0E10 D0D0       368            pop psw
0E12 D0E0       369            pop acc
0E14 32         370            reti
0E15            371   
0E15            372   EI0_ISR:
0E15 C288       373       clr IT0
0E17 120CD9     374       lcall Timer1_Init
0E1A 32         375       reti
0E1B            376   
0E1B            377   EI1_ISR:
0E1B C28A       378       clr IT1
0E1D C28E       379       clr TR1; disable  timer 1
0E1F 120D49     380       lcall Data_Initialization
0E22 32         381       reti
0E23            382   
0E23            383   ;---------------------------------;
0E23            384   ;      Finite State Machines      ;
0E23            385   ;---------------------------------;
0E23            386   FSM0:
0E23 C0E0       387       push acc
0E25 120BAF     388       lcall Key_Read
0E28 E533       389       mov a, FSM0_State
0E2A 755A00     390            mov x+0, #low (0 % 0x10000) 
0E2D 755B00     390            mov x+1, #high(0 % 0x10000) 
0E30 755C00     390            mov x+2, #low (0 / 0x10000) 
0E33 755D00     390            mov x+3, #high(0 / 0x10000) 
0E36 856F5A     391       mov x, keyin
0E39 1202B8     392       lcall hex2bcd
0E3C C0E0       393            push acc
0E3E 740A       393            mov a, #10
0E40 14         393            dec a
0E41 120290     393            lcall ?Set_Cursor_1 ; Select column and row
0E44 D0E0       393            pop acc
0E46 C000       394            push ar0
0E48 A862       394            mov r0, bcd
0E4A 120295     394            lcall ?Display_BCD
0E4D D000       394            pop ar0
0E4F D0E0       395       pop acc
0E51 22         396   ret
0E52            397   
0E52            398   
0E52            399       ;---------------------------------;
0E52            400       ; FSM1 using Timer Interrupt      ;
0E52            401       ;---------------------------------;
0E52            402       ;update status and send data to LCD and PC every one/half seconds
0E52            403   FSM1:
0E52 E534       404       mov a, FSM1_State
0E54            405       FSM1_State0:
0E54 B40002     406           cjne a, #0, JUMP_FSM1_State1
0E57 8003       407           sjmp Start_FSM1_State0
0E59            408           JUMP_FSM1_State1:
0E59 020F1A     409           ljmp FSM1_State1
0E5C            410           
0E5C            411           Start_FSM1_State0:
0E5C D203       412           setb enable_time_global
0E5E D2A7       413           setb OVEN; turn oven on
0E60 1206DC     414       lcall Read_Room_Temp
0E63 120602     414       lcall Read_Oven_Temp
0E66            414   
0E66            414       ;mov(dst, src)
0E66 85515D     414            mov x+3, Current_Oven_Temp+3
0E69 85505C     414       mov x+2, Current_Oven_Temp+2
0E6C 854F5B     414       mov x+1, Current_Oven_Temp+1
0E6F 854E5A     414       mov x,   Current_Oven_Temp
0E72            414       ;mov(dst, src)
0E72 853961     414            mov y+3, TEMP_SOAK+3
0E75 853860     414       mov y+2, TEMP_SOAK+2
0E78 85375F     414       mov y+1, TEMP_SOAK+1
0E7B 85365E     414       mov y,   TEMP_SOAK
0E7E            414   
0E7E 1203C0     414       lcall x_lt_y    ;Read Temperatures
0E81 C0E0       415            push acc
0E83 7401       415            mov a, #1
0E85 14         415            dec a
0E86 120290     415            lcall ?Set_Cursor_1 ; Select column and row
0E89 D0E0       415            pop acc
0E8B C083       415            push dph
0E8D C082       415            push dpl
0E8F C0E0       415            push acc
0E91 90014B     415            mov dptr, #WORKING
0E94 120283     415            lcall ?Send_Constant_String
0E97 D0E0       415            pop acc
0E99 D082       415            pop dpl
0E9B D083       415            pop dph
0E9D C0E0       415            push acc
0E9F 7401       415            mov a, #1
0EA1 14         415            dec a
0EA2 12028E     415            lcall ?Set_Cursor_2 ; Select column and row
0EA5 D0E0       415            pop acc
0EA7 C083       415            push dph
0EA9 C082       415            push dpl
0EAB C0E0       415            push acc
0EAD 90015C     415            mov dptr, #STEP1
0EB0 120283     415            lcall ?Send_Constant_String
0EB3 D0E0       415            pop acc
0EB5 D082       415            pop dpl
0EB7 D083       415            pop dph;display interface
0EB9 120CF2     416           lcall Display_Working_Status
0EBC C0E0       417            push acc
0EBE 7406       417            mov a, #6
0EC0 14         417            dec a
0EC1 12028E     417            lcall ?Set_Cursor_2 ; Select column and row
0EC4 D0E0       417            pop acc
0EC6            418       ;mov(dst, src)
0EC6 85395D     418            mov x+3, TEMP_SOAK+3
0EC9 85385C     418       mov x+2, TEMP_SOAK+2
0ECC 85375B     418       mov x+1, TEMP_SOAK+1
0ECF 85365A     418       mov x,   TEMP_SOAK
0ED2 1202B8     419       lcall hex2bcd
0ED5            419       ;now the bcd num of time is stored in bcd
0ED5 C000       419            push ar0
0ED7 A863       419            mov r0, bcd+1
0ED9 1202AB     419            lcall ?Display_NUM
0EDC D000       419            pop ar0;
0EDE C000       419            push ar0
0EE0 A862       419            mov r0, bcd
0EE2 120295     419            lcall ?Display_BCD
0EE5 D000       419            pop ar0;
0EE7            420   
0EE7 200207     421           jb mf, FSM1_State0_Error_Check;check Error and continue if smaller than set time
0EEA            422           ;if temp greater
0EEA 0534       423           inc FSM1_State; go to next state            
0EEC 853A32     424           mov Time_Counter, TIME_SOAK; move the TIME_SOAK in counter and count down
0EEF 8026       425           sjmp FSM1_State0_Done
0EF1            426   
0EF1            427           FSM1_State0_Error_Check:
0EF1 E531       428           mov a, Time_Global
0EF3 B43C21     429           cjne a, #QUITTIME, FSM1_State0_Done; not time, done
0EF6            430           ;if time reached, check temp
0EF6            431       ;mov(dst, src)
0EF6 85515D     431            mov x+3, Current_Oven_Temp+3
0EF9 85505C     431       mov x+2, Current_Oven_Temp+2
0EFC 854F5B     431       mov x+1, Current_Oven_Temp+1
0EFF 854E5A     431       mov x,   Current_Oven_Temp;move current oven temp in x
0F02 756100     432           mov y+3, #0
0F05 756000     433           mov y+2, #0
0F08 755F00     434           mov y+1, #0
0F0B 755E32     435           mov y, #QUITTEMP
0F0E 1203C0     436           lcall x_lt_y; check if current oven temp is smaller than quittemp
0F11            437   
0F11 300203     438           jnb mf, FSM1_State0_Done; the oven is working properly
0F14            439           ;if not working right
0F14 0211F2     440           ljmp FSM1_WARNING
0F17            441   
0F17            442   
0F17            443   
0F17            444           FSM1_State0_Done:
0F17 021231     445               ljmp FSM1_DONE
0F1A            446   
0F1A            447   
0F1A            448       FSM1_State1:
0F1A B40102     449           cjne a, #1, JUMP_FSM1_State2
0F1D 8003       450               sjmp Start_FSM1_State1
0F1F            451           JUMP_FSM1_State2:
0F1F 020FC0     452               ljmp FSM1_State2
0F22            453           
0F22            454           Start_FSM1_State1:
0F22 D53205     455           djnz Time_Counter, FSM1_State1_Continue; decrement every 1 second
0F25            456           ;time over, change state
0F25 0534       457           inc FSM1_State; increment states
0F27 020FBD     458           ljmp FSM1_State1_Done
0F2A            459   
0F2A            460           FSM1_State1_Continue:
0F2A            461           ;next: check temp
0F2A            462           ;read temp and compare
0F2A 1206DC     463       lcall Read_Room_Temp
0F2D 120602     463       lcall Read_Oven_Temp
0F30            463   
0F30            463       ;mov(dst, src)
0F30 85515D     463            mov x+3, Current_Oven_Temp+3
0F33 85505C     463       mov x+2, Current_Oven_Temp+2
0F36 854F5B     463       mov x+1, Current_Oven_Temp+1
0F39 854E5A     463       mov x,   Current_Oven_Temp
0F3C            463       ;mov(dst, src)
0F3C 853961     463            mov y+3, TEMP_SOAK+3
0F3F 853860     463       mov y+2, TEMP_SOAK+2
0F42 85375F     463       mov y+1, TEMP_SOAK+1
0F45 85365E     463       mov y,   TEMP_SOAK
0F48            463   
0F48 1203C0     463       lcall x_lt_y   ;Update current temp info
0F4B C0E0       464            push acc
0F4D 7401       464            mov a, #1
0F4F 14         464            dec a
0F50 120290     464            lcall ?Set_Cursor_1 ; Select column and row
0F53 D0E0       464            pop acc
0F55 C083       464            push dph
0F57 C082       464            push dpl
0F59 C0E0       464            push acc
0F5B 90014B     464            mov dptr, #WORKING
0F5E 120283     464            lcall ?Send_Constant_String
0F61 D0E0       464            pop acc
0F63 D082       464            pop dpl
0F65 D083       464            pop dph
0F67 C0E0       464            push acc
0F69 7401       464            mov a, #1
0F6B 14         464            dec a
0F6C 12028E     464            lcall ?Set_Cursor_2 ; Select column and row
0F6F D0E0       464            pop acc
0F71 C083       464            push dph
0F73 C082       464            push dpl
0F75 C0E0       464            push acc
0F77 90016D     464            mov dptr, #STEP2
0F7A 120283     464            lcall ?Send_Constant_String
0F7D D0E0       464            pop acc
0F7F D082       464            pop dpl
0F81 D083       464            pop dph
0F83 120CF2     465           lcall Display_Working_Status; update time and temp on lcd
0F86            466           ;if temp is lower than expected, jump to ON
0F86 C0E0       467            push acc
0F88 7405       467            mov a, #5
0F8A 14         467            dec a
0F8B 12028E     467            lcall ?Set_Cursor_2 ; Select column and row
0F8E D0E0       467            pop acc
0F90 755A00     468            mov x+0, #low (0 % 0x10000) 
0F93 755B00     468            mov x+1, #high(0 % 0x10000) 
0F96 755C00     468            mov x+2, #low (0 / 0x10000) 
0F99 755D00     468            mov x+3, #high(0 / 0x10000) 
0F9C 85325A     469           mov x, Time_Counter
0F9F 1202B8     470       lcall hex2bcd
0FA2            470       ;now the bcd num of time is stored in bcd
0FA2 C000       470            push ar0
0FA4 A863       470            mov r0, bcd+1
0FA6 1202AB     470            lcall ?Display_NUM
0FA9 D000       470            pop ar0;
0FAB C000       470            push ar0
0FAD A862       470            mov r0, bcd
0FAF 120295     470            lcall ?Display_BCD
0FB2 D000       470            pop ar0;
0FB4            471   
0FB4 200204     472           jb mf, FSM1_State1_ON
0FB7            473           ;if temp is higher, close oven
0FB7 C2A7       474           clr OVEN 
0FB9 8002       475           sjmp FSM1_State1_Done
0FBB            476   
0FBB            477           FSM1_State1_ON:
0FBB D2A7       478           setb OVEN   ;if temp is lower, turn on oven
0FBD            479           FSM1_State1_Done:
0FBD 021231     480               ljmp FSM1_DONE
0FC0            481   
0FC0            482       FSM1_State2: ;temp ramp up until TEMP_RFLW
0FC0 B40202     483           cjne a, #2, JUMP_FSM1_State3
0FC3 8003       484               sjmp Start_FSM1_State2
0FC5            485           JUMP_FSM1_State3:
0FC5 02105F     486               ljmp FSM1_State3
0FC8            487   
0FC8            488           Start_FSM1_State2:
0FC8 D2A7       489           setb OVEN; turn on oven
0FCA            490   
0FCA            491           ;read temperature
0FCA 1206DC     492       lcall Read_Room_Temp
0FCD 120602     492       lcall Read_Oven_Temp
0FD0            492   
0FD0            492       ;mov(dst, src)
0FD0 85515D     492            mov x+3, Current_Oven_Temp+3
0FD3 85505C     492       mov x+2, Current_Oven_Temp+2
0FD6 854F5B     492       mov x+1, Current_Oven_Temp+1
0FD9 854E5A     492       mov x,   Current_Oven_Temp
0FDC            492       ;mov(dst, src)
0FDC 854161     492            mov y+3, TEMP_RFLW+3
0FDF 854060     492       mov y+2, TEMP_RFLW+2
0FE2 853F5F     492       mov y+1, TEMP_RFLW+1
0FE5 853E5E     492       mov y,   TEMP_RFLW
0FE8            492   
0FE8 1203C0     492       lcall x_lt_y
0FEB 200208     493           jb mf, FSM1_State2_Continue
0FEE            494           ;if temp reached
0FEE 0534       495           inc FSM1_State
0FF0 854232     496           mov Time_Counter, TIME_RFLW
0FF3 021231     497           ljmp FSM1_DONE
0FF6            498   
0FF6            499           FSM1_State2_Continue:
0FF6 C0E0       500            push acc
0FF8 7401       500            mov a, #1
0FFA 14         500            dec a
0FFB 120290     500            lcall ?Set_Cursor_1 ; Select column and row
0FFE D0E0       500            pop acc
1000 C083       500            push dph
1002 C082       500            push dpl
1004 C0E0       500            push acc
1006 90014B     500            mov dptr, #WORKING
1009 120283     500            lcall ?Send_Constant_String
100C D0E0       500            pop acc
100E D082       500            pop dpl
1010 D083       500            pop dph
1012 C0E0       500            push acc
1014 7401       500            mov a, #1
1016 14         500            dec a
1017 12028E     500            lcall ?Set_Cursor_2 ; Select column and row
101A D0E0       500            pop acc
101C C083       500            push dph
101E C082       500            push dpl
1020 C0E0       500            push acc
1022 90017E     500            mov dptr, #STEP3
1025 120283     500            lcall ?Send_Constant_String
1028 D0E0       500            pop acc
102A D082       500            pop dpl
102C D083       500            pop dph
102E 120CF2     501           lcall Display_Working_Status
1031 C0E0       502            push acc
1033 7406       502            mov a, #6
1035 14         502            dec a
1036 12028E     502            lcall ?Set_Cursor_2 ; Select column and row
1039 D0E0       502            pop acc
103B            503       ;mov(dst, src)
103B 85415D     503            mov x+3, TEMP_RFLW+3
103E 85405C     503       mov x+2, TEMP_RFLW+2
1041 853F5B     503       mov x+1, TEMP_RFLW+1
1044 853E5A     503       mov x,   TEMP_RFLW
1047 1202B8     504       lcall hex2bcd
104A            504       ;now the bcd num of time is stored in bcd
104A C000       504            push ar0
104C A863       504            mov r0, bcd+1
104E 1202AB     504            lcall ?Display_NUM
1051 D000       504            pop ar0;
1053 C000       504            push ar0
1055 A862       504            mov r0, bcd
1057 120295     504            lcall ?Display_BCD
105A D000       504            pop ar0;
105C            505   
105C            506           FSM1_State2_Done:
105C 021231     507               ljmp FSM1_DONE
105F            508           
105F            509            FSM1_State3: ; keep temp at TEMP_RFLW for a few time
105F B40302     510           cjne a, #3, JUMP_FSM1_State4
1062 8003       511               sjmp Start_FSM1_State3
1064            512           JUMP_FSM1_State4:
1064 021105     513               ljmp FSM1_State4
1067            514           
1067            515           Start_FSM1_State3:
1067 D53205     516           djnz Time_Counter, FSM1_State3_Continue
106A            517           ;if time's up
106A 0534       518           inc FSM1_State
106C 021102     519           ljmp FSM1_State3_Done
106F            520   
106F            521           FSM1_State3_Continue:
106F C0E0       522            push acc
1071 7401       522            mov a, #1
1073 14         522            dec a
1074 120290     522            lcall ?Set_Cursor_1 ; Select column and row
1077 D0E0       522            pop acc
1079 C083       522            push dph
107B C082       522            push dpl
107D C0E0       522            push acc
107F 90014B     522            mov dptr, #WORKING
1082 120283     522            lcall ?Send_Constant_String
1085 D0E0       522            pop acc
1087 D082       522            pop dpl
1089 D083       522            pop dph
108B C0E0       522            push acc
108D 7401       522            mov a, #1
108F 14         522            dec a
1090 12028E     522            lcall ?Set_Cursor_2 ; Select column and row
1093 D0E0       522            pop acc
1095 C083       522            push dph
1097 C082       522            push dpl
1099 C0E0       522            push acc
109B 90018F     522            mov dptr, #STEP4
109E 120283     522            lcall ?Send_Constant_String
10A1 D0E0       522            pop acc
10A3 D082       522            pop dpl
10A5 D083       522            pop dph
10A7 120CF2     523           lcall Display_Working_Status
10AA 1206DC     524       lcall Read_Room_Temp
10AD 120602     524       lcall Read_Oven_Temp
10B0            524   
10B0            524       ;mov(dst, src)
10B0 85515D     524            mov x+3, Current_Oven_Temp+3
10B3 85505C     524       mov x+2, Current_Oven_Temp+2
10B6 854F5B     524       mov x+1, Current_Oven_Temp+1
10B9 854E5A     524       mov x,   Current_Oven_Temp
10BC            524       ;mov(dst, src)
10BC 854161     524            mov y+3, TEMP_RFLW+3
10BF 854060     524       mov y+2, TEMP_RFLW+2
10C2 853F5F     524       mov y+1, TEMP_RFLW+1
10C5 853E5E     524       mov y,   TEMP_RFLW
10C8            524   
10C8 1203C0     524       lcall x_lt_y; update temp info, set or clr mf flag
10CB C0E0       525            push acc
10CD 7405       525            mov a, #5
10CF 14         525            dec a
10D0 12028E     525            lcall ?Set_Cursor_2 ; Select column and row
10D3 D0E0       525            pop acc
10D5 755A00     526            mov x+0, #low (0 % 0x10000) 
10D8 755B00     526            mov x+1, #high(0 % 0x10000) 
10DB 755C00     526            mov x+2, #low (0 / 0x10000) 
10DE 755D00     526            mov x+3, #high(0 / 0x10000) 
10E1 85325A     527           mov x, Time_Counter
10E4 1202B8     528       lcall hex2bcd
10E7            528       ;now the bcd num of time is stored in bcd
10E7 C000       528            push ar0
10E9 A863       528            mov r0, bcd+1
10EB 1202AB     528            lcall ?Display_NUM
10EE D000       528            pop ar0;
10F0 C000       528            push ar0
10F2 A862       528            mov r0, bcd
10F4 120295     528            lcall ?Display_BCD
10F7 D000       528            pop ar0;
10F9            529   
10F9            530           ;if temp is lower than expected, jump to ON
10F9 200204     531           jb mf, FSM1_State3_ON
10FC            532           ;if temp is higher, close oven
10FC C2A7       533           clr OVEN 
10FE 8002       534           sjmp FSM1_State3_Done
1100            535   
1100            536           FSM1_State3_ON:
1100 D2A7       537           setb OVEN   ;if temp is lower, turn on oven
1102            538           FSM1_State3_Done:
1102 021231     539               ljmp FSM1_DONE
1105            540           
1105            541   
1105            542       
1105            543       FSM1_State4:; cool down until safe temp
1105 B40402     544           cjne a, #4, JUMP_FSM1_State5
1108 8003       545               sjmp Start_FSM1_State4
110A            546           JUMP_FSM1_State5:
110A 0211A7     547               ljmp FSM1_State5
110D            548           
110D            549           Start_FSM1_State4:
110D C2A7       550           clr OVEN
110F            551           ;read temperature
110F 1206DC     552       lcall Read_Room_Temp
1112 120602     552       lcall Read_Oven_Temp
1115            552   
1115            552       ;mov(dst, src)
1115 85515D     552            mov x+3, Current_Oven_Temp+3
1118 85505C     552       mov x+2, Current_Oven_Temp+2
111B 854F5B     552       mov x+1, Current_Oven_Temp+1
111E 854E5A     552       mov x,   Current_Oven_Temp
1121            552       ;mov(dst, src)
1121 854961     552            mov y+3, TEMP_SAFE+3
1124 854860     552       mov y+2, TEMP_SAFE+2
1127 85475F     552       mov y+1, TEMP_SAFE+1
112A 85465E     552       mov y,   TEMP_SAFE
112D            552   
112D 1203C0     552       lcall x_lt_y
1130            553           ;if temp is smaller than TEMP_SAFE, go state 5
1130 300205     554           jnb mf, FSM1_State4_Continue
1133            555           ;if temp is smaller than expected
1133 0534       556           inc FSM1_State
1135 753200     557           mov Time_Counter, #0
1138            558   
1138            559           FSM1_State4_Continue:
1138 C0E0       560            push acc
113A 7401       560            mov a, #1
113C 14         560            dec a
113D 120290     560            lcall ?Set_Cursor_1 ; Select column and row
1140 D0E0       560            pop acc
1142 C083       560            push dph
1144 C082       560            push dpl
1146 C0E0       560            push acc
1148 90014B     560            mov dptr, #WORKING
114B 120283     560            lcall ?Send_Constant_String
114E D0E0       560            pop acc
1150 D082       560            pop dpl
1152 D083       560            pop dph
1154 C0E0       560            push acc
1156 7401       560            mov a, #1
1158 14         560            dec a
1159 12028E     560            lcall ?Set_Cursor_2 ; Select column and row
115C D0E0       560            pop acc
115E C083       560            push dph
1160 C082       560            push dpl
1162 C0E0       560            push acc
1164 9001A0     560            mov dptr, #STEP5
1167 120283     560            lcall ?Send_Constant_String
116A D0E0       560            pop acc
116C D082       560            pop dpl
116E D083       560            pop dph
1170 120CF2     561           lcall Display_Working_Status
1173 C0E0       562            push acc
1175 7405       562            mov a, #5
1177 14         562            dec a
1178 12028E     562            lcall ?Set_Cursor_2 ; Select column and row
117B D0E0       562            pop acc
117D 755A00     563            mov x+0, #low (0 % 0x10000) 
1180 755B00     563            mov x+1, #high(0 % 0x10000) 
1183 755C00     563            mov x+2, #low (0 / 0x10000) 
1186 755D00     563            mov x+3, #high(0 / 0x10000) 
1189 85465A     564           mov x, TEMP_SAFE
118C 1202B8     565           lcall hex2bcd
118F 1202B8     566       lcall hex2bcd
1192            566       ;now the bcd num of time is stored in bcd
1192 C000       566            push ar0
1194 A863       566            mov r0, bcd+1
1196 1202AB     566            lcall ?Display_NUM
1199 D000       566            pop ar0;
119B C000       566            push ar0
119D A862       566            mov r0, bcd
119F 120295     566            lcall ?Display_BCD
11A2 D000       566            pop ar0;
11A4            567   
11A4            568           FSM1_State4_Done:
11A4 021231     569               ljmp FSM1_DONE
11A7            570   
11A7            571       FSM1_State5: ; already cool done, display something, play some music
11A7 B40502     572            cjne a, #5, JUMP_FSM1_DOne
11AA 8003       573               sjmp Start_FSM1_State5
11AC            574           JUMP_FSM1_Done:
11AC 021231     575               ljmp FSM1_Done
11AF            576               
11AF            577           Start_FSM1_State5:
11AF C2A7       578           clr OVEN; double check oven is not on
11B1 C203       579           clr enable_time_global; stop counting
11B3 C208       580           clr speak_enable
11B5 C0E0       581            push acc
11B7 7401       581            mov a, #1
11B9 14         581            dec a
11BA 120290     581            lcall ?Set_Cursor_1 ; Select column and row
11BD D0E0       581            pop acc
11BF C083       581            push dph
11C1 C082       581            push dpl
11C3 C0E0       581            push acc
11C5 90014B     581            mov dptr, #WORKING
11C8 120283     581            lcall ?Send_Constant_String
11CB D0E0       581            pop acc
11CD D082       581            pop dpl
11CF D083       581            pop dph
11D1 C0E0       581            push acc
11D3 7401       581            mov a, #1
11D5 14         581            dec a
11D6 12028E     581            lcall ?Set_Cursor_2 ; Select column and row
11D9 D0E0       581            pop acc
11DB C083       581            push dph
11DD C082       581            push dpl
11DF C0E0       581            push acc
11E1 9001B1     581            mov dptr, #STEP6
11E4 120283     581            lcall ?Send_Constant_String
11E7 D0E0       581            pop acc
11E9 D082       581            pop dpl
11EB D083       581            pop dph
11ED 120CF2     582           lcall Display_Working_Status
11F0 803F       583           sjmp FSM1_Done
11F2            584   
11F2            585   
11F2            586       FSM1_WARNING:
11F2 C2A7       587           clr OVEN
11F4 C0E0       588            push acc
11F6 7401       588            mov a, #1
11F8 14         588            dec a
11F9 120290     588            lcall ?Set_Cursor_1 ; Select column and row
11FC D0E0       588            pop acc
11FE C083       588            push dph
1200 C082       588            push dpl
1202 C0E0       588            push acc
1204 9001C2     588            mov dptr, #WARNING1
1207 120283     588            lcall ?Send_Constant_String
120A D0E0       588            pop acc
120C D082       588            pop dpl
120E D083       588            pop dph
1210 C0E0       588            push acc
1212 7401       588            mov a, #1
1214 14         588            dec a
1215 12028E     588            lcall ?Set_Cursor_2 ; Select column and row
1218 D0E0       588            pop acc
121A C083       588            push dph
121C C082       588            push dpl
121E C0E0       588            push acc
1220 9001D3     588            mov dptr, #WARNING2
1223 120283     588            lcall ?Send_Constant_String
1226 D0E0       588            pop acc
1228 D082       588            pop dpl
122A D083       588            pop dph
122C C208       589           clr speak_enable
122E 753406     590           mov FSM1_State, #6
1231            591   
1231            592       FSM1_DONE:
1231 22         593       ret
1232            594   
1232            595   EN
