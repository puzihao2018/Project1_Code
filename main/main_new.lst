                  2   $LIST
0000              4   
0000              5   ;-------------------;
0000              6   ;    Const Define   ;
0000              7   ;-------------------; 
0000              8   XTAL EQU 7373000
0000              9   BAUD EQU 115200
0000             10   BRVAL EQU ((XTAL/BAUD)-16)
0000             11   
0000             12   CCU_RATE      EQU 22050      ; 100Hz, for an overflow rate of 10ms
0000             13   CCU_RELOAD    EQU ((65536-((XTAL/(2*CCU_RATE)))))
0000             14   
0000             15   ;TIMER0_RATE   EQU 4096    ; 4096Hz
0000             16   ;TIMER0_RELOAD EQU ((65536-(XTAL/(2*TIMER0_RATE))))
0000             17   TIMER1_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             18   TIMER1_RELOAD EQU ((65536-(XTAL/(2*TIMER1_RATE))))
0000             19   QUITTIME      EQU 60
0000             20   QUITTEMP      EQU 50
0000             21   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             22   
0000             23   number_off_set EQU 17200 ;the distance between each number
0000             24   ;number start at ff
0000             25   
0000             26   ;starting addressed of different sound tracks
0000             27   decimal_start  EQU 360000
0000             28   decimal_off_set EQU 24100
0000             29   decimal_playtime EQU 50000
0000             30   
0000             31   special_dec_start EQU 174000 ;numbers from 10 to 19
0000             32   special_off_set EQU 21500
0000             33   special_playtime EQU 21500;19000
0000             34   
0000             35   hundreds_start EQU 563000
0000             36   hundreds_off_set EQU 37000
0000             37   
0000             38   current_temp_is_start EQU 674000
0000             39   current_temp_playtime EQU 35000
0000             40   
0000             41   degree_start EQU 710000
0000             42   degree_playtime EQU 11018
0000             43   
0000             44   celsius_start EQU 732236
0000             45   celsius_playtime EQU 17000
0000             46   
0000             47   current_process_is_start EQU 757000
0000             48   current_process_is_playtime EQU 27000
0000             49            
0000             50   ramp_to_soak_start EQU 790000
0000             51   ramp_to_soak_playtime EQU 25000
0000             52   
0000             53   preheat_and_soak_start EQU 822000
0000             54   preheat_and_soak_playtime EQU 27000
0000             55   
0000             56   ramp_to_peak_start EQU 857000
0000             57   ramp_to_peak_playtime EQU 19000
0000             58   
0000             59   reflow_start EQU 885000
0000             60   reflow_playtime EQU 15000
0000             61   
0000             62   cooling_start EQU 906000
0000             63   cooling_playtime EQU 14000
0000             64   ;-------------------;
0000             65   ;    Ports Define   ;
0000             66   ;-------------------; 
0000             67   ;ADC01 equ P0.0; Read Room Temperature
0000             68   LCD_RS equ P0.1
0000             69   LCD_RW equ P0.2
0000             70   LCD_E  equ P0.3
0000             71   ;Soundout  P0.4
0000             72   LCD_D4 equ P0.5
0000             73   LCD_D5 equ P0.6
0000             74   LCD_D6 equ P0.7
0000             75   LCD_D7 equ P3.0
0000             76   ;          P3.1
0000             77   ;          P1.2
0000             78   Start  equ P1.3
0000             79   Stop   equ P1.4
0000             80   LED    equ P1.6
0000             81   ;ADC00 equ P1.7; Read Oven Temperature
0000             82   ;ADC03 equ P2.0; Read Keyboard1
0000             83   ;ADC02 equ P2.1; Read Keyboard0
0000             84   ;MOSI  equ P2.2
0000             85   ;MISO  equ P2.3
0000             86   FLASH_CE EQU P2.4
0000             87   ;SPICK equ P2.5
0000             88   ;WAVEOUT   P2.6
0000             89   OVEN   equ P2.7
0000             90   
0000             91   ;------------------------;
0000             92   ;    Interrupt Vectors   ;
0000             93   ;------------------------; 
0000             94   ; Reset vector
0000             95   org 0x0000
0000 020C3E      96       ljmp MainProgram
0003             97   
0003             98   ; External interrupt 0 vector, start
0003             99   org 0x0003
0003 020DDB     100            ljmp EI0_ISR
0006            101   
0006            102   ; Timer/Counter 0 overflow interrupt vector
000B            103   org 0x000B
000B 32         104            reti
000C            105   
000C            106   ; External interrupt 1 vector, stop
0013            107   org 0x0013
0013 020DE1     108            ljmp EI1_ISR
0016            109   
0016            110   ; Timer/Counter 1 overflow interrupt vector
001B            111   org 0x001B
001B 020DB4     112            ljmp Timer1_ISR
001E            113   
001E            114   ; Serial port receive/transmit interrupt vector
0023            115   org 0x0023 
0023 32         116            reti
0024            117   
0024            118   ; CCU interrupt vector
005B            119   org 0x005b 
005B 020764     120            ljmp CCU_ISR
005E            121   
005E            122   ;-----------------------;
005E            123   ;    Variables Define   ;
005E            124   ;-----------------------; 
005E            125   ;Variable_name: ds n
0030            126   dseg at 0x30
0030            127       Count10ms:    ds 1 ; Used to determine when half second has passed
0031            128       Time_Global:  ds 1 ; to store the time of whole process
0032            129       Time_Counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            130   
0033            131       FSM0_State: ds 1
0034            132       FSM1_State: ds 1
0035            133   
0035            134       Profile_Num: ds 1
0036            135   
0036            136       TEMP_SOAK:  ds 4
003A            137       TIME_SOAK:  ds 4
003E            138       TEMP_RFLW:  ds 4
0042            139       TIME_RFLW:  ds 4
0046            140       TEMP_SAFE:  ds 4
004A            141       Current_Room_Temp: ds 4
004E            142            Current_Oven_Temp: ds 4
0052            143   
0052            144       Cursor:     ds 1
0053            145       NEW_BCD:    ds 3    ; 3 digit BCD used to store current entered number
0056            146       NEW_HEX:    ds 4    ; 32 bit number of new entered number
005A            147       ;for math32.inc
005A            148       x: ds 4
005E            149       y: ds 4
0062            150       bcd: ds 5
0067            151       Count5s: ds 1
0068            152       ;z
0068            153       w:   ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
006B            154            number: ds 1;
006C            155       digits: ds 1;
006D            156            tenth: ds 1;
006E            157            individual_offest: ds 1;
006F            158       ;key
006F            159       keyin: ds 1
0070            160   
0070            161   
0070            162   ;-------------------;
0070            163   ;    Flags Define   ;
0070            164   ;-------------------; 
0070            165   ;Flag_name: dbit 1
0000            166   bseg
0000            167       FSM0_State_Changed:  dbit 1
0001            168       Main_State:          dbit 1 ; 0 for setting, 1 for reflowing
0002            169       ;for math32.inc
0002            170       mf: dbit 1
0003            171       enable_time_global: dbit 1
0004            172       half_seconds_flag: dbit 1 ; 500ms in double rate mode
0005            173           nodigit: dbit 1 ; if playing from 10 to 19 then we don't need to
0006            174                       ;play the last digit
0006            175            skiphundred: dbit 1
0007            176            skiptenth: dbit 1
0008            177   ;-----------------------;
0008            178   ;     Include Files     ;
0008            179   ;-----------------------; 
0008            180   ;$NOLIST
                 -1       $include(lcd_4bit.inc) 
005E              1   cseg
005E              2   
005E 30313233     3   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
006E 30313233     4   hex: db '0123456789abcdef',0
     34353637
     38396162
     63646566
     00
007F              5   
007F              6   ;LCD                '1234567890123456'
007F 57454C43     7   WELCOME1:        db 'WELCOME!        '   ,0
     4F4D4521
     20202020
     20202020
     00
0090 53757065     8   WELCOME2:        db 'Super Reflow!   '   ,0
     72205265
     666C6F77
     21202020
     00
00A1 53657474     9   MAIN_FACE1:      db 'Setting: Prof   '   ,0
     696E673A
     2050726F
     66202020
     00
00B2 53746172    10   MAIN_FACE2: db 'Start       Stop'   ,0
     74202020
     20202020
     53746F70
     00
00C3 53544D50    11   SETTING1:        db 'STMP:   STM:   s'   ,0
     3A202020
     53544D3A
     20202073
     00
00D4 52544D50    12   SETTING2:   db 'RTMP:   RTM:   s'   ,0
     3A202020
     52544D3A
     20202073
     00
00E5 4F4C443A    13   MODIFY_DOWN:db 'OLD:    NEW:    '   ,0
     20202020
     4E45573A
     20202020
     00
00F6 4D4F4449    14   MODIFY1:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
0107 4D4F4449    15   MODIFY2:         db 'MODIFY:TIME_SOAK'   ,0
     46593A54
     494D455F
     534F414B
     00
0118 4D4F4449    16   MODIFY3:         db 'MODIFY:TEMP_RFLW'   ,0
     46593A54
     454D505F
     52464C57
     00
0129 4D4F4449    17   MODIFY4:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
013A 4D4F4449    18   MODIFY5:    db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
014B 54454D50    19   WORKING:    db 'TEMP:   TIME:   '   ,0
     3A202020
     54494D45
     3A202020
     00
015C 53544D50    20   STEP1:           db 'STMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
016D 53544D3A    21   STEP2:      db 'STM:   s SOAKING'   ,0
     20202073
     20534F41
     4B494E47
     00
017E 52544D50    22   STEP3:      db 'RTMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
018F 52544D3A    23   STEP4:      db 'RTM:   s REFLOW '   ,0
     20202073
     20524546
     4C4F5720
     00
01A0 5346543A    24   STEP5:      db 'SFT:     COOLING'   ,0
     20202020
     20434F4F
     4C494E47
     00
01B1 20202020    25   STEP6:      db '         FINISH '   ,0
     20202020
     2046494E
     49534820
     00
01C2 4572726F    26   WARNING1:   db 'Error Warning!  '   ,0
     72205761
     726E696E
     67212020
     00
01D3 54454D50    27   WARNING2:   db 'TEMP Sensing ERR'   ,0
     2053656E
     73696E67
     20455252
     00
01E4             28   ;---------------------------------;
01E4             29   ;           Basic Macros          ;
01E4             30   ;---------------------------------;
                 31   LCD_Initailize mac
                 32   	lcall LCD_4BIT
                 33   endmac
01E4             34   
                 35   LCD_WriteData mac
                 36   	mov a, %0
                 37   	lcall ?LCD_WriteData
                 38   endmac
01E4             39            
                 40   LCD_WriteCommand mac
                 41   	mov a, %0
                 42   	lcall ?LCD_WriteCommand
                 43   endmac
01E4             44   
                 45   LCD_Send_Constant_String mac
                 46   	push dph
                 47   	push dpl
                 48   	push acc
                 49   	mov dptr, %0
                 50   	lcall ?Send_Constant_String
                 51   	pop acc
                 52   	pop dpl
                 53   	pop dph
                 54   endmac
01E4             55   
                 56   LCD_Set_Cursor mac
                 57   	push acc
                 58   	mov a, #%1
                 59   	dec a
                 60   	lcall ?Set_Cursor_%0 ; Select column and row
                 61   	pop acc
                 62   endmac
01E4             63   
                 64   LCD_Display_BCD mac
                 65   	push ar0
                 66   	mov r0, %0
                 67   	lcall ?Display_BCD
                 68   	pop ar0
                 69   endmac
01E4             70   
                 71   LCD_Display_NUM mac
                 72   	push ar0
                 73   	mov r0, %0
                 74   	lcall ?Display_NUM
                 75   	pop ar0
                 76   endmac
01E4             77   
                 78   LCD_Display_Char mac
                 79   	push acc
                 80   	mov a, %0
                 81   	lcall ?LCD_WriteData
                 82   	pop acc
                 83   endmac
01E4             84   
                 85   Wait_Milli_Seconds mac
                 86   	push AR2
                 87   	mov R2, %0
                 88   	lcall ?Wait_Milli_Seconds
                 89   	pop AR2
                 90   endmac
01E4             91   
01E4             92   ;---------------------------------;
01E4             93   ;         Interface Macros        ;
01E4             94   ;---------------------------------;
01E4             95   
                 96   LCD_INTERFACE_WELCOME mac
                 97   	LCD_Set_Cursor(1,1)
                 98   	LCD_Send_Constant_String(#WELCOME1)
                 99   	LCD_Set_Cursor(2,1)
                100   	LCD_Send_Constant_String(#WELCOME2)
                101   endmac
01E4            102   
                103   LCD_INTERFACE_MAIN mac
                104   	LCD_Set_Cursor(1,1)
                105   	LCD_Send_Constant_String(#MAIN_FACE1)
                106   	LCD_Set_Cursor(2,1)
                107   	LCD_Send_Constant_String(#MAIN_FACE2)
                108   	LCD_Set_Cursor(1,15); Profile number
                109   	LCD_Display_BCD(Profile_Num)
                110   endmac
01E4            112   
                113   LCD_INTERFACE_SETTING mac
                114   	LCD_Set_Cursor(1,1)
                115   	LCD_Send_Constant_String(#SETTING1)
                116   	LCD_Set_Cursor(2,1)
                117   	LCD_Send_Constant_String(#SETTING2)
                118   endmac
01E4            119   
                120   LCD_INTERFACE_MODIFY1 mac
                121   	LCD_Set_Cursor(1,1)
                122   	LCD_Send_Constant_String(#MODIFY1)
                123   	LCD_Set_Cursor(2,1)
                124   	LCD_Send_Constant_String(#MODIFY_DOWN)
                125   endmac
01E4            126   
                127   LCD_INTERFACE_MODIFY2 mac
                128   	LCD_Set_Cursor(1,1)
                129   	LCD_Send_Constant_String(#MODIFY2)
                130   	LCD_Set_Cursor(2,1)
                131   	LCD_Send_Constant_String(#MODIFY_DOWN)
                132   endmac
01E4            133   
                134   LCD_INTERFACE_MODIFY3 mac
                135   	LCD_Set_Cursor(1,1)
                136   	LCD_Send_Constant_String(#MODIFY3)
                137   	LCD_Set_Cursor(2,1)
                138   	LCD_Send_Constant_String(#MODIFY_DOWN)
                139   endmac
01E4            140   
                141   LCD_INTERFACE_MODIFY4 mac
                142   	LCD_Set_Cursor(1,1)
                143   	LCD_Send_Constant_String(#MODIFY4)
                144   	LCD_Set_Cursor(2,1)
                145   	LCD_Send_Constant_String(#MODIFY_DOWN)
                146   endmac
01E4            147   
                148   LCD_INTERFACE_MODIFY5 mac
                149   	LCD_Set_Cursor(1,1)
                150   	LCD_Send_Constant_String(#MODIFY5)
                151   	LCD_Set_Cursor(2,1)
                152   	LCD_Send_Constant_String(#MODIFY_DOWN)
                153   endmac
01E4            154   
                155   LCD_INTERFACE_STEP1 mac
                156   	LCD_Set_Cursor(1,1)
                157   	LCD_Send_Constant_String(#WORKING)
                158   	LCD_Set_Cursor(2,1)
                159   	LCD_Send_Constant_String(#STEP1)
                160   endmac
01E4            161   
                162   LCD_INTERFACE_STEP2 mac
                163   	LCD_Set_Cursor(1,1)
                164   	LCD_Send_Constant_String(#WORKING)
                165   	LCD_Set_Cursor(2,1)
                166   	LCD_Send_Constant_String(#STEP2)
                167   endmac
01E4            168   
                169   LCD_INTERFACE_STEP3 mac
                170   	LCD_Set_Cursor(1,1)
                171   	LCD_Send_Constant_String(#WORKING)
                172   	LCD_Set_Cursor(2,1)
                173   	LCD_Send_Constant_String(#STEP3)
                174   endmac
01E4            175   
                176   LCD_INTERFACE_STEP4 mac
                177   	LCD_Set_Cursor(1,1)
                178   	LCD_Send_Constant_String(#WORKING)
                179   	LCD_Set_Cursor(2,1)
                180   	LCD_Send_Constant_String(#STEP4)
                181   endmac
01E4            182   
                183   LCD_INTERFACE_STEP5 mac
                184   	LCD_Set_Cursor(1,1)
                185   	LCD_Send_Constant_String(#WORKING)
                186   	LCD_Set_Cursor(2,1)
                187   	LCD_Send_Constant_String(#STEP5)
                188   endmac
01E4            189   
                190   LCD_INTERFACE_STEP6 mac
                191   	LCD_Set_Cursor(1,1)
                192   	LCD_Send_Constant_String(#WORKING)
                193   	LCD_Set_Cursor(2,1)
                194   	LCD_Send_Constant_String(#STEP6)
                195   endmac
01E4            196   
                197   LCD_INTERFACE_WARNING mac
                198   	LCD_Set_Cursor(1,1)
                199   	LCD_Send_Constant_String(#WARNING1)
                200   	LCD_Set_Cursor(2,1)
                201   	LCD_Send_Constant_String(#WARNING2)
                202   endmac
01E4            203   
01E4            204   
01E4            205   Wait10us:
01E4 7812       206       mov R0, #18
01E6 D8FE       207       djnz R0, $ ; 2 machine cycles-> 2*0.27126us*18=10us
01E8 22         208            ret
01E9            209   ;---------------------------------;
01E9            210   ; Wait 40 microseconds            ;
01E9            211   ;---------------------------------;
01E9            212   Wait40uSec:
01E9 C000       213            push AR0
01EB 784A       214            mov R0, #74
01ED            215   L0: 
01ED D8FE       216            djnz R0, L0 ; 2 cycles->2*271.26ns*74=40us
01EF D000       217            pop AR0
01F1 22         218       ret
01F2            219   
01F2            220   ;---------------------------------;
01F2            221   ; Wait 500 microseconds           ;
01F2            222   ;---------------------------------;
01F2            223   WaitHalfSec:
01F2 7A28       224       mov R2, #40
01F4 79FA       225   H3: mov R1, #250
01F6 78B8       226   H2: mov R0, #184
01F8 D8FE       227   H1: djnz R0, H1 ; 2 machine cycles-> 2*0.27126us*184=100us
01FA D9FA       228       djnz R1, H2 ; 100us*250=0.025s
01FC DAF6       229       djnz R2, H3 ; 0.025s*20=0.5s
01FE 22         230       ret
01FF            231   
01FF            232   ;---------------------------------;
01FF            233   ; Wait 'R2' milliseconds          ;
01FF            234   ;---------------------------------;
01FF            235   ?Wait_Milli_Seconds:
01FF C000       236            push AR0
0201 C001       237            push AR1
0203 790A       238   L3: mov R1, #10
0205 78B8       239   L2: mov R0, #184
0207 D8FE       240   L1: djnz R0, L1 ; 2 cycles->2*271.26ns*184=100us
0209 D9FA       241       djnz R1, L2 ; 100us*10=1ms
020B DAF6       242       djnz R2, L3 ; number of millisecons to wait passed in R2
020D D001       243       pop AR1
020F D000       244       pop AR0
0211 22         245       ret
0212            246            
0212            247   ;---------------------------------;
0212            248   ; Toggles the 'E' pin in the LCD  ;
0212            249   ;---------------------------------;
0212            250   LCD_pulse:
0212 D283       251            setb LCD_E
0214 1201E9     252            lcall Wait40uSec
0217 C283       253            clr LCD_E
0219 1201E9     254       lcall Wait40uSec
021C 22         255       ret
021D            256   
021D            257   ;---------------------------------;
021D            258   ; Writes acc to LCD in 4-bit mode ;
021D            259   ;---------------------------------;
021D            260   LCD_byte:
021D            261            ; Write high 4 bits first
021D A2E7       262            mov c, ACC.7
021F 92B0       263            mov LCD_D7, c
0221 A2E6       264            mov c, ACC.6
0223 9287       265            mov LCD_D6, c
0225 A2E5       266            mov c, ACC.5
0227 9286       267            mov LCD_D5, c
0229 A2E4       268            mov c, ACC.4
022B 9285       269            mov LCD_D4, c
022D 120212     270       lcall LCD_pulse
0230            271            ; Write low 4 bits next
0230 A2E3       272            mov c, ACC.3
0232 92B0       273            mov LCD_D7, c
0234 A2E2       274            mov c, ACC.2
0236 9287       275            mov LCD_D6, c
0238 A2E1       276            mov c, ACC.1
023A 9286       277            mov LCD_D5, c
023C A2E0       278            mov c, ACC.0
023E 9285       279            mov LCD_D4, c
0240 120212     280       lcall LCD_pulse
0243 22         281            ret
0244            282   
0244            283   ;---------------------------------;
0244            284   ; Write data to LCD               ;
0244            285   ;---------------------------------;
0244            286   ?LCD_WriteData:
0244 D281       287            setb LCD_RS
0246 02021D     288            ljmp LCD_byte
0249            289   
0249            290   ;---------------------------------;
0249            291   ; Write command to LCD            ;
0249            292   ;---------------------------------;
0249            293   ?LCD_WriteCommand:
0249 C281       294            clr LCD_RS
024B 02021D     295            ljmp LCD_byte
024E            296   
024E            297   ;---------------------------------;
024E            298   ; Configure LCD in 4-bit mode     ;
024E            299   ;---------------------------------;
024E            300   LCD_4BIT:
024E C283       301            clr LCD_E   ; Resting state of LCD's enable pin is zero
0250 C282       302            clr LCD_RW  ; We are only writing to the LCD in this program
0252            303            
0252            304            ; After power on, let the LCD start up before initializing
0252 C002       305            push AR2
0254 7A28       305            mov R2, #40
0256 1201FF     305            lcall ?Wait_Milli_Seconds
0259 D002       305            pop AR2
025B            306            
025B            307            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
025B 7433       308            mov a, #0x33
025D 120249     308            lcall ?LCD_WriteCommand
0260 7433       309            mov a, #0x33
0262 120249     309            lcall ?LCD_WriteCommand
0265 7432       310            mov a, #0x32
0267 120249     310            lcall ?LCD_WriteCommand ; change to 4-bit mode
026A            311   
026A            312            ; Configure the LCD
026A 7428       313            mov a, #0x28
026C 120249     313            lcall ?LCD_WriteCommand
026F 740C       314            mov a, #0x0c
0271 120249     314            lcall ?LCD_WriteCommand
0274 7401       315            mov a, #0x01
0276 120249     315            lcall ?LCD_WriteCommand ;  Clear screen command (takes some time)
0279            316   
0279            317       ;Wait for the clear screen command to finish.
0279 C002       318            push AR2
027B 7A02       318            mov R2, #2
027D 1201FF     318            lcall ?Wait_Milli_Seconds
0280 D002       318            pop AR2
0282 22         319       ret
0283            320   
0283            321   ;---------------------------------;
0283            322   ; Send a constant string to LCD   ;
0283            323   ;---------------------------------;
0283            324   ?Send_Constant_String:
0283 E4         325       clr a
0284 93         326       movc a, @a+dptr
0285 6006       327       jz ?Send_Constant_String_Done
0287 120244     328       lcall ?LCD_WriteData
028A A3         329       inc dptr
028B 80F6       330       sjmp ?Send_Constant_String
028D            331   ?Send_Constant_String_Done:
028D 22         332       ret  
028E            333   
028E            334   ;---------------------------------;
028E            335   ; Set LCD cursor at row, column   ;
028E            336   ;---------------------------------;
028E            337   ?Set_Cursor_2:
028E 4440       338            orl a, #01000000B
0290            339   ?Set_Cursor_1:
0290 4480       340            orl a, #10000000B
0292 020249     341            ljmp ?LCD_WriteCommand ; Select column and row
0295            342   
0295            343   ;---------------------------------;
0295            344   ; Display a BCD number in the LCD ;
0295            345   ;---------------------------------;
0295            346   ?Display_BCD:
0295 C0E0       347            push acc
0297            348            ; Write most significant digit
0297 E8         349            mov a, r0
0298 C4         350            swap a
0299 540F       351            anl a, #0fh
029B 4430       352            orl a, #30h
029D 120244     353            lcall ?LCD_WriteData
02A0            354            ; write least significant digit
02A0 E8         355            mov a, r0
02A1 540F       356            anl a, #0fh
02A3 4430       357            orl a, #30h
02A5 120244     358            lcall ?LCD_WriteData
02A8 D0E0       359            pop acc
02AA 22         360            ret
02AB            361   
02AB            362   ?Display_NUM:
02AB C0E0       363            push acc
02AD E8         364            mov a, R0
02AE 540F       365            anl a, #0fh
02B0 4430       366            orl a, #30h
02B2 120244     367            lcall ?LCD_WriteData
02B5 D0E0       368            pop acc
02B7            369   
02B7 22         370            ret
                 -1       $include(math32.inc)
                559   $LIST
                 -1       $include(LPC9351.inc)
0528              1   cseg
0528              2   
0528              3   ;---------------------------------;
0528              4   ;           Basic Macros          ;
0528              5   ;---------------------------------;
                  6   Ports_Initialize mac
                  7       lcall Ports_Init
                  8   endmac
0528              9   
                 10   Clock_Double mac
                 11       lcall _Clock_Double
                 12   endmac
0528             13   
                 14   ADC_Initialize mac
                 15       lcall InitADC
                 16   endmac
0528             17   
0528             18   ;---------------------------------;
0528             19   ;            Functions            ;
0528             20   ;---------------------------------;
0528             21   _Clock_Double:
0528 C0E0        22       push acc
052A 90FFDE      23       mov dptr, #CLKCON
052D E0          24       movx a, @dptr
052E 4408        25       orl a, #00001000B ; double the clock speed to 14.746MHz
0530 F0          26       movx @dptr,a
0531 D0E0        27       pop acc
0533 22          28       ret
0534             29   
0534             30   ;---------------------------------;
0534             31   ; Initial configuration of ports. ;
0534             32   ; After reset the default for the ;
0534             33   ; pins is 'Open Drain'.  This     ;
0534             34   ; routine changes them pins to    ;
0534             35   ; Quasi-bidirectional like in the ;
0534             36   ; original 8051.                  ;
0534             37   ; Notice that P1.2 and P1.3 are   ;
0534             38   ; always 'Open Drain'. If those   ;
0534             39   ; pins are to be used as output   ;
0534             40   ; they need a pull-up resistor.   ;
0534             41   ;---------------------------------;
0534             42   Ports_Init:
0534             43       ; Configure all the ports in bidirectional mode:
0534 758400      44       mov P0M1, #00H
0537 758500      45       mov P0M2, #00H
053A 759100      46       mov P1M1, #00H
053D 759200      47       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0540 75A400      48       mov P2M1, #00H
0543 75A500      49       mov P2M2, #00H
0546 75B100      50       mov P3M1, #00H
0549 75B200      51       mov P3M2, #00H
054C 22          52            ret
054D             53   
054D             54   InitADC:
054D             55            ; ADC0_0 is connected to P1.7
054D             56            ; ADC0_1 is connected to P0.0
054D             57            ; ADC0_2 is connected to P2.1
054D             58            ; ADC0_3 is connected to P2.0
054D             59       ; Configure pins P1.7, P0.0, P2.1, and P2.0 as inputs
054D 438401      60       orl P0M1, #00000001b
0550 5385FE      61       anl P0M2, #11111110b
0553 439180      62       orl P1M1, #10000000b
0556 53927F      63       anl P1M2, #01111111b
0559 43A403      64       orl P2M1, #00000011b
055C 53A5FC      65       anl P2M2, #11111100b
055F             66            ; Setup ADC0
055F D2C2        67            setb BURST0 ; Autoscan continuos conversion mode
0561 75A120      68            mov     ADMODB,#0x20 ;ADC0 clock is 7.3728MHz/2
0564 75A30F      69            mov     ADINS,#0x0f ; Select the four channels of ADC0 for conversion
0567 758E05      70            mov     ADCON0,#0x05 ; Enable the converter and start immediately
056A             71            ; Wait for first conversion to complete
056A             72   InitADC_L1:
056A E58E        73            mov     a,ADCON0
056C 30E3FB      74            jnb     acc.3,InitADC_L1
056F 22          75            ret
                 76   DO_NOTHING mac
                 77   	NOP
                 78   endmac
                 78   $LIST
                 -1       $include(serial.inc)
0570              1   CSEG
0570              2   
0570              3   
0570              4   ;---------------------------------;
0570              5   ;           Basic Macros          ;
0570              6   ;---------------------------------;
                  7   Serial_Initialize mac
                  8   	;Serial_Initialize()
                  9       lcall _Serial_Initialize
                 10   endmac
0570             11   
                 12   Serial_Send_Char mac
                 13       mov a, %0
                 14       lcall putchar
                 15   endmac
0570             16   
                 17   Serial_Read_Char mac
                 18   	;Serial_Read_Char(direct)
                 19       lcall getchar
                 20       mov %0, a
                 21   endmac
0570             22   
                 23   Serial_Send_Newline mac
                 24   	lcall Send_NewLine
                 25   endmac
0570             26   
                 27   Serial_Send_BCD mac
                 28   	push ar0
                 29   	mov r0, %0
                 30   	lcall ?Send_BCD
                 31   	pop ar0
                 32   endmac
0570             33   
                 34   Serial_Send_Constant_String mac
                 35   	mov dptr, %0
                 36   	lcall SendString
                 37   endmac
0570             38   
0570             39   ;---------------------------------;
0570             40   ; Initialize the serial port      ;
0570             41   ;---------------------------------;
0570             42   _Serial_Initialize:
0570 75BD00      43            mov     BRGCON,#0x00
0573 75BF00      44            mov     BRGR1,#high(BRVAL)
0576 75BE30      45            mov     BRGR0,#low(BRVAL)
0579 75BD03      46            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
057C 759852      47            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
057F             48            ; Make sure that TXD(P1.0) and RXD(P1.1) are configured as bidrectional I/O
057F 5391FC      49            anl     P1M1,#11111100B
0582 5392FC      50            anl     P1M2,#11111100B
0585 22          51            ret
0586             52   
0586             53   ;---------------------------------;
0586             54   ; Sends a byte via serial port    ;
0586             55   ;---------------------------------;
0586             56   putchar:
0586 109902      57            jbc     TI,putchar_L1
0589 80FB        58            sjmp putchar
058B             59   putchar_L1:
058B F599        60            mov     SBUF,a
058D 22          61            ret
058E             62   
058E             63   SendString:
058E E4          64       clr a
058F 93          65       movc a, @a+dptr
0590 6006        66       jz SendString_L1
0592 120586      67       lcall putchar
0595 A3          68       inc dptr
0596 80F6        69       sjmp SendString  
0598             70   SendString_L1:
0598 22          71            ret
0599             72   
0599             73   ;---------------------------------;
0599             74   ; Send a BCD number to PuTTY      ;
0599             75   ;---------------------------------;
0599             76   ?Send_BCD:
0599 C0E0        77            push acc
059B             78            ; Write most significant digit
059B E8          79            mov a, r0
059C C4          80            swap a
059D 540F        81            anl a, #0fh
059F 4430        82            orl a, #30h
05A1 120586      83            lcall putchar
05A4             84            ; write least significant digit
05A4 E8          85            mov a, r0
05A5 540F        86            anl a, #0fh
05A7 4430        87            orl a, #30h
05A9 120586      88            lcall putchar
05AC D0E0        89            pop acc
05AE 22          90            ret
05AF             91   
05AF             92   Send_NewLine:
05AF 740D        93            mov a, #'\r'
05B1 120586      94            lcall putchar
05B4 740A        95            mov a, #'\n'
05B6 120586      96            lcall putchar   
05B9 22          97            ret
05BA             98   
05BA             99   
05BA            100   SendTemp0:
05BA 90005E     101            mov dptr, #HexAscii 
05BD            102            
05BD            103            
05BD            104            
05BD E565       105            mov a, bcd+3
05BF C4         106            swap a
05C0 540F       107            anl a, #0xf
05C2 93         108            movc a, @a+dptr
05C3 120586     109            lcall putchar
05C6 E565       110            mov a, bcd+3
05C8 540F       111            anl a, #0xf
05CA 93         112            movc a, @a+dptr
05CB 120586     113            lcall putchar
05CE            114            
05CE E564       115            mov a, bcd+2
05D0 C4         116            swap a
05D1 540F       117            anl a, #0xf
05D3 93         118            movc a, @a+dptr
05D4 120586     119            lcall putchar
05D7 E564       120            mov a, bcd+2
05D9 540F       121            anl a, #0xf
05DB 93         122            movc a, @a+dptr
05DC 120586     123            lcall putchar
05DF            124            
05DF E563       125            mov a, bcd+1
05E1 C4         126            swap a
05E2 540F       127            anl a, #0xf
05E4 93         128            movc a, @a+dptr
05E5 120586     129            lcall putchar
05E8 E563       130            mov a, bcd+1
05EA 540F       131            anl a, #0xf
05EC 93         132            movc a, @a+dptr
05ED 120586     133            lcall putchar
05F0            134   
05F0            135   
05F0 E562       136            mov a, bcd+0
05F2 C4         137            swap a
05F3 540F       138            anl a, #0xf
05F5 93         139            movc a, @a+dptr
05F6 120586     140            lcall putchar
05F9 E562       141            mov a, bcd+0
05FB 540F       142            anl a, #0xf
05FD 93         143            movc a, @a+dptr
05FE 120586     144            lcall putchar
0601 22         145            ret
                 -1       $include(temperature.inc)
0602              1   cseg
0602              2   
0602              3   
0602              4   
0602              5   Read_Oven_Temp:
0602              6            ; Take 256 (4^4) consecutive measurements of ADC0 channel 0 at about 10 us intervals and accumulate in x
0602 755A00       7            mov x+0, #low (0 % 0x10000) 
0605 755B00       7            mov x+1, #high(0 % 0x10000) 
0608 755C00       7            mov x+2, #low (0 / 0x10000) 
060B 755D00       7            mov x+3, #high(0 / 0x10000) 
060E 85C75A       8       mov x+0, ad0dat2
0611 7FFF         9            mov R7, #255
0613 1201E4      10       lcall Wait10us
0616             11   accumulate_loop0:
0616 85C75E      12       mov y+0, ad0dat2
0619 755F00      13       mov y+1, #0
061C 756000      14       mov y+2, #0
061F 756100      15       mov y+3, #0
0622 12037D      16       lcall add32
0625 1201E4      17       lcall Wait10us
0628 DFEC        18            djnz R7, accumulate_loop0
062A             19            
062A             20            ; Now divide by 16 (2^4)
062A 755E10      21            mov y+0, #low (16 % 0x10000) 
062D 755F00      21            mov y+1, #high(16 % 0x10000) 
0630 756000      21            mov y+2, #low (16 / 0x10000) 
0633 756100      21            mov y+3, #high(16 / 0x10000) 
0636 1204BF      22            lcall div32
0639             23            ; x has now the 12-bit representation of the temperature
0639             24            
0639             25            ; Convert to temperature (C)
0639 755EE8      26            mov y+0, #low (33000 % 0x10000) 
063C 755F80      26            mov y+1, #high(33000 % 0x10000) 
063F 756000      26            mov y+2, #low (33000 / 0x10000) 
0642 756100      26            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
0645 120432      27            lcall mul32
0648 755E00      28            mov y+0, #low (((1<<12)) % 0x10000) 
064B 755F10      28            mov y+1, #high(((1<<12)) % 0x10000) 
064E 756000      28            mov y+2, #low (((1<<12)) / 0x10000) 
0651 756100      28            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
0654 1204BF      29            lcall div32
0657 755E3C      30            mov y+0, #low (60 % 0x10000) 
065A 755F00      30            mov y+1, #high(60 % 0x10000) 
065D 756000      30            mov y+2, #low (60 / 0x10000) 
0660 756100      30            mov y+3, #high(60 / 0x10000) 
0663 12039E      31            lcall sub32
0666             32   
0666             33            ;mov32(Current_Oven_Volt,x); store the hex value of voltage
0666             34            
0666 755E0E      35            mov y+0, #low (7438 % 0x10000) 
0669 755F1D      35            mov y+1, #high(7438 % 0x10000) 
066C 756000      35            mov y+2, #low (7438 / 0x10000) 
066F 756100      35            mov y+3, #high(7438 / 0x10000) 
0672 120432      36            lcall mul32
0675 755E10      37            mov y+0, #low (10000 % 0x10000) 
0678 755F27      37            mov y+1, #high(10000 % 0x10000) 
067B 756000      37            mov y+2, #low (10000 / 0x10000) 
067E 756100      37            mov y+3, #high(10000 / 0x10000) 
0681 1204BF      38            lcall div32
0684             39            ;now we got the relateive temp number in hex
0684             40   
0684             41       ;mov(dst, src)
0684 854D61      41            mov y+3, Current_Room_Temp+3
0687 854C60      41       mov y+2, Current_Room_Temp+2
068A 854B5F      41       mov y+1, Current_Room_Temp+1
068D 854A5E      41       mov y,   Current_Room_Temp
0690 12037D      42            lcall add32
0693             43            ;now we got the true value of oven in hex
0693 1202B8      44            lcall hex2bcd
0696 1205BA      45            lcall SendTemp0; send to PC through serial port
0699 1205AF      46            lcall Send_Newline
069C 755E64      47            mov y+0, #low (100 % 0x10000) 
069F 755F00      47            mov y+1, #high(100 % 0x10000) 
06A2 756000      47            mov y+2, #low (100 / 0x10000) 
06A5 756100      47            mov y+3, #high(100 / 0x10000) 
06A8 1204BF      48            lcall div32;divide by 100 to get the value in integer
06AB             49            ; now x contains the value in hex
06AB 755E5E      50            mov y+0, #low (350 % 0x10000) 
06AE 755F01      50            mov y+1, #high(350 % 0x10000) 
06B1 756000      50            mov y+2, #low (350 / 0x10000) 
06B4 756100      50            mov y+3, #high(350 / 0x10000) 
06B7 1203C0      51            lcall x_lt_y
06BA 200203      52            jb mf, Temp_OK
06BD             53            ;if not ok
06BD 020602      54            ljmp Read_Oven_Temp;re-read the value
06C0             55   
06C0             56            Temp_OK:
06C0             57       ;mov(dst, src)
06C0 855D51      57            mov Current_Oven_Temp+3, x+3
06C3 855C50      57       mov Current_Oven_Temp+2, x+2
06C6 855B4F      57       mov Current_Oven_Temp+1, x+1
06C9 855A4E      57       mov Current_Oven_Temp,   x
06CC 22          58            ret
06CD             59   
06CD             60   Read_Room_Temp:
06CD             61            
06CD 755A00      62            mov x+0, #low (0 % 0x10000) 
06D0 755B00      62            mov x+1, #high(0 % 0x10000) 
06D3 755C00      62            mov x+2, #low (0 / 0x10000) 
06D6 755D00      62            mov x+3, #high(0 / 0x10000) 
06D9 85C75A      63       mov x+0, ad0dat2
06DC 7FFF        64            mov R7, #255
06DE 1201E4      65       lcall Wait10us
06E1             66       
06E1             67   accumulate_loop1:
06E1 85F45E      68       mov y+0, ad0dat3
06E4 755F00      69       mov y+1, #0
06E7 756000      70       mov y+2, #0
06EA 756100      71       mov y+3, #0
06ED 12037D      72       lcall add32
06F0 1201E4      73       lcall Wait10us
06F3 DFEC        74            djnz R7, accumulate_loop1
06F5             75            
06F5             76            ; Now divide by 16 (2^4)
06F5 755E10      77            mov y+0, #low (16 % 0x10000) 
06F8 755F00      77            mov y+1, #high(16 % 0x10000) 
06FB 756000      77            mov y+2, #low (16 / 0x10000) 
06FE 756100      77            mov y+3, #high(16 / 0x10000) 
0701 1204BF      78            lcall div32
0704             79            ; x has now the 12-bit representation of the temperature
0704             80            
0704             81            ; Convert to temperature (C)
0704 755EE8      82            mov y+0, #low (33000 % 0x10000) 
0707 755F80      82            mov y+1, #high(33000 % 0x10000) 
070A 756000      82            mov y+2, #low (33000 / 0x10000) 
070D 756100      82            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
0710 120432      83            lcall mul32
0713 755E00      84            mov y+0, #low (((1<<12)) % 0x10000) 
0716 755F10      84            mov y+1, #high(((1<<12)) % 0x10000) 
0719 756000      84            mov y+2, #low (((1<<12)) / 0x10000) 
071C 756100      84            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
071F 1204BF      85            lcall div32
0722 755E3C      86            mov y+0, #low (60 % 0x10000) 
0725 755F00      86            mov y+1, #high(60 % 0x10000) 
0728 756000      86            mov y+2, #low (60 / 0x10000) 
072B 756100      86            mov y+3, #high(60 / 0x10000) 
072E 12039E      87            lcall sub32
0731             88            
0731             89            ;now we got the voltage value
0731             90            ;mov32(Current_Room_Volt,x)
0731             91            
0731 755EA4      92            mov y+0, #low (27300 % 0x10000) 
0734 755F6A      92            mov y+1, #high(27300 % 0x10000) 
0737 756000      92            mov y+2, #low (27300 / 0x10000) 
073A 756100      92            mov y+3, #high(27300 / 0x10000) 
073D 12039E      93            lcall sub32
0740             94            ;now we got the temperature
0740             95       ;mov(dst, src)
0740 855D4D      95            mov Current_Room_Temp+3, x+3
0743 855C4C      95       mov Current_Room_Temp+2, x+2
0746 855B4B      95       mov Current_Room_Temp+1, x+1
0749 855A4A      95       mov Current_Room_Temp,   x
074C             96            
074C 22          97            ret
                 -1       $include(speaker.inc)
                457   $LIST
                 -1       $include(key.inc)
0B8E              1   cseg
0B8E              2   
0B8E              3   
0B8E              4   ;-----------------------;
0B8E              5   ;    Functions Define   ;
0B8E              6   ;-----------------------; 
0B8E              7   
0B8E              8   ;Key_Read: if read, return the button readed.
0B8E              9   ;Return 0 if read nothing.
0B8E             10   Key_Read:
0B8E C0E0        11       push acc
0B90 120B9F      12       lcall ADC_to_PB; read lower 8 button
0B93 E56F        13       mov a, keyin
0B95 B40001      14       cjne a, #0, Continue_Read_Key; if nothing, continue read key
0B98 22          15       ret; if read successfully, return
0B99             16       Continue_Read_Key:
0B99 120BF0      17       lcall ADC_to_PB_1
0B9C D0E0        18            pop acc
0B9E 22          19       ret
0B9F             20   
0B9F             21   ADC_to_PB:
0B9F 756F00      22       mov keyin, #0;clear input
0BA2             23            ; Check PB6
0BA2 C3          24            clr c
0BA3 E5C5        25            mov a, AD0DAT0
0BA5 94A3        26            subb a, #(173-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
0BA7 4004        27            jc ADC_to_PB_L6
0BA9 756F07      28       mov keyin, #7
0BAC 22          29            ret
0BAD             30   ADC_to_PB_L6:
0BAD             31            ; Check PB5
0BAD C3          32            clr c
0BAE E5C5        33            mov a, AD0DAT0; P1.7
0BB0 9491        34            subb a, #(155-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
0BB2 4004        35            jc ADC_to_PB_L5
0BB4 756F06      36            mov keyin, #6
0BB7 22          37            ret
0BB8             38   ADC_to_PB_L5:
0BB8             39            ; Check PB4
0BB8 C3          40            clr c
0BB9 E5C5        41            mov a, AD0DAT0
0BBB 9478        42            subb a, #(130-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
0BBD 4004        43            jc ADC_to_PB_L4
0BBF 756F05      44            mov keyin, #5
0BC2 22          45            ret
0BC3             46   ADC_to_PB_L4:
0BC3             47            ; Check PB3
0BC3 C3          48            clr c
0BC4 E5C5        49            mov a, AD0DAT0
0BC6 9462        50            subb a, #(108-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
0BC8 4004        51            jc ADC_to_PB_L3
0BCA 756F04      52            mov keyin, #4
0BCD 22          53            ret
0BCE             54   ADC_to_PB_L3:
0BCE             55            ; Check PB2
0BCE C3          56            clr c
0BCF E5C5        57            mov a, AD0DAT0
0BD1 9444        58            subb a, #(78-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
0BD3 4004        59            jc ADC_to_PB_L2
0BD5 756F03      60            mov keyin, #3
0BD8 22          61            ret
0BD9             62   ADC_to_PB_L2:
0BD9             63            ; Check PB1
0BD9 C3          64            clr c
0BDA E5C5        65            mov a, AD0DAT0
0BDC 9433        66            subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
0BDE 4004        67            jc ADC_to_PB_L1
0BE0 756F02      68            mov keyin, #2
0BE3 22          69            ret
0BE4             70   ADC_to_PB_L1:
0BE4             71            ; Check PB1
0BE4 C3          72            clr c
0BE5 E5C5        73            mov a, AD0DAT0
0BE7 9413        74            subb a, #(29-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
0BE9 4004        75            jc ADC_to_PB_L0
0BEB 756F01      76            mov keyin, #1
0BEE 22          77            ret
0BEF             78   ADC_to_PB_L0:
0BEF             79            ; No pusbutton pressed  
0BEF 22          80            ret
0BF0             81   
0BF0             82   ADC_to_PB_1:
0BF0             83            ; Check PB6
0BF0 C3          84            clr c
0BF1 E5C6        85            mov a, AD0DAT1
0BF3 94C4        86            subb a, #(206-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
0BF5 4004        87            jc ADC_to_PB_L6_2
0BF7 756F0E      88            mov keyin, #14
0BFA 22          89            ret
0BFB             90   ADC_to_PB_L6_2:
0BFB             91            ; Check PB5
0BFB C3          92            clr c
0BFC E5C6        93            mov a, AD0DAT1
0BFE 94AF        94            subb a, #(185-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
0C00 4004        95            jc ADC_to_PB_L5_2
0C02 756F0D      96            mov keyin, #13
0C05 22          97            ret
0C06             98   ADC_to_PB_L5_2:
0C06             99            ; Check PB4
0C06 C3         100            clr c
0C07 E5C6       101            mov a, AD0DAT1
0C09 9490       102            subb a, #(154-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
0C0B 4004       103            jc ADC_to_PB_L4_2
0C0D 756F0C     104            mov keyin, #12
0C10 22         105            ret
0C11            106   ADC_to_PB_L4_2:
0C11            107            ; Check PB3
0C11 C3         108            clr c
0C12 E5C6       109            mov a, AD0DAT1
0C14 9471       110            subb a, #(123-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
0C16 4004       111            jc ADC_to_PB_L3_2
0C18 756F0B     112            mov keyin, #11
0C1B 22         113            ret
0C1C            114   ADC_to_PB_L3_2:
0C1C            115            ; Check PB2
0C1C C3         116            clr c
0C1D E5C6       117            mov a, AD0DAT1
0C1F 9452       118            subb a, #(92-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
0C21 4004       119            jc ADC_to_PB_L2_2
0C23 756F0A     120            mov keyin, #10
0C26 22         121            ret
0C27            122   ADC_to_PB_L2_2:
0C27            123            ; Check PB1
0C27 C3         124            clr c
0C28 E5C6       125            mov a, AD0DAT1
0C2A 9433       126            subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
0C2C 4004       127            jc ADC_to_PB_L1_2
0C2E 756F09     128            mov keyin, #9
0C31 22         129            ret
0C32            130   ADC_to_PB_L1_2:
0C32            131            ; Check PB1
0C32 C3         132            clr c
0C33 E5C6       133            mov a, AD0DAT1
0C35 9414       134            subb a, #(30-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
0C37 4004       135            jc ADC_to_PB_L01
0C39 756F08     136            mov keyin, #8
0C3C 22         137            ret
0C3D            138   ADC_to_PB_L01:
0C3D            139            ; No pusbutton pressed  
0C3D 22         140            ret
0C3E            188   ;$LIST
0C3E            189   
0C3E            190   cseg
0C3E            191   
0C3E            192   MainProgram:
0C3E 75817F     193       mov SP, #0x7F
0C41 120534     194       lcall Ports_Init
0C44 12024E     195            lcall LCD_4BIT
0C47            196            ;Serial_Initialize()
0C47 120570     196       lcall _Serial_Initialize
0C4A 12054D     197       lcall InitADC
0C4D C0E0       198            push acc
0C4F 7401       198            mov a, #1
0C51 14         198            dec a
0C52 120290     198            lcall ?Set_Cursor_1 ; Select column and row
0C55 D0E0       198            pop acc
0C57 C083       198            push dph
0C59 C082       198            push dpl
0C5B C0E0       198            push acc
0C5D 90007F     198            mov dptr, #WELCOME1
0C60 120283     198            lcall ?Send_Constant_String
0C63 D0E0       198            pop acc
0C65 D082       198            pop dpl
0C67 D083       198            pop dph
0C69 C0E0       198            push acc
0C6B 7401       198            mov a, #1
0C6D 14         198            dec a
0C6E 12028E     198            lcall ?Set_Cursor_2 ; Select column and row
0C71 D0E0       198            pop acc
0C73 C083       198            push dph
0C75 C082       198            push dpl
0C77 C0E0       198            push acc
0C79 900090     198            mov dptr, #WELCOME2
0C7C 120283     198            lcall ?Send_Constant_String
0C7F D0E0       198            pop acc
0C81 D082       198            pop dpl
0C83 D083       198            pop dph
0C85 120D21     199       lcall Data_Initialization
0C88 120795     200       lcall InitDAC
0C8B 12074D     201       lcall CCU_Init
0C8E 1207A5     202            lcall Init_SPI
0C91 120CC4     203       lcall External_Interrupt0_Init
0C94 120CC7     204       lcall External_Interrupt1_Init
0C97 C2C8       205       clr TMOD20 ; Stop CCU timer
0C99 D2AF       206       setb EA   ; Enable Global interrupts
0C9B C2A7       207       clr OVEN
0C9D            208   
0C9D            209   Main_Loop:
0C9D            210   
0C9D            211   
0C9D 3004FD     212       jnb half_seconds_flag, Main_Loop
0CA0            213   
0CA0            214   loop_b:
0CA0 C204       215       clr half_seconds_flag
0CA2 0567       216       inc Count5s
0CA4 E567       217       mov a, Count5s
0CA6 B40506     218       cjne a, #5, skip3
0CA9 756700     219       mov Count5s, #0
0CAC 1211EF     220       lcall Speak_Process
0CAF            221       skip3:
0CAF            222   
0CAF 80EC       223            sjmp Main_Loop
0CB1            224   
0CB1            225   
0CB1            226   
0CB1            227   
0CB1            228   ;----------------------------;
0CB1            229   ;           Macros           ;
0CB1            230   ;----------------------------; 
                231   Display_3BCD_from_x mac
                232       lcall hex2bcd
                233       ;now the bcd num of time is stored in bcd
                234       LCD_Display_NUM(bcd+1);
                235       LCD_Display_BCD(bcd);
                236   endmac
0CB1            237   
                238   Update_Temp mac
                239       lcall Read_Room_Temp
                240       lcall Read_Oven_Temp
                241       mov32(x, Current_Oven_Temp)
                242       mov32(y, %0)
                243       lcall x_lt_y
                244   endmac
0CB1            246   
0CB1            247   ;----------------------------;
0CB1            248   ;         Functions          ;
0CB1            249   ;----------------------------; 
0CB1            250   
0CB1            251   Timer1_Init:
0CB1 E589       252            mov a, TMOD
0CB3 540F       253            anl a, #0x0f ; Clear the bits for timer 1
0CB5 4410       254            orl a, #0x10 ; Configure timer 1 as 16-timer
0CB7 F589       255            mov TMOD, a
0CB9 758D6F     256            mov TH1, #high(TIMER1_RELOAD)
0CBC 758BFF     257            mov TL1, #low(TIMER1_RELOAD)
0CBF            258            ; Enable the timer and interrupts
0CBF D2AB       259       setb ET1  ; Enable timer 1 interrupt
0CC1 D28E       260       setb TR1  ; Start timer 1
0CC3 22         261            ret
0CC4            262   
0CC4            263   External_Interrupt0_Init:
0CC4            264            ; Enable the external interrupt
0CC4 D2A8       265       setb EX0  ; Enable timer 1 interrupt
0CC6 22         266            ret
0CC7            267   
0CC7            268   External_Interrupt1_Init:
0CC7            269            ; Enable the external interrupt
0CC7 D2AA       270       setb EX1  ; Enable timer 1 interrupt
0CC9 22         271            ret
0CCA            272   
0CCA            273   Display_Working_Status:
0CCA C0E0       274            push acc
0CCC 7406       274            mov a, #6
0CCE 14         274            dec a
0CCF 120290     274            lcall ?Set_Cursor_1 ; Select column and row
0CD2 D0E0       274            pop acc
0CD4            275       ;mov(dst, src)
0CD4 85515D     275            mov x+3, Current_Oven_Temp+3
0CD7 85505C     275       mov x+2, Current_Oven_Temp+2
0CDA 854F5B     275       mov x+1, Current_Oven_Temp+1
0CDD 854E5A     275       mov x,   Current_Oven_Temp
0CE0 1202B8     276       lcall hex2bcd
0CE3            276       ;now the bcd num of time is stored in bcd
0CE3 C000       276            push ar0
0CE5 A863       276            mov r0, bcd+1
0CE7 1202AB     276            lcall ?Display_NUM
0CEA D000       276            pop ar0;
0CEC C000       276            push ar0
0CEE A862       276            mov r0, bcd
0CF0 120295     276            lcall ?Display_BCD
0CF3 D000       276            pop ar0;
0CF5            277   
0CF5 C0E0       278            push acc
0CF7 740E       278            mov a, #14
0CF9 14         278            dec a
0CFA 120290     278            lcall ?Set_Cursor_1 ; Select column and row
0CFD D0E0       278            pop acc
0CFF 755D00     279       mov x+3, #0
0D02 755C00     280       mov x+2, #0
0D05 755B00     281       mov x+1, #0
0D08 85315A     282       mov x, Time_Global
0D0B 1202B8     283       lcall hex2bcd
0D0E            283       ;now the bcd num of time is stored in bcd
0D0E C000       283            push ar0
0D10 A863       283            mov r0, bcd+1
0D12 1202AB     283            lcall ?Display_NUM
0D15 D000       283            pop ar0;
0D17 C000       283            push ar0
0D19 A862       283            mov r0, bcd
0D1B 120295     283            lcall ?Display_BCD
0D1E D000       283            pop ar0;
0D20 22         284       ret
0D21            285   
0D21            286   Data_Initialization:
0D21 753100     287       mov Time_Global, #0x00
0D24 753900     288       mov TEMP_SOAK+3, #0x00
0D27 753800     289       mov TEMP_SOAK+2, #0x00
0D2A 753700     290       mov TEMP_SOAK+1, #0x00
0D2D 753696     291       mov TEMP_SOAK, #150
0D30 754100     292       mov TEMP_RFLW+3, #0
0D33 754000     293       mov TEMP_RFLW+2, #0
0D36 753F00     294       mov TEMP_RFLW+1, #0
0D39 753ED9     295       mov TEMP_RFLW, #217
0D3C 753D00     296       mov TIME_SOAK+3, #0
0D3F 753C00     297       mov TIME_SOAK+2, #0
0D42 753B00     298       mov TIME_SOAK+1, #0
0D45 753A3C     299       mov TIME_SOAK, #60
0D48 754500     300       mov TIME_RFLW+3, #0
0D4B 754400     301       mov TIME_RFLW+2, #0
0D4E 754300     302       mov TIME_RFLW+1, #0
0D51 75424B     303       mov TIME_RFLW, #75
0D54 754900     304       mov TEMP_SAFE+3, #0
0D57 754800     305       mov TEMP_SAFE+2, #0
0D5A 754700     306       mov TEMP_SAFE+1, #0
0D5D 75463C     307       mov TEMP_SAFE, #60
0D60 753300     308       mov FSM0_State, #0
0D63 753400     309       mov FSM1_State, #0
0D66 756B00     310       mov number, #0x0 ;;not needed
0D69 756E00     311       mov individual_offest, #0x0
0D6C 756700     312       mov Count5s, #0x00
0D6F            313       
0D6F C296       314       clr LED
0D71 C203       315       clr enable_time_global
0D73 C205       316       clr nodigit
0D75 C206       317            clr skiphundred
0D77 C207       318            clr skiptenth
0D79 C201       319       clr Main_State
0D7B            320   
0D7B C0E0       321            push acc
0D7D 7401       321            mov a, #1
0D7F 14         321            dec a
0D80 120290     321            lcall ?Set_Cursor_1 ; Select column and row
0D83 D0E0       321            pop acc
0D85 C083       321            push dph
0D87 C082       321            push dpl
0D89 C0E0       321            push acc
0D8B 90007F     321            mov dptr, #WELCOME1
0D8E 120283     321            lcall ?Send_Constant_String
0D91 D0E0       321            pop acc
0D93 D082       321            pop dpl
0D95 D083       321            pop dph
0D97 C0E0       321            push acc
0D99 7401       321            mov a, #1
0D9B 14         321            dec a
0D9C 12028E     321            lcall ?Set_Cursor_2 ; Select column and row
0D9F D0E0       321            pop acc
0DA1 C083       321            push dph
0DA3 C082       321            push dpl
0DA5 C0E0       321            push acc
0DA7 900090     321            mov dptr, #WELCOME2
0DAA 120283     321            lcall ?Send_Constant_String
0DAD D0E0       321            pop acc
0DAF D082       321            pop dpl
0DB1 D083       321            pop dph
0DB3 22         322       ret
0DB4            323   
0DB4            324   ;----------------------------;
0DB4            325   ;     Interrupt Services     ;
0DB4            326   ;----------------------------; 
0DB4            327   Timer1_ISR:
0DB4 758D6F     328            mov TH1, #high(TIMER1_RELOAD)
0DB7 758BFF     329            mov TL1, #low(TIMER1_RELOAD)
0DBA B2A6       330            cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0DBC            331            
0DBC            332            ; The two registers used in the ISR must be saved in the stack
0DBC C0E0       333            push acc
0DBE C0D0       334            push psw
0DC0            335            
0DC0            336            ; Increment the 8-bit 10-mili-second counter
0DC0 0530       337            inc Count10ms
0DC2            338   
0DC2            339   Inc_Done:
0DC2            340            ; Check if half second has passed
0DC2 E530       341            mov a, Count10ms
0DC4 B4640F     342            cjne a, #100, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
0DC7            343            
0DC7            344            ; 500 milliseconds have passed.  Set a flag so the main program knows
0DC7 D204       345            setb half_seconds_flag ; Let the main program know half second had passed
0DC9            346       
0DC9 300302     347       jnb enable_time_global, skip1
0DCC 0531       348       inc Time_Global
0DCE            349            skip1:
0DCE 753000     350       mov Count10ms, #0
0DD1            351   
0DD1 B296       352       cpl LED
0DD3 120E18     353       lcall FSM1;call FSM1 here
0DD6            354   
0DD6            355   Timer1_ISR_done:
0DD6 D0D0       356            pop psw
0DD8 D0E0       357            pop acc
0DDA 32         358            reti
0DDB            359   
0DDB            360   EI0_ISR:
0DDB C288       361       clr IT0
0DDD 120CB1     362       lcall Timer1_Init
0DE0 32         363       reti
0DE1            364   
0DE1            365   EI1_ISR:
0DE1 C28A       366       clr IT1
0DE3 C28E       367       clr TR1; disable  timer 1
0DE5 120D21     368       lcall Data_Initialization
0DE8 32         369       reti
0DE9            370   
0DE9            371   ;---------------------------------;
0DE9            372   ;      Finite State Machines      ;
0DE9            373   ;---------------------------------;
0DE9            374   FSM0:
0DE9 C0E0       375       push acc
0DEB 120B8E     376       lcall Key_Read
0DEE E533       377       mov a, FSM0_State
0DF0 755A00     378            mov x+0, #low (0 % 0x10000) 
0DF3 755B00     378            mov x+1, #high(0 % 0x10000) 
0DF6 755C00     378            mov x+2, #low (0 / 0x10000) 
0DF9 755D00     378            mov x+3, #high(0 / 0x10000) 
0DFC 856F5A     379       mov x, keyin
0DFF 1202B8     380       lcall hex2bcd
0E02 C0E0       381            push acc
0E04 740A       381            mov a, #10
0E06 14         381            dec a
0E07 120290     381            lcall ?Set_Cursor_1 ; Select column and row
0E0A D0E0       381            pop acc
0E0C C000       382            push ar0
0E0E A862       382            mov r0, bcd
0E10 120295     382            lcall ?Display_BCD
0E13 D000       382            pop ar0
0E15 D0E0       383       pop acc
0E17 22         384   ret
0E18            385   
0E18            386   
0E18            387       ;---------------------------------;
0E18            388       ; FSM1 using Timer Interrupt      ;
0E18            389       ;---------------------------------;
0E18            390       ;update status and send data to LCD and PC every one/half seconds
0E18            391   FSM1:
0E18            392   
0E18            393   
0E18 E534       394       mov a, FSM1_State
0E1A            395       FSM1_State0:
0E1A B40002     396           cjne a, #0, JUMP_FSM1_State1
0E1D 8003       397           sjmp Start_FSM1_State0
0E1F            398           JUMP_FSM1_State1:
0E1F 020EE0     399           ljmp FSM1_State1
0E22            400           
0E22            401           Start_FSM1_State0:
0E22 D203       402           setb enable_time_global
0E24 D2A7       403           setb OVEN; turn oven on
0E26 1206CD     404       lcall Read_Room_Temp
0E29 120602     404       lcall Read_Oven_Temp
0E2C            404   
0E2C            404       ;mov(dst, src)
0E2C 85515D     404            mov x+3, Current_Oven_Temp+3
0E2F 85505C     404       mov x+2, Current_Oven_Temp+2
0E32 854F5B     404       mov x+1, Current_Oven_Temp+1
0E35 854E5A     404       mov x,   Current_Oven_Temp
0E38            404       ;mov(dst, src)
0E38 853961     404            mov y+3, TEMP_SOAK+3
0E3B 853860     404       mov y+2, TEMP_SOAK+2
0E3E 85375F     404       mov y+1, TEMP_SOAK+1
0E41 85365E     404       mov y,   TEMP_SOAK
0E44            404   
0E44 1203C0     404       lcall x_lt_y    ;Read Temperatures
0E47 C0E0       405            push acc
0E49 7401       405            mov a, #1
0E4B 14         405            dec a
0E4C 120290     405            lcall ?Set_Cursor_1 ; Select column and row
0E4F D0E0       405            pop acc
0E51 C083       405            push dph
0E53 C082       405            push dpl
0E55 C0E0       405            push acc
0E57 90014B     405            mov dptr, #WORKING
0E5A 120283     405            lcall ?Send_Constant_String
0E5D D0E0       405            pop acc
0E5F D082       405            pop dpl
0E61 D083       405            pop dph
0E63 C0E0       405            push acc
0E65 7401       405            mov a, #1
0E67 14         405            dec a
0E68 12028E     405            lcall ?Set_Cursor_2 ; Select column and row
0E6B D0E0       405            pop acc
0E6D C083       405            push dph
0E6F C082       405            push dpl
0E71 C0E0       405            push acc
0E73 90015C     405            mov dptr, #STEP1
0E76 120283     405            lcall ?Send_Constant_String
0E79 D0E0       405            pop acc
0E7B D082       405            pop dpl
0E7D D083       405            pop dph;display interface
0E7F 120CCA     406           lcall Display_Working_Status
0E82 C0E0       407            push acc
0E84 7406       407            mov a, #6
0E86 14         407            dec a
0E87 12028E     407            lcall ?Set_Cursor_2 ; Select column and row
0E8A D0E0       407            pop acc
0E8C            408       ;mov(dst, src)
0E8C 85395D     408            mov x+3, TEMP_SOAK+3
0E8F 85385C     408       mov x+2, TEMP_SOAK+2
0E92 85375B     408       mov x+1, TEMP_SOAK+1
0E95 85365A     408       mov x,   TEMP_SOAK
0E98 1202B8     409       lcall hex2bcd
0E9B            409       ;now the bcd num of time is stored in bcd
0E9B C000       409            push ar0
0E9D A863       409            mov r0, bcd+1
0E9F 1202AB     409            lcall ?Display_NUM
0EA2 D000       409            pop ar0;
0EA4 C000       409            push ar0
0EA6 A862       409            mov r0, bcd
0EA8 120295     409            lcall ?Display_BCD
0EAB D000       409            pop ar0;
0EAD            410   
0EAD 200207     411           jb mf, FSM1_State0_Error_Check;check Error and continue if smaller than set time
0EB0            412           ;if temp greater
0EB0 0534       413           inc FSM1_State; go to next state            
0EB2 853A32     414           mov Time_Counter, TIME_SOAK; move the TIME_SOAK in counter and count down
0EB5 8026       415           sjmp FSM1_State0_Done
0EB7            416   
0EB7            417           FSM1_State0_Error_Check:
0EB7 E531       418           mov a, Time_Global
0EB9 B43C21     419           cjne a, #QUITTIME, FSM1_State0_Done; not time, done
0EBC            420           ;if time reached, check temp
0EBC            421       ;mov(dst, src)
0EBC 85515D     421            mov x+3, Current_Oven_Temp+3
0EBF 85505C     421       mov x+2, Current_Oven_Temp+2
0EC2 854F5B     421       mov x+1, Current_Oven_Temp+1
0EC5 854E5A     421       mov x,   Current_Oven_Temp;move current oven temp in x
0EC8 756100     422           mov y+3, #0
0ECB 756000     423           mov y+2, #0
0ECE 755F00     424           mov y+1, #0
0ED1 755E32     425           mov y, #QUITTEMP
0ED4 1203C0     426           lcall x_lt_y; check if current oven temp is smaller than quittemp
0ED7            427   
0ED7 300203     428           jnb mf, FSM1_State0_Done; the oven is working properly
0EDA            429           ;if not working right
0EDA 0211B1     430           ljmp FSM1_WARNING
0EDD            431   
0EDD            432   
0EDD            433   
0EDD            434           FSM1_State0_Done:
0EDD 0211EE     435               ljmp FSM1_DONE
0EE0            436   
0EE0            437   
0EE0            438       FSM1_State1:
0EE0 B40102     439           cjne a, #1, JUMP_FSM1_State2
0EE3 8003       440               sjmp Start_FSM1_State1
0EE5            441           JUMP_FSM1_State2:
0EE5 020F86     442               ljmp FSM1_State2
0EE8            443           
0EE8            444           Start_FSM1_State1:
0EE8 D53205     445           djnz Time_Counter, FSM1_State1_Continue; decrement every 1 second
0EEB            446           ;time over, change state
0EEB 0534       447           inc FSM1_State; increment states
0EED 020F83     448           ljmp FSM1_State1_Done
0EF0            449   
0EF0            450           FSM1_State1_Continue:
0EF0            451           ;next: check temp
0EF0            452           ;read temp and compare
0EF0 1206CD     453       lcall Read_Room_Temp
0EF3 120602     453       lcall Read_Oven_Temp
0EF6            453   
0EF6            453       ;mov(dst, src)
0EF6 85515D     453            mov x+3, Current_Oven_Temp+3
0EF9 85505C     453       mov x+2, Current_Oven_Temp+2
0EFC 854F5B     453       mov x+1, Current_Oven_Temp+1
0EFF 854E5A     453       mov x,   Current_Oven_Temp
0F02            453       ;mov(dst, src)
0F02 853961     453            mov y+3, TEMP_SOAK+3
0F05 853860     453       mov y+2, TEMP_SOAK+2
0F08 85375F     453       mov y+1, TEMP_SOAK+1
0F0B 85365E     453       mov y,   TEMP_SOAK
0F0E            453   
0F0E 1203C0     453       lcall x_lt_y   ;Update current temp info
0F11 C0E0       454            push acc
0F13 7401       454            mov a, #1
0F15 14         454            dec a
0F16 120290     454            lcall ?Set_Cursor_1 ; Select column and row
0F19 D0E0       454            pop acc
0F1B C083       454            push dph
0F1D C082       454            push dpl
0F1F C0E0       454            push acc
0F21 90014B     454            mov dptr, #WORKING
0F24 120283     454            lcall ?Send_Constant_String
0F27 D0E0       454            pop acc
0F29 D082       454            pop dpl
0F2B D083       454            pop dph
0F2D C0E0       454            push acc
0F2F 7401       454            mov a, #1
0F31 14         454            dec a
0F32 12028E     454            lcall ?Set_Cursor_2 ; Select column and row
0F35 D0E0       454            pop acc
0F37 C083       454            push dph
0F39 C082       454            push dpl
0F3B C0E0       454            push acc
0F3D 90016D     454            mov dptr, #STEP2
0F40 120283     454            lcall ?Send_Constant_String
0F43 D0E0       454            pop acc
0F45 D082       454            pop dpl
0F47 D083       454            pop dph
0F49 120CCA     455           lcall Display_Working_Status; update time and temp on lcd
0F4C            456           ;if temp is lower than expected, jump to ON
0F4C C0E0       457            push acc
0F4E 7405       457            mov a, #5
0F50 14         457            dec a
0F51 12028E     457            lcall ?Set_Cursor_2 ; Select column and row
0F54 D0E0       457            pop acc
0F56 755A00     458            mov x+0, #low (0 % 0x10000) 
0F59 755B00     458            mov x+1, #high(0 % 0x10000) 
0F5C 755C00     458            mov x+2, #low (0 / 0x10000) 
0F5F 755D00     458            mov x+3, #high(0 / 0x10000) 
0F62 85325A     459           mov x, Time_Counter
0F65 1202B8     460       lcall hex2bcd
0F68            460       ;now the bcd num of time is stored in bcd
0F68 C000       460            push ar0
0F6A A863       460            mov r0, bcd+1
0F6C 1202AB     460            lcall ?Display_NUM
0F6F D000       460            pop ar0;
0F71 C000       460            push ar0
0F73 A862       460            mov r0, bcd
0F75 120295     460            lcall ?Display_BCD
0F78 D000       460            pop ar0;
0F7A            461   
0F7A 200204     462           jb mf, FSM1_State1_ON
0F7D            463           ;if temp is higher, close oven
0F7D C2A7       464           clr OVEN 
0F7F 8002       465           sjmp FSM1_State1_Done
0F81            466   
0F81            467           FSM1_State1_ON:
0F81 D2A7       468           setb OVEN   ;if temp is lower, turn on oven
0F83            469           FSM1_State1_Done:
0F83 0211EE     470               ljmp FSM1_DONE
0F86            471   
0F86            472       FSM1_State2: ;temp ramp up until TEMP_RFLW
0F86 B40202     473           cjne a, #2, JUMP_FSM1_State3
0F89 8003       474               sjmp Start_FSM1_State2
0F8B            475           JUMP_FSM1_State3:
0F8B 021025     476               ljmp FSM1_State3
0F8E            477   
0F8E            478           Start_FSM1_State2:
0F8E D2A7       479           setb OVEN; turn on oven
0F90            480   
0F90            481           ;read temperature
0F90 1206CD     482       lcall Read_Room_Temp
0F93 120602     482       lcall Read_Oven_Temp
0F96            482   
0F96            482       ;mov(dst, src)
0F96 85515D     482            mov x+3, Current_Oven_Temp+3
0F99 85505C     482       mov x+2, Current_Oven_Temp+2
0F9C 854F5B     482       mov x+1, Current_Oven_Temp+1
0F9F 854E5A     482       mov x,   Current_Oven_Temp
0FA2            482       ;mov(dst, src)
0FA2 854161     482            mov y+3, TEMP_RFLW+3
0FA5 854060     482       mov y+2, TEMP_RFLW+2
0FA8 853F5F     482       mov y+1, TEMP_RFLW+1
0FAB 853E5E     482       mov y,   TEMP_RFLW
0FAE            482   
0FAE 1203C0     482       lcall x_lt_y
0FB1 200208     483           jb mf, FSM1_State2_Continue
0FB4            484           ;if temp reached
0FB4 0534       485           inc FSM1_State
0FB6 854232     486           mov Time_Counter, TIME_RFLW
0FB9 0211EE     487           ljmp FSM1_DONE
0FBC            488   
0FBC            489           FSM1_State2_Continue:
0FBC C0E0       490            push acc
0FBE 7401       490            mov a, #1
0FC0 14         490            dec a
0FC1 120290     490            lcall ?Set_Cursor_1 ; Select column and row
0FC4 D0E0       490            pop acc
0FC6 C083       490            push dph
0FC8 C082       490            push dpl
0FCA C0E0       490            push acc
0FCC 90014B     490            mov dptr, #WORKING
0FCF 120283     490            lcall ?Send_Constant_String
0FD2 D0E0       490            pop acc
0FD4 D082       490            pop dpl
0FD6 D083       490            pop dph
0FD8 C0E0       490            push acc
0FDA 7401       490            mov a, #1
0FDC 14         490            dec a
0FDD 12028E     490            lcall ?Set_Cursor_2 ; Select column and row
0FE0 D0E0       490            pop acc
0FE2 C083       490            push dph
0FE4 C082       490            push dpl
0FE6 C0E0       490            push acc
0FE8 90017E     490            mov dptr, #STEP3
0FEB 120283     490            lcall ?Send_Constant_String
0FEE D0E0       490            pop acc
0FF0 D082       490            pop dpl
0FF2 D083       490            pop dph
0FF4 120CCA     491           lcall Display_Working_Status
0FF7 C0E0       492            push acc
0FF9 7406       492            mov a, #6
0FFB 14         492            dec a
0FFC 12028E     492            lcall ?Set_Cursor_2 ; Select column and row
0FFF D0E0       492            pop acc
1001            493       ;mov(dst, src)
1001 85415D     493            mov x+3, TEMP_RFLW+3
1004 85405C     493       mov x+2, TEMP_RFLW+2
1007 853F5B     493       mov x+1, TEMP_RFLW+1
100A 853E5A     493       mov x,   TEMP_RFLW
100D 1202B8     494       lcall hex2bcd
1010            494       ;now the bcd num of time is stored in bcd
1010 C000       494            push ar0
1012 A863       494            mov r0, bcd+1
1014 1202AB     494            lcall ?Display_NUM
1017 D000       494            pop ar0;
1019 C000       494            push ar0
101B A862       494            mov r0, bcd
101D 120295     494            lcall ?Display_BCD
1020 D000       494            pop ar0;
1022            495   
1022            496           FSM1_State2_Done:
1022 0211EE     497               ljmp FSM1_DONE
1025            498           
1025            499            FSM1_State3: ; keep temp at TEMP_RFLW for a few time
1025 B40302     500           cjne a, #3, JUMP_FSM1_State4
1028 8003       501               sjmp Start_FSM1_State3
102A            502           JUMP_FSM1_State4:
102A 0210CB     503               ljmp FSM1_State4
102D            504           
102D            505           Start_FSM1_State3:
102D D53205     506           djnz Time_Counter, FSM1_State3_Continue
1030            507           ;if time's up
1030 0534       508           inc FSM1_State
1032 0210C8     509           ljmp FSM1_State3_Done
1035            510   
1035            511           FSM1_State3_Continue:
1035 C0E0       512            push acc
1037 7401       512            mov a, #1
1039 14         512            dec a
103A 120290     512            lcall ?Set_Cursor_1 ; Select column and row
103D D0E0       512            pop acc
103F C083       512            push dph
1041 C082       512            push dpl
1043 C0E0       512            push acc
1045 90014B     512            mov dptr, #WORKING
1048 120283     512            lcall ?Send_Constant_String
104B D0E0       512            pop acc
104D D082       512            pop dpl
104F D083       512            pop dph
1051 C0E0       512            push acc
1053 7401       512            mov a, #1
1055 14         512            dec a
1056 12028E     512            lcall ?Set_Cursor_2 ; Select column and row
1059 D0E0       512            pop acc
105B C083       512            push dph
105D C082       512            push dpl
105F C0E0       512            push acc
1061 90018F     512            mov dptr, #STEP4
1064 120283     512            lcall ?Send_Constant_String
1067 D0E0       512            pop acc
1069 D082       512            pop dpl
106B D083       512            pop dph
106D 120CCA     513           lcall Display_Working_Status
1070 1206CD     514       lcall Read_Room_Temp
1073 120602     514       lcall Read_Oven_Temp
1076            514   
1076            514       ;mov(dst, src)
1076 85515D     514            mov x+3, Current_Oven_Temp+3
1079 85505C     514       mov x+2, Current_Oven_Temp+2
107C 854F5B     514       mov x+1, Current_Oven_Temp+1
107F 854E5A     514       mov x,   Current_Oven_Temp
1082            514       ;mov(dst, src)
1082 854161     514            mov y+3, TEMP_RFLW+3
1085 854060     514       mov y+2, TEMP_RFLW+2
1088 853F5F     514       mov y+1, TEMP_RFLW+1
108B 853E5E     514       mov y,   TEMP_RFLW
108E            514   
108E 1203C0     514       lcall x_lt_y; update temp info, set or clr mf flag
1091 C0E0       515            push acc
1093 7405       515            mov a, #5
1095 14         515            dec a
1096 12028E     515            lcall ?Set_Cursor_2 ; Select column and row
1099 D0E0       515            pop acc
109B 755A00     516            mov x+0, #low (0 % 0x10000) 
109E 755B00     516            mov x+1, #high(0 % 0x10000) 
10A1 755C00     516            mov x+2, #low (0 / 0x10000) 
10A4 755D00     516            mov x+3, #high(0 / 0x10000) 
10A7 85325A     517           mov x, Time_Counter
10AA 1202B8     518       lcall hex2bcd
10AD            518       ;now the bcd num of time is stored in bcd
10AD C000       518            push ar0
10AF A863       518            mov r0, bcd+1
10B1 1202AB     518            lcall ?Display_NUM
10B4 D000       518            pop ar0;
10B6 C000       518            push ar0
10B8 A862       518            mov r0, bcd
10BA 120295     518            lcall ?Display_BCD
10BD D000       518            pop ar0;
10BF            519   
10BF            520           ;if temp is lower than expected, jump to ON
10BF 200204     521           jb mf, FSM1_State3_ON
10C2            522           ;if temp is higher, close oven
10C2 C2A7       523           clr OVEN 
10C4 8002       524           sjmp FSM1_State3_Done
10C6            525   
10C6            526           FSM1_State3_ON:
10C6 D2A7       527           setb OVEN   ;if temp is lower, turn on oven
10C8            528           FSM1_State3_Done:
10C8 0211EE     529               ljmp FSM1_DONE
10CB            530           
10CB            531   
10CB            532       
10CB            533       FSM1_State4:; cool down until safe temp
10CB B40402     534           cjne a, #4, JUMP_FSM1_State5
10CE 8003       535               sjmp Start_FSM1_State4
10D0            536           JUMP_FSM1_State5:
10D0 02116D     537               ljmp FSM1_State5
10D3            538           
10D3            539           Start_FSM1_State4:
10D3 C2A7       540           clr OVEN
10D5            541           ;read temperature
10D5 1206CD     542       lcall Read_Room_Temp
10D8 120602     542       lcall Read_Oven_Temp
10DB            542   
10DB            542       ;mov(dst, src)
10DB 85515D     542            mov x+3, Current_Oven_Temp+3
10DE 85505C     542       mov x+2, Current_Oven_Temp+2
10E1 854F5B     542       mov x+1, Current_Oven_Temp+1
10E4 854E5A     542       mov x,   Current_Oven_Temp
10E7            542       ;mov(dst, src)
10E7 854961     542            mov y+3, TEMP_SAFE+3
10EA 854860     542       mov y+2, TEMP_SAFE+2
10ED 85475F     542       mov y+1, TEMP_SAFE+1
10F0 85465E     542       mov y,   TEMP_SAFE
10F3            542   
10F3 1203C0     542       lcall x_lt_y
10F6            543           ;if temp is smaller than TEMP_SAFE, go state 5
10F6 300205     544           jnb mf, FSM1_State4_Continue
10F9            545           ;if temp is smaller than expected
10F9 0534       546           inc FSM1_State
10FB 753200     547           mov Time_Counter, #0
10FE            548   
10FE            549           FSM1_State4_Continue:
10FE C0E0       550            push acc
1100 7401       550            mov a, #1
1102 14         550            dec a
1103 120290     550            lcall ?Set_Cursor_1 ; Select column and row
1106 D0E0       550            pop acc
1108 C083       550            push dph
110A C082       550            push dpl
110C C0E0       550            push acc
110E 90014B     550            mov dptr, #WORKING
1111 120283     550            lcall ?Send_Constant_String
1114 D0E0       550            pop acc
1116 D082       550            pop dpl
1118 D083       550            pop dph
111A C0E0       550            push acc
111C 7401       550            mov a, #1
111E 14         550            dec a
111F 12028E     550            lcall ?Set_Cursor_2 ; Select column and row
1122 D0E0       550            pop acc
1124 C083       550            push dph
1126 C082       550            push dpl
1128 C0E0       550            push acc
112A 9001A0     550            mov dptr, #STEP5
112D 120283     550            lcall ?Send_Constant_String
1130 D0E0       550            pop acc
1132 D082       550            pop dpl
1134 D083       550            pop dph
1136 120CCA     551           lcall Display_Working_Status
1139 C0E0       552            push acc
113B 7405       552            mov a, #5
113D 14         552            dec a
113E 12028E     552            lcall ?Set_Cursor_2 ; Select column and row
1141 D0E0       552            pop acc
1143 755A00     553            mov x+0, #low (0 % 0x10000) 
1146 755B00     553            mov x+1, #high(0 % 0x10000) 
1149 755C00     553            mov x+2, #low (0 / 0x10000) 
114C 755D00     553            mov x+3, #high(0 / 0x10000) 
114F 85465A     554           mov x, TEMP_SAFE
1152 1202B8     555           lcall hex2bcd
1155 1202B8     556       lcall hex2bcd
1158            556       ;now the bcd num of time is stored in bcd
1158 C000       556            push ar0
115A A863       556            mov r0, bcd+1
115C 1202AB     556            lcall ?Display_NUM
115F D000       556            pop ar0;
1161 C000       556            push ar0
1163 A862       556            mov r0, bcd
1165 120295     556            lcall ?Display_BCD
1168 D000       556            pop ar0;
116A            557   
116A            558           FSM1_State4_Done:
116A 0211EE     559               ljmp FSM1_DONE
116D            560   
116D            561       FSM1_State5: ; already cool done, display something, play some music
116D B4057E     562           cjne a, #5, FSM1_DONE
1170 C2A7       563           clr OVEN; double check oven is not on
1172 C203       564           clr enable_time_global; stop counting
1174 C0E0       565            push acc
1176 7401       565            mov a, #1
1178 14         565            dec a
1179 120290     565            lcall ?Set_Cursor_1 ; Select column and row
117C D0E0       565            pop acc
117E C083       565            push dph
1180 C082       565            push dpl
1182 C0E0       565            push acc
1184 90014B     565            mov dptr, #WORKING
1187 120283     565            lcall ?Send_Constant_String
118A D0E0       565            pop acc
118C D082       565            pop dpl
118E D083       565            pop dph
1190 C0E0       565            push acc
1192 7401       565            mov a, #1
1194 14         565            dec a
1195 12028E     565            lcall ?Set_Cursor_2 ; Select column and row
1198 D0E0       565            pop acc
119A C083       565            push dph
119C C082       565            push dpl
119E C0E0       565            push acc
11A0 9001B1     565            mov dptr, #STEP6
11A3 120283     565            lcall ?Send_Constant_String
11A6 D0E0       565            pop acc
11A8 D082       565            pop dpl
11AA D083       565            pop dph
11AC 120CCA     566           lcall Display_Working_Status
11AF 803D       567           sjmp FSM1_Done
11B1            568   
11B1            569   
11B1            570       FSM1_WARNING:
11B1 C2A7       571           clr OVEN
11B3 C0E0       572            push acc
11B5 7401       572            mov a, #1
11B7 14         572            dec a
11B8 120290     572            lcall ?Set_Cursor_1 ; Select column and row
11BB D0E0       572            pop acc
11BD C083       572            push dph
11BF C082       572            push dpl
11C1 C0E0       572            push acc
11C3 9001C2     572            mov dptr, #WARNING1
11C6 120283     572            lcall ?Send_Constant_String
11C9 D0E0       572            pop acc
11CB D082       572            pop dpl
11CD D083       572            pop dph
11CF C0E0       572            push acc
11D1 7401       572            mov a, #1
11D3 14         572            dec a
11D4 12028E     572            lcall ?Set_Cursor_2 ; Select column and row
11D7 D0E0       572            pop acc
11D9 C083       572            push dph
11DB C082       572            push dpl
11DD C0E0       572            push acc
11DF 9001D3     572            mov dptr, #WARNING2
11E2 120283     572            lcall ?Send_Constant_String
11E5 D0E0       572            pop acc
11E7 D082       572            pop dpl
11E9 D083       572            pop dph
11EB 753406     573           mov FSM1_State, #6
11EE            574   
11EE            575       FSM1_DONE:
11EE 22         576       ret
11EF            577   
11EF            578   Speak_Process:
11EF 120A4C     579       lcall current_temp_is
11F2 854E6B     580       mov number, Current_Oven_Temp+0
11F5 120A2F     581       lcall playnumbers
11F8 120A6B     582       lcall degree
11FB 120A8A     583       lcall celsius
11FE 22         584       ret
11FF            585   
11FF            586   EN
