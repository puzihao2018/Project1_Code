                  2   $LIST
0000              4   
0000              5   ;-------------------;
0000              6   ;    Const Define   ;
0000              7   ;-------------------; 
0000              8   XTAL EQU 7373000
0000              9   BAUD EQU 115200
0000             10   BRVAL EQU ((XTAL/BAUD)-16)
0000             11   
0000             12   CCU_RATE      EQU 22050
0000             13   CCU_RELOAD    EQU ((65536-((XTAL/(2*CCU_RATE)))))
0000             14   
0000             15   ;TIMER0_RATE   EQU 4096    ; 4096Hz
0000             16   ;TIMER0_RELOAD EQU ((65536-(XTAL/(2*TIMER0_RATE))))
0000             17   TIMER1_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             18   TIMER1_RELOAD EQU ((65536-(XTAL/(2*TIMER1_RATE))))
0000             19   QUITTIME      EQU 60
0000             20   QUITTEMP      EQU 50
0000             21   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             22   
0000             23   number_off_set EQU 17200 ;the distance between each number
0000             24   ;number start at ff
0000             25   
0000             26   ;starting addressed of different sound tracks
0000             27   decimal_start  EQU 360000
0000             28   decimal_off_set EQU 24100
0000             29   decimal_playtime EQU 50000
0000             30   
0000             31   special_dec_start EQU 174000 ;numbers from 10 to 19
0000             32   special_off_set EQU 21500
0000             33   special_playtime EQU 21500;19000
0000             34   
0000             35   hundreds_start EQU 563000
0000             36   hundreds_off_set EQU 36000
0000             37   
0000             38   current_temp_is_start EQU 674000
0000             39   current_temp_playtime EQU 35000
0000             40   
0000             41   degree_start EQU 710000
0000             42   degree_playtime EQU 11018
0000             43   
0000             44   celsius_start EQU 732236
0000             45   celsius_playtime EQU 17000
0000             46   
0000             47   current_process_is_start EQU 757000
0000             48   current_process_is_playtime EQU 27000
0000             49            
0000             50   ramp_to_soak_start EQU 790000
0000             51   ramp_to_soak_playtime EQU 25000
0000             52   
0000             53   preheat_and_soak_start EQU 822000
0000             54   preheat_and_soak_playtime EQU 27000
0000             55   
0000             56   ramp_to_peak_start EQU 857000
0000             57   ramp_to_peak_playtime EQU 19000
0000             58   
0000             59   reflow_start EQU 885000
0000             60   reflow_playtime EQU 15000
0000             61   
0000             62   cooling_start EQU 906000
0000             63   cooling_playtime EQU 14000
0000             64   ;-------------------;
0000             65   ;    Ports Define   ;
0000             66   ;-------------------; 
0000             67   ;ADC01 equ P0.0; Read Room Temperature
0000             68   LCD_RS equ P0.1
0000             69   LCD_RW equ P0.2
0000             70   LCD_E  equ P0.3
0000             71   ;Soundout  P0.4
0000             72   LCD_D4 equ P0.5
0000             73   LCD_D5 equ P0.6
0000             74   LCD_D6 equ P0.7
0000             75   LCD_D7 equ P3.0
0000             76   ;          P3.1
0000             77   ;          P1.2
0000             78   Start  equ P1.3
0000             79   Stop   equ P1.4
0000             80   LED    equ P1.6
0000             81   ;ADC00 equ P1.7; Read Oven Temperature
0000             82   ;ADC03 equ P2.0; Read Keyboard1
0000             83   ;ADC02 equ P2.1; Read Keyboard0
0000             84   ;MOSI  equ P2.2
0000             85   ;MISO  equ P2.3
0000             86   FLASH_CE EQU P2.4
0000             87   ;SPICK equ P2.5
0000             88   ;WAVEOUT   P2.6
0000             89   OVEN   equ P2.7
0000             90   
0000             91   ;------------------------;
0000             92   ;    Interrupt Vectors   ;
0000             93   ;------------------------; 
0000             94   ; Reset vector
0000             95   org 0x0000
0000 020C5F      96       ljmp MainProgram
0003             97   
0003             98   ; External interrupt 0 vector, start
0003             99   org 0x0003
0003 020DFC     100            ljmp EI0_ISR
0006            101   
0006            102   ; Timer/Counter 0 overflow interrupt vector
000B            103   org 0x000B
000B 32         104            reti
000C            105   
000C            106   ; External interrupt 1 vector, stop
0013            107   org 0x0013
0013 020E02     108            ljmp EI1_ISR
0016            109   
0016            110   ; Timer/Counter 1 overflow interrupt vector
001B            111   org 0x001B
001B 020DD5     112            ljmp Timer1_ISR
001E            113   
001E            114   ; Serial port receive/transmit interrupt vector
0023            115   org 0x0023 
0023 32         116            reti
0024            117   
0024            118   ; CCU interrupt vector
005B            119   org 0x005b 
005B 020782     120            ljmp CCU_ISR
005E            121   
005E            122   ;-----------------------;
005E            123   ;    Variables Define   ;
005E            124   ;-----------------------; 
005E            125   ;Variable_name: ds n
0030            126   dseg at 0x30
0030            127       Count10ms:    ds 1 ; Used to determine when half second has passed
0031            128       Time_Global:  ds 1 ; to store the time of whole process
0032            129       Time_Counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            130   
0033            131       FSM0_State: ds 1
0034            132       FSM1_State: ds 1
0035            133   
0035            134       Profile_Num: ds 1
0036            135   
0036            136       TEMP_SOAK:  ds 4
003A            137       TIME_SOAK:  ds 4
003E            138       TEMP_RFLW:  ds 4
0042            139       TIME_RFLW:  ds 4
0046            140       TEMP_SAFE:  ds 4
004A            141       Current_Room_Temp: ds 4
004E            142            Current_Oven_Temp: ds 4
0052            143   
0052            144       Cursor:     ds 1
0053            145       NEW_BCD:    ds 3    ; 3 digit BCD used to store current entered number
0056            146       NEW_HEX:    ds 4    ; 32 bit number of new entered number
005A            147       ;for math32.inc
005A            148       x: ds 4
005E            149       y: ds 4
0062            150       bcd: ds 5
0067            151       Count5s: ds 1
0068            152       ;z
0068            153       w:   ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
006B            154            number: ds 1;
006C            155       digits: ds 1;
006D            156            tenth: ds 1;
006E            157            individual_offest: ds 1;
006F            158       ;key
006F            159       keyin: ds 1
0070            160   
0070            161   
0070            162   ;-------------------;
0070            163   ;    Flags Define   ;
0070            164   ;-------------------; 
0070            165   ;Flag_name: dbit 1
0000            166   bseg
0000            167       FSM0_State_Changed:  dbit 1
0001            168       Main_State:          dbit 1 ; 0 for setting, 1 for reflowing
0002            169       ;for math32.inc
0002            170       mf: dbit 1
0003            171       enable_time_global: dbit 1
0004            172       half_seconds_flag: dbit 1 ; 500ms in double rate mode
0005            173           nodigit: dbit 1 ; if playing from 10 to 19 then we don't need to
0006            174                       ;play the last digit
0006            175            skiphundred: dbit 1
0007            176            skiptenth: dbit 1
0008            177   ;-----------------------;
0008            178   ;     Include Files     ;
0008            179   ;-----------------------; 
0008            180   ;$NOLIST
                 -1       $include(lcd_4bit.inc) 
005E              1   cseg
005E              2   
005E 30313233     3   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
006E 30313233     4   hex: db '0123456789abcdef',0
     34353637
     38396162
     63646566
     00
007F              5   
007F              6   ;LCD                '1234567890123456'
007F 57454C43     7   WELCOME1:        db 'WELCOME!        '   ,0
     4F4D4521
     20202020
     20202020
     00
0090 53757065     8   WELCOME2:        db 'Super Reflow!   '   ,0
     72205265
     666C6F77
     21202020
     00
00A1 53657474     9   MAIN_FACE1:      db 'Setting: Prof   '   ,0
     696E673A
     2050726F
     66202020
     00
00B2 53746172    10   MAIN_FACE2: db 'Start       Stop'   ,0
     74202020
     20202020
     53746F70
     00
00C3 53544D50    11   SETTING1:        db 'STMP:   STM:   s'   ,0
     3A202020
     53544D3A
     20202073
     00
00D4 52544D50    12   SETTING2:   db 'RTMP:   RTM:   s'   ,0
     3A202020
     52544D3A
     20202073
     00
00E5 4F4C443A    13   MODIFY_DOWN:db 'OLD:    NEW:    '   ,0
     20202020
     4E45573A
     20202020
     00
00F6 4D4F4449    14   MODIFY1:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
0107 4D4F4449    15   MODIFY2:         db 'MODIFY:TIME_SOAK'   ,0
     46593A54
     494D455F
     534F414B
     00
0118 4D4F4449    16   MODIFY3:         db 'MODIFY:TEMP_RFLW'   ,0
     46593A54
     454D505F
     52464C57
     00
0129 4D4F4449    17   MODIFY4:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
013A 4D4F4449    18   MODIFY5:    db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
014B 54454D50    19   WORKING:    db 'TEMP:   TIME:   '   ,0
     3A202020
     54494D45
     3A202020
     00
015C 53544D50    20   STEP1:           db 'STMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
016D 53544D3A    21   STEP2:      db 'STM:   s SOAKING'   ,0
     20202073
     20534F41
     4B494E47
     00
017E 52544D50    22   STEP3:      db 'RTMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
018F 52544D3A    23   STEP4:      db 'RTM:   s REFLOW '   ,0
     20202073
     20524546
     4C4F5720
     00
01A0 5346543A    24   STEP5:      db 'SFT:     COOLING'   ,0
     20202020
     20434F4F
     4C494E47
     00
01B1 20202020    25   STEP6:      db '         FINISH '   ,0
     20202020
     2046494E
     49534820
     00
01C2 4572726F    26   WARNING1:   db 'Error Warning!  '   ,0
     72205761
     726E696E
     67212020
     00
01D3 54454D50    27   WARNING2:   db 'TEMP Sensing ERR'   ,0
     2053656E
     73696E67
     20455252
     00
01E4             28   ;---------------------------------;
01E4             29   ;           Basic Macros          ;
01E4             30   ;---------------------------------;
                 31   LCD_Initailize mac
                 32   	lcall LCD_4BIT
                 33   endmac
01E4             34   
                 35   LCD_WriteData mac
                 36   	mov a, %0
                 37   	lcall ?LCD_WriteData
                 38   endmac
01E4             39            
                 40   LCD_WriteCommand mac
                 41   	mov a, %0
                 42   	lcall ?LCD_WriteCommand
                 43   endmac
01E4             44   
                 45   LCD_Send_Constant_String mac
                 46   	push dph
                 47   	push dpl
                 48   	push acc
                 49   	mov dptr, %0
                 50   	lcall ?Send_Constant_String
                 51   	pop acc
                 52   	pop dpl
                 53   	pop dph
                 54   endmac
01E4             55   
                 56   LCD_Set_Cursor mac
                 57   	push acc
                 58   	mov a, #%1
                 59   	dec a
                 60   	lcall ?Set_Cursor_%0 ; Select column and row
                 61   	pop acc
                 62   endmac
01E4             63   
                 64   LCD_Display_BCD mac
                 65   	push ar0
                 66   	mov r0, %0
                 67   	lcall ?Display_BCD
                 68   	pop ar0
                 69   endmac
01E4             70   
                 71   LCD_Display_NUM mac
                 72   	push ar0
                 73   	mov r0, %0
                 74   	lcall ?Display_NUM
                 75   	pop ar0
                 76   endmac
01E4             77   
                 78   LCD_Display_Char mac
                 79   	push acc
                 80   	mov a, %0
                 81   	lcall ?LCD_WriteData
                 82   	pop acc
                 83   endmac
01E4             84   
                 85   Wait_Milli_Seconds mac
                 86   	push AR2
                 87   	mov R2, %0
                 88   	lcall ?Wait_Milli_Seconds
                 89   	pop AR2
                 90   endmac
01E4             91   
01E4             92   ;---------------------------------;
01E4             93   ;         Interface Macros        ;
01E4             94   ;---------------------------------;
01E4             95   
                 96   LCD_INTERFACE_WELCOME mac
                 97   	LCD_Set_Cursor(1,1)
                 98   	LCD_Send_Constant_String(#WELCOME1)
                 99   	LCD_Set_Cursor(2,1)
                100   	LCD_Send_Constant_String(#WELCOME2)
                101   endmac
01E4            102   
                103   LCD_INTERFACE_MAIN mac
                104   	LCD_Set_Cursor(1,1)
                105   	LCD_Send_Constant_String(#MAIN_FACE1)
                106   	LCD_Set_Cursor(2,1)
                107   	LCD_Send_Constant_String(#MAIN_FACE2)
                108   	LCD_Set_Cursor(1,15); Profile number
                109   	LCD_Display_BCD(Profile_Num)
                110   endmac
01E4            112   
                113   LCD_INTERFACE_SETTING mac
                114   	LCD_Set_Cursor(1,1)
                115   	LCD_Send_Constant_String(#SETTING1)
                116   	LCD_Set_Cursor(2,1)
                117   	LCD_Send_Constant_String(#SETTING2)
                118   endmac
01E4            119   
                120   LCD_INTERFACE_MODIFY1 mac
                121   	LCD_Set_Cursor(1,1)
                122   	LCD_Send_Constant_String(#MODIFY1)
                123   	LCD_Set_Cursor(2,1)
                124   	LCD_Send_Constant_String(#MODIFY_DOWN)
                125   endmac
01E4            126   
                127   LCD_INTERFACE_MODIFY2 mac
                128   	LCD_Set_Cursor(1,1)
                129   	LCD_Send_Constant_String(#MODIFY2)
                130   	LCD_Set_Cursor(2,1)
                131   	LCD_Send_Constant_String(#MODIFY_DOWN)
                132   endmac
01E4            133   
                134   LCD_INTERFACE_MODIFY3 mac
                135   	LCD_Set_Cursor(1,1)
                136   	LCD_Send_Constant_String(#MODIFY3)
                137   	LCD_Set_Cursor(2,1)
                138   	LCD_Send_Constant_String(#MODIFY_DOWN)
                139   endmac
01E4            140   
                141   LCD_INTERFACE_MODIFY4 mac
                142   	LCD_Set_Cursor(1,1)
                143   	LCD_Send_Constant_String(#MODIFY4)
                144   	LCD_Set_Cursor(2,1)
                145   	LCD_Send_Constant_String(#MODIFY_DOWN)
                146   endmac
01E4            147   
                148   LCD_INTERFACE_MODIFY5 mac
                149   	LCD_Set_Cursor(1,1)
                150   	LCD_Send_Constant_String(#MODIFY5)
                151   	LCD_Set_Cursor(2,1)
                152   	LCD_Send_Constant_String(#MODIFY_DOWN)
                153   endmac
01E4            154   
                155   LCD_INTERFACE_STEP1 mac
                156   	LCD_Set_Cursor(1,1)
                157   	LCD_Send_Constant_String(#WORKING)
                158   	LCD_Set_Cursor(2,1)
                159   	LCD_Send_Constant_String(#STEP1)
                160   endmac
01E4            161   
                162   LCD_INTERFACE_STEP2 mac
                163   	LCD_Set_Cursor(1,1)
                164   	LCD_Send_Constant_String(#WORKING)
                165   	LCD_Set_Cursor(2,1)
                166   	LCD_Send_Constant_String(#STEP2)
                167   endmac
01E4            168   
                169   LCD_INTERFACE_STEP3 mac
                170   	LCD_Set_Cursor(1,1)
                171   	LCD_Send_Constant_String(#WORKING)
                172   	LCD_Set_Cursor(2,1)
                173   	LCD_Send_Constant_String(#STEP3)
                174   endmac
01E4            175   
                176   LCD_INTERFACE_STEP4 mac
                177   	LCD_Set_Cursor(1,1)
                178   	LCD_Send_Constant_String(#WORKING)
                179   	LCD_Set_Cursor(2,1)
                180   	LCD_Send_Constant_String(#STEP4)
                181   endmac
01E4            182   
                183   LCD_INTERFACE_STEP5 mac
                184   	LCD_Set_Cursor(1,1)
                185   	LCD_Send_Constant_String(#WORKING)
                186   	LCD_Set_Cursor(2,1)
                187   	LCD_Send_Constant_String(#STEP5)
                188   endmac
01E4            189   
                190   LCD_INTERFACE_STEP6 mac
                191   	LCD_Set_Cursor(1,1)
                192   	LCD_Send_Constant_String(#WORKING)
                193   	LCD_Set_Cursor(2,1)
                194   	LCD_Send_Constant_String(#STEP6)
                195   endmac
01E4            196   
                197   LCD_INTERFACE_WARNING mac
                198   	LCD_Set_Cursor(1,1)
                199   	LCD_Send_Constant_String(#WARNING1)
                200   	LCD_Set_Cursor(2,1)
                201   	LCD_Send_Constant_String(#WARNING2)
                202   endmac
01E4            203   
01E4            204   
01E4            205   Wait10us:
01E4 7812       206       mov R0, #18
01E6 D8FE       207       djnz R0, $ ; 2 machine cycles-> 2*0.27126us*18=10us
01E8 22         208            ret
01E9            209   ;---------------------------------;
01E9            210   ; Wait 40 microseconds            ;
01E9            211   ;---------------------------------;
01E9            212   Wait40uSec:
01E9 C000       213            push AR0
01EB 784A       214            mov R0, #74
01ED            215   L0: 
01ED D8FE       216            djnz R0, L0 ; 2 cycles->2*271.26ns*74=40us
01EF D000       217            pop AR0
01F1 22         218       ret
01F2            219   
01F2            220   ;---------------------------------;
01F2            221   ; Wait 500 microseconds           ;
01F2            222   ;---------------------------------;
01F2            223   WaitHalfSec:
01F2 7A28       224       mov R2, #40
01F4 79FA       225   H3: mov R1, #250
01F6 78B8       226   H2: mov R0, #184
01F8 D8FE       227   H1: djnz R0, H1 ; 2 machine cycles-> 2*0.27126us*184=100us
01FA D9FA       228       djnz R1, H2 ; 100us*250=0.025s
01FC DAF6       229       djnz R2, H3 ; 0.025s*20=0.5s
01FE 22         230       ret
01FF            231   
01FF            232   ;---------------------------------;
01FF            233   ; Wait 'R2' milliseconds          ;
01FF            234   ;---------------------------------;
01FF            235   ?Wait_Milli_Seconds:
01FF C000       236            push AR0
0201 C001       237            push AR1
0203 790A       238   L3: mov R1, #10
0205 78B8       239   L2: mov R0, #184
0207 D8FE       240   L1: djnz R0, L1 ; 2 cycles->2*271.26ns*184=100us
0209 D9FA       241       djnz R1, L2 ; 100us*10=1ms
020B DAF6       242       djnz R2, L3 ; number of millisecons to wait passed in R2
020D D001       243       pop AR1
020F D000       244       pop AR0
0211 22         245       ret
0212            246            
0212            247   ;---------------------------------;
0212            248   ; Toggles the 'E' pin in the LCD  ;
0212            249   ;---------------------------------;
0212            250   LCD_pulse:
0212 D283       251            setb LCD_E
0214 1201E9     252            lcall Wait40uSec
0217 C283       253            clr LCD_E
0219 1201E9     254       lcall Wait40uSec
021C 22         255       ret
021D            256   
021D            257   ;---------------------------------;
021D            258   ; Writes acc to LCD in 4-bit mode ;
021D            259   ;---------------------------------;
021D            260   LCD_byte:
021D            261            ; Write high 4 bits first
021D A2E7       262            mov c, ACC.7
021F 92B0       263            mov LCD_D7, c
0221 A2E6       264            mov c, ACC.6
0223 9287       265            mov LCD_D6, c
0225 A2E5       266            mov c, ACC.5
0227 9286       267            mov LCD_D5, c
0229 A2E4       268            mov c, ACC.4
022B 9285       269            mov LCD_D4, c
022D 120212     270       lcall LCD_pulse
0230            271            ; Write low 4 bits next
0230 A2E3       272            mov c, ACC.3
0232 92B0       273            mov LCD_D7, c
0234 A2E2       274            mov c, ACC.2
0236 9287       275            mov LCD_D6, c
0238 A2E1       276            mov c, ACC.1
023A 9286       277            mov LCD_D5, c
023C A2E0       278            mov c, ACC.0
023E 9285       279            mov LCD_D4, c
0240 120212     280       lcall LCD_pulse
0243 22         281            ret
0244            282   
0244            283   ;---------------------------------;
0244            284   ; Write data to LCD               ;
0244            285   ;---------------------------------;
0244            286   ?LCD_WriteData:
0244 D281       287            setb LCD_RS
0246 02021D     288            ljmp LCD_byte
0249            289   
0249            290   ;---------------------------------;
0249            291   ; Write command to LCD            ;
0249            292   ;---------------------------------;
0249            293   ?LCD_WriteCommand:
0249 C281       294            clr LCD_RS
024B 02021D     295            ljmp LCD_byte
024E            296   
024E            297   ;---------------------------------;
024E            298   ; Configure LCD in 4-bit mode     ;
024E            299   ;---------------------------------;
024E            300   LCD_4BIT:
024E C283       301            clr LCD_E   ; Resting state of LCD's enable pin is zero
0250 C282       302            clr LCD_RW  ; We are only writing to the LCD in this program
0252            303            
0252            304            ; After power on, let the LCD start up before initializing
0252 C002       305            push AR2
0254 7A28       305            mov R2, #40
0256 1201FF     305            lcall ?Wait_Milli_Seconds
0259 D002       305            pop AR2
025B            306            
025B            307            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
025B 7433       308            mov a, #0x33
025D 120249     308            lcall ?LCD_WriteCommand
0260 7433       309            mov a, #0x33
0262 120249     309            lcall ?LCD_WriteCommand
0265 7432       310            mov a, #0x32
0267 120249     310            lcall ?LCD_WriteCommand ; change to 4-bit mode
026A            311   
026A            312            ; Configure the LCD
026A 7428       313            mov a, #0x28
026C 120249     313            lcall ?LCD_WriteCommand
026F 740C       314            mov a, #0x0c
0271 120249     314            lcall ?LCD_WriteCommand
0274 7401       315            mov a, #0x01
0276 120249     315            lcall ?LCD_WriteCommand ;  Clear screen command (takes some time)
0279            316   
0279            317       ;Wait for the clear screen command to finish.
0279 C002       318            push AR2
027B 7A02       318            mov R2, #2
027D 1201FF     318            lcall ?Wait_Milli_Seconds
0280 D002       318            pop AR2
0282 22         319       ret
0283            320   
0283            321   ;---------------------------------;
0283            322   ; Send a constant string to LCD   ;
0283            323   ;---------------------------------;
0283            324   ?Send_Constant_String:
0283 E4         325       clr a
0284 93         326       movc a, @a+dptr
0285 6006       327       jz ?Send_Constant_String_Done
0287 120244     328       lcall ?LCD_WriteData
028A A3         329       inc dptr
028B 80F6       330       sjmp ?Send_Constant_String
028D            331   ?Send_Constant_String_Done:
028D 22         332       ret  
028E            333   
028E            334   ;---------------------------------;
028E            335   ; Set LCD cursor at row, column   ;
028E            336   ;---------------------------------;
028E            337   ?Set_Cursor_2:
028E 4440       338            orl a, #01000000B
0290            339   ?Set_Cursor_1:
0290 4480       340            orl a, #10000000B
0292 020249     341            ljmp ?LCD_WriteCommand ; Select column and row
0295            342   
0295            343   ;---------------------------------;
0295            344   ; Display a BCD number in the LCD ;
0295            345   ;---------------------------------;
0295            346   ?Display_BCD:
0295 C0E0       347            push acc
0297            348            ; Write most significant digit
0297 E8         349            mov a, r0
0298 C4         350            swap a
0299 540F       351            anl a, #0fh
029B 4430       352            orl a, #30h
029D 120244     353            lcall ?LCD_WriteData
02A0            354            ; write least significant digit
02A0 E8         355            mov a, r0
02A1 540F       356            anl a, #0fh
02A3 4430       357            orl a, #30h
02A5 120244     358            lcall ?LCD_WriteData
02A8 D0E0       359            pop acc
02AA 22         360            ret
02AB            361   
02AB            362   ?Display_NUM:
02AB C0E0       363            push acc
02AD E8         364            mov a, R0
02AE 540F       365            anl a, #0fh
02B0 4430       366            orl a, #30h
02B2 120244     367            lcall ?LCD_WriteData
02B5 D0E0       368            pop acc
02B7            369   
02B7 22         370            ret
                 -1       $include(math32.inc)
                559   $LIST
                 -1       $include(LPC9351.inc)
0528              1   cseg
0528              2   
0528              3   ;---------------------------------;
0528              4   ;           Basic Macros          ;
0528              5   ;---------------------------------;
                  6   Ports_Initialize mac
                  7       lcall Ports_Init
                  8   endmac
0528              9   
                 10   Clock_Double mac
                 11       lcall _Clock_Double
                 12   endmac
0528             13   
                 14   ADC_Initialize mac
                 15       lcall InitADC
                 16   endmac
0528             17   
0528             18   ;---------------------------------;
0528             19   ;            Functions            ;
0528             20   ;---------------------------------;
0528             21   _Clock_Double:
0528 C0E0        22       push acc
052A 90FFDE      23       mov dptr, #CLKCON
052D E0          24       movx a, @dptr
052E 4408        25       orl a, #00001000B ; double the clock speed to 14.746MHz
0530 F0          26       movx @dptr,a
0531 D0E0        27       pop acc
0533 22          28       ret
0534             29   
0534             30   ;---------------------------------;
0534             31   ; Initial configuration of ports. ;
0534             32   ; After reset the default for the ;
0534             33   ; pins is 'Open Drain'.  This     ;
0534             34   ; routine changes them pins to    ;
0534             35   ; Quasi-bidirectional like in the ;
0534             36   ; original 8051.                  ;
0534             37   ; Notice that P1.2 and P1.3 are   ;
0534             38   ; always 'Open Drain'. If those   ;
0534             39   ; pins are to be used as output   ;
0534             40   ; they need a pull-up resistor.   ;
0534             41   ;---------------------------------;
0534             42   Ports_Init:
0534             43       ; Configure all the ports in bidirectional mode:
0534 758400      44       mov P0M1, #00H
0537 758500      45       mov P0M2, #00H
053A 759100      46       mov P1M1, #00H
053D 759200      47       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0540 75A400      48       mov P2M1, #00H
0543 75A500      49       mov P2M2, #00H
0546 75B100      50       mov P3M1, #00H
0549 75B200      51       mov P3M2, #00H
054C 22          52            ret
054D             53   
054D             54   InitADC:
054D             55            ; ADC0_0 is connected to P1.7
054D             56            ; ADC0_1 is connected to P0.0
054D             57            ; ADC0_2 is connected to P2.1
054D             58            ; ADC0_3 is connected to P2.0
054D             59       ; Configure pins P1.7, P0.0, P2.1, and P2.0 as inputs
054D 438401      60       orl P0M1, #00000001b
0550 5385FE      61       anl P0M2, #11111110b
0553 439180      62       orl P1M1, #10000000b
0556 53927F      63       anl P1M2, #01111111b
0559 43A403      64       orl P2M1, #00000011b
055C 53A5FC      65       anl P2M2, #11111100b
055F             66            ; Setup ADC0
055F D2C2        67            setb BURST0 ; Autoscan continuos conversion mode
0561 75A120      68            mov     ADMODB,#0x20 ;ADC0 clock is 7.3728MHz/2
0564 75A30F      69            mov     ADINS,#0x0f ; Select the four channels of ADC0 for conversion
0567 758E05      70            mov     ADCON0,#0x05 ; Enable the converter and start immediately
056A             71            ; Wait for first conversion to complete
056A             72   InitADC_L1:
056A E58E        73            mov     a,ADCON0
056C 30E3FB      74            jnb     acc.3,InitADC_L1
056F 22          75            ret
                 76   DO_NOTHING mac
                 77   	NOP
                 78   endmac
                 78   $LIST
                 -1       $include(serial.inc)
0570              1   CSEG
0570              2   
0570              3   
0570              4   ;---------------------------------;
0570              5   ;           Basic Macros          ;
0570              6   ;---------------------------------;
                  7   Serial_Initialize mac
                  8   	;Serial_Initialize()
                  9       lcall _Serial_Initialize
                 10   endmac
0570             11   
                 12   Serial_Send_Char mac
                 13       mov a, %0
                 14       lcall putchar
                 15   endmac
0570             16   
                 17   Serial_Read_Char mac
                 18   	;Serial_Read_Char(direct)
                 19       lcall getchar
                 20       mov %0, a
                 21   endmac
0570             22   
                 23   Serial_Send_Newline mac
                 24   	lcall Send_NewLine
                 25   endmac
0570             26   
                 27   Serial_Send_BCD mac
                 28   	push ar0
                 29   	mov r0, %0
                 30   	lcall ?Send_BCD
                 31   	pop ar0
                 32   endmac
0570             33   
                 34   Serial_Send_Constant_String mac
                 35   	mov dptr, %0
                 36   	lcall SendString
                 37   endmac
0570             38   
0570             39   ;---------------------------------;
0570             40   ; Initialize the serial port      ;
0570             41   ;---------------------------------;
0570             42   _Serial_Initialize:
0570 75BD00      43            mov     BRGCON,#0x00
0573 75BF00      44            mov     BRGR1,#high(BRVAL)
0576 75BE30      45            mov     BRGR0,#low(BRVAL)
0579 75BD03      46            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
057C 759852      47            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
057F             48            ; Make sure that TXD(P1.0) and RXD(P1.1) are configured as bidrectional I/O
057F 5391FC      49            anl     P1M1,#11111100B
0582 5392FC      50            anl     P1M2,#11111100B
0585 22          51            ret
0586             52   
0586             53   ;---------------------------------;
0586             54   ; Sends a byte via serial port    ;
0586             55   ;---------------------------------;
0586             56   putchar:
0586 109902      57            jbc     TI,putchar_L1
0589 80FB        58            sjmp putchar
058B             59   putchar_L1:
058B F599        60            mov     SBUF,a
058D 22          61            ret
058E             62   
058E             63   SendString:
058E E4          64       clr a
058F 93          65       movc a, @a+dptr
0590 6006        66       jz SendString_L1
0592 120586      67       lcall putchar
0595 A3          68       inc dptr
0596 80F6        69       sjmp SendString  
0598             70   SendString_L1:
0598 22          71            ret
0599             72   
0599             73   ;---------------------------------;
0599             74   ; Send a BCD number to PuTTY      ;
0599             75   ;---------------------------------;
0599             76   ?Send_BCD:
0599 C0E0        77            push acc
059B             78            ; Write most significant digit
059B E8          79            mov a, r0
059C C4          80            swap a
059D 540F        81            anl a, #0fh
059F 4430        82            orl a, #30h
05A1 120586      83            lcall putchar
05A4             84            ; write least significant digit
05A4 E8          85            mov a, r0
05A5 540F        86            anl a, #0fh
05A7 4430        87            orl a, #30h
05A9 120586      88            lcall putchar
05AC D0E0        89            pop acc
05AE 22          90            ret
05AF             91   
05AF             92   Send_NewLine:
05AF 740D        93            mov a, #'\r'
05B1 120586      94            lcall putchar
05B4 740A        95            mov a, #'\n'
05B6 120586      96            lcall putchar   
05B9 22          97            ret
05BA             98   
05BA             99   
05BA            100   SendTemp0:
05BA 90005E     101            mov dptr, #HexAscii 
05BD            102            
05BD            103            
05BD            104            
05BD E565       105            mov a, bcd+3
05BF C4         106            swap a
05C0 540F       107            anl a, #0xf
05C2 93         108            movc a, @a+dptr
05C3 120586     109            lcall putchar
05C6 E565       110            mov a, bcd+3
05C8 540F       111            anl a, #0xf
05CA 93         112            movc a, @a+dptr
05CB 120586     113            lcall putchar
05CE            114            
05CE E564       115            mov a, bcd+2
05D0 C4         116            swap a
05D1 540F       117            anl a, #0xf
05D3 93         118            movc a, @a+dptr
05D4 120586     119            lcall putchar
05D7 E564       120            mov a, bcd+2
05D9 540F       121            anl a, #0xf
05DB 93         122            movc a, @a+dptr
05DC 120586     123            lcall putchar
05DF            124            
05DF E563       125            mov a, bcd+1
05E1 C4         126            swap a
05E2 540F       127            anl a, #0xf
05E4 93         128            movc a, @a+dptr
05E5 120586     129            lcall putchar
05E8 E563       130            mov a, bcd+1
05EA 540F       131            anl a, #0xf
05EC 93         132            movc a, @a+dptr
05ED 120586     133            lcall putchar
05F0            134   
05F0            135   
05F0 E562       136            mov a, bcd+0
05F2 C4         137            swap a
05F3 540F       138            anl a, #0xf
05F5 93         139            movc a, @a+dptr
05F6 120586     140            lcall putchar
05F9 E562       141            mov a, bcd+0
05FB 540F       142            anl a, #0xf
05FD 93         143            movc a, @a+dptr
05FE 120586     144            lcall putchar
0601 22         145            ret
                 -1       $include(temperature.inc)
0602              1   cseg
0602              2   
0602              3   
0602              4   
0602              5   Read_Oven_Temp:
0602              6            ; Take 256 (4^4) consecutive measurements of ADC0 channel 0 at about 10 us intervals and accumulate in x
0602 755A00       7            mov x+0, #low (0 % 0x10000) 
0605 755B00       7            mov x+1, #high(0 % 0x10000) 
0608 755C00       7            mov x+2, #low (0 / 0x10000) 
060B 755D00       7            mov x+3, #high(0 / 0x10000) 
060E 85C75A       8       mov x+0, ad0dat2
0611 7FFF         9            mov R7, #255
0613 1201E4      10       lcall Wait10us
0616             11   accumulate_loop0:
0616 85C75E      12       mov y+0, ad0dat2
0619 755F00      13       mov y+1, #0
061C 756000      14       mov y+2, #0
061F 756100      15       mov y+3, #0
0622 12037D      16       lcall add32
0625 1201E4      17       lcall Wait10us
0628 DFEC        18            djnz R7, accumulate_loop0
062A             19            
062A             20            ; Now divide by 16 (2^4)
062A 755E10      21            mov y+0, #low (16 % 0x10000) 
062D 755F00      21            mov y+1, #high(16 % 0x10000) 
0630 756000      21            mov y+2, #low (16 / 0x10000) 
0633 756100      21            mov y+3, #high(16 / 0x10000) 
0636 1204BF      22            lcall div32
0639             23            ; x has now the 12-bit representation of the temperature
0639             24            
0639             25            ; Convert to temperature (C)
0639 755EE8      26            mov y+0, #low (33000 % 0x10000) 
063C 755F80      26            mov y+1, #high(33000 % 0x10000) 
063F 756000      26            mov y+2, #low (33000 / 0x10000) 
0642 756100      26            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
0645 120432      27            lcall mul32
0648 755E00      28            mov y+0, #low (((1<<12)) % 0x10000) 
064B 755F10      28            mov y+1, #high(((1<<12)) % 0x10000) 
064E 756000      28            mov y+2, #low (((1<<12)) / 0x10000) 
0651 756100      28            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
0654 1204BF      29            lcall div32
0657 755E3C      30            mov y+0, #low (60 % 0x10000) 
065A 755F00      30            mov y+1, #high(60 % 0x10000) 
065D 756000      30            mov y+2, #low (60 / 0x10000) 
0660 756100      30            mov y+3, #high(60 / 0x10000) 
0663 12039E      31            lcall sub32
0666             32   
0666             33            ;mov32(Current_Oven_Volt,x); store the hex value of voltage
0666             34            
0666 755E0E      35            mov y+0, #low (7438 % 0x10000) 
0669 755F1D      35            mov y+1, #high(7438 % 0x10000) 
066C 756000      35            mov y+2, #low (7438 / 0x10000) 
066F 756100      35            mov y+3, #high(7438 / 0x10000) 
0672 120432      36            lcall mul32
0675 755E10      37            mov y+0, #low (10000 % 0x10000) 
0678 755F27      37            mov y+1, #high(10000 % 0x10000) 
067B 756000      37            mov y+2, #low (10000 / 0x10000) 
067E 756100      37            mov y+3, #high(10000 / 0x10000) 
0681 1204BF      38            lcall div32
0684 755EB4      39            mov y+0, #low (180 % 0x10000) 
0687 755F00      39            mov y+1, #high(180 % 0x10000) 
068A 756000      39            mov y+2, #low (180 / 0x10000) 
068D 756100      39            mov y+3, #high(180 / 0x10000) 
0690 12039E      40            lcall sub32
0693             41            ;now we got the relateive temp number in hex
0693             42   
0693             43       ;mov(dst, src)
0693 854D61      43            mov y+3, Current_Room_Temp+3
0696 854C60      43       mov y+2, Current_Room_Temp+2
0699 854B5F      43       mov y+1, Current_Room_Temp+1
069C 854A5E      43       mov y,   Current_Room_Temp
069F 12037D      44            lcall add32
06A2             45            ;now we got the true value of oven in hex
06A2 1202B8      46            lcall hex2bcd
06A5 1205BA      47            lcall SendTemp0; send to PC through serial port
06A8 1205AF      48            lcall Send_Newline
06AB 755E64      49            mov y+0, #low (100 % 0x10000) 
06AE 755F00      49            mov y+1, #high(100 % 0x10000) 
06B1 756000      49            mov y+2, #low (100 / 0x10000) 
06B4 756100      49            mov y+3, #high(100 / 0x10000) 
06B7 1204BF      50            lcall div32;divide by 100 to get the value in integer
06BA             51            ; now x contains the value in hex
06BA 755E5E      52            mov y+0, #low (350 % 0x10000) 
06BD 755F01      52            mov y+1, #high(350 % 0x10000) 
06C0 756000      52            mov y+2, #low (350 / 0x10000) 
06C3 756100      52            mov y+3, #high(350 / 0x10000) 
06C6 1203C0      53            lcall x_lt_y
06C9 200203      54            jb mf, Temp_OK
06CC             55            ;if not ok
06CC 020602      56            ljmp Read_Oven_Temp;re-read the value
06CF             57   
06CF             58            Temp_OK:
06CF             59       ;mov(dst, src)
06CF 855D51      59            mov Current_Oven_Temp+3, x+3
06D2 855C50      59       mov Current_Oven_Temp+2, x+2
06D5 855B4F      59       mov Current_Oven_Temp+1, x+1
06D8 855A4E      59       mov Current_Oven_Temp,   x
06DB 22          60            ret
06DC             61   
06DC             62   Read_Room_Temp:
06DC             63            
06DC 755A00      64            mov x+0, #low (0 % 0x10000) 
06DF 755B00      64            mov x+1, #high(0 % 0x10000) 
06E2 755C00      64            mov x+2, #low (0 / 0x10000) 
06E5 755D00      64            mov x+3, #high(0 / 0x10000) 
06E8 85C75A      65       mov x+0, ad0dat2
06EB 7FFF        66            mov R7, #255
06ED 1201E4      67       lcall Wait10us
06F0             68       
06F0             69   accumulate_loop1:
06F0 85F45E      70       mov y+0, ad0dat3
06F3 755F00      71       mov y+1, #0
06F6 756000      72       mov y+2, #0
06F9 756100      73       mov y+3, #0
06FC 12037D      74       lcall add32
06FF 1201E4      75       lcall Wait10us
0702 DFEC        76            djnz R7, accumulate_loop1
0704             77            
0704             78            ; Now divide by 16 (2^4)
0704 755E10      79            mov y+0, #low (16 % 0x10000) 
0707 755F00      79            mov y+1, #high(16 % 0x10000) 
070A 756000      79            mov y+2, #low (16 / 0x10000) 
070D 756100      79            mov y+3, #high(16 / 0x10000) 
0710 1204BF      80            lcall div32
0713             81            ; x has now the 12-bit representation of the temperature
0713             82            
0713             83            ; Convert to temperature (C)
0713 755EE8      84            mov y+0, #low (33000 % 0x10000) 
0716 755F80      84            mov y+1, #high(33000 % 0x10000) 
0719 756000      84            mov y+2, #low (33000 / 0x10000) 
071C 756100      84            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
071F 120432      85            lcall mul32
0722 755E00      86            mov y+0, #low (((1<<12)) % 0x10000) 
0725 755F10      86            mov y+1, #high(((1<<12)) % 0x10000) 
0728 756000      86            mov y+2, #low (((1<<12)) / 0x10000) 
072B 756100      86            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
072E 1204BF      87            lcall div32
0731 755E3C      88            mov y+0, #low (60 % 0x10000) 
0734 755F00      88            mov y+1, #high(60 % 0x10000) 
0737 756000      88            mov y+2, #low (60 / 0x10000) 
073A 756100      88            mov y+3, #high(60 / 0x10000) 
073D 12039E      89            lcall sub32
0740             90            
0740             91            ;now we got the voltage value
0740             92            ;mov32(Current_Room_Volt,x)
0740             93            
0740 755EA4      94            mov y+0, #low (27300 % 0x10000) 
0743 755F6A      94            mov y+1, #high(27300 % 0x10000) 
0746 756000      94            mov y+2, #low (27300 / 0x10000) 
0749 756100      94            mov y+3, #high(27300 / 0x10000) 
074C 12039E      95            lcall sub32
074F 755EF4      96            mov y+0, #low (500 % 0x10000) 
0752 755F01      96            mov y+1, #high(500 % 0x10000) 
0755 756000      96            mov y+2, #low (500 / 0x10000) 
0758 756100      96            mov y+3, #high(500 / 0x10000) 
075B 12039E      97            lcall sub32
075E             98            ;now we got the temperature
075E             99       ;mov(dst, src)
075E 855D4D      99            mov Current_Room_Temp+3, x+3
0761 855C4C      99       mov Current_Room_Temp+2, x+2
0764 855B4B      99       mov Current_Room_Temp+1, x+1
0767 855A4A      99       mov Current_Room_Temp,   x
076A            100            
076A 22         101            ret
                 -1       $include(speaker.inc)
                458   $LIST
                 -1       $include(key.inc)
0BAF              1   cseg
0BAF              2   
0BAF              3   
0BAF              4   ;-----------------------;
0BAF              5   ;    Functions Define   ;
0BAF              6   ;-----------------------; 
0BAF              7   
0BAF              8   ;Key_Read: if read, return the button readed.
0BAF              9   ;Return 0 if read nothing.
0BAF             10   Key_Read:
0BAF C0E0        11       push acc
0BB1 120BC0      12       lcall ADC_to_PB; read lower 8 button
0BB4 E56F        13       mov a, keyin
0BB6 B40001      14       cjne a, #0, Continue_Read_Key; if nothing, continue read key
0BB9 22          15       ret; if read successfully, return
0BBA             16       Continue_Read_Key:
0BBA 120C11      17       lcall ADC_to_PB_1
0BBD D0E0        18            pop acc
0BBF 22          19       ret
0BC0             20   
0BC0             21   ADC_to_PB:
0BC0 756F00      22       mov keyin, #0;clear input
0BC3             23            ; Check PB6
0BC3 C3          24            clr c
0BC4 E5C5        25            mov a, AD0DAT0
0BC6 94A3        26            subb a, #(173-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
0BC8 4004        27            jc ADC_to_PB_L6
0BCA 756F07      28       mov keyin, #7
0BCD 22          29            ret
0BCE             30   ADC_to_PB_L6:
0BCE             31            ; Check PB5
0BCE C3          32            clr c
0BCF E5C5        33            mov a, AD0DAT0; P1.7
0BD1 9491        34            subb a, #(155-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
0BD3 4004        35            jc ADC_to_PB_L5
0BD5 756F06      36            mov keyin, #6
0BD8 22          37            ret
0BD9             38   ADC_to_PB_L5:
0BD9             39            ; Check PB4
0BD9 C3          40            clr c
0BDA E5C5        41            mov a, AD0DAT0
0BDC 9478        42            subb a, #(130-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
0BDE 4004        43            jc ADC_to_PB_L4
0BE0 756F05      44            mov keyin, #5
0BE3 22          45            ret
0BE4             46   ADC_to_PB_L4:
0BE4             47            ; Check PB3
0BE4 C3          48            clr c
0BE5 E5C5        49            mov a, AD0DAT0
0BE7 9462        50            subb a, #(108-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
0BE9 4004        51            jc ADC_to_PB_L3
0BEB 756F04      52            mov keyin, #4
0BEE 22          53            ret
0BEF             54   ADC_to_PB_L3:
0BEF             55            ; Check PB2
0BEF C3          56            clr c
0BF0 E5C5        57            mov a, AD0DAT0
0BF2 9444        58            subb a, #(78-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
0BF4 4004        59            jc ADC_to_PB_L2
0BF6 756F03      60            mov keyin, #3
0BF9 22          61            ret
0BFA             62   ADC_to_PB_L2:
0BFA             63            ; Check PB1
0BFA C3          64            clr c
0BFB E5C5        65            mov a, AD0DAT0
0BFD 9433        66            subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
0BFF 4004        67            jc ADC_to_PB_L1
0C01 756F02      68            mov keyin, #2
0C04 22          69            ret
0C05             70   ADC_to_PB_L1:
0C05             71            ; Check PB1
0C05 C3          72            clr c
0C06 E5C5        73            mov a, AD0DAT0
0C08 9413        74            subb a, #(29-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
0C0A 4004        75            jc ADC_to_PB_L0
0C0C 756F01      76            mov keyin, #1
0C0F 22          77            ret
0C10             78   ADC_to_PB_L0:
0C10             79            ; No pusbutton pressed  
0C10 22          80            ret
0C11             81   
0C11             82   ADC_to_PB_1:
0C11             83            ; Check PB6
0C11 C3          84            clr c
0C12 E5C6        85            mov a, AD0DAT1
0C14 94C4        86            subb a, #(206-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
0C16 4004        87            jc ADC_to_PB_L6_2
0C18 756F0E      88            mov keyin, #14
0C1B 22          89            ret
0C1C             90   ADC_to_PB_L6_2:
0C1C             91            ; Check PB5
0C1C C3          92            clr c
0C1D E5C6        93            mov a, AD0DAT1
0C1F 94AF        94            subb a, #(185-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
0C21 4004        95            jc ADC_to_PB_L5_2
0C23 756F0D      96            mov keyin, #13
0C26 22          97            ret
0C27             98   ADC_to_PB_L5_2:
0C27             99            ; Check PB4
0C27 C3         100            clr c
0C28 E5C6       101            mov a, AD0DAT1
0C2A 9490       102            subb a, #(154-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
0C2C 4004       103            jc ADC_to_PB_L4_2
0C2E 756F0C     104            mov keyin, #12
0C31 22         105            ret
0C32            106   ADC_to_PB_L4_2:
0C32            107            ; Check PB3
0C32 C3         108            clr c
0C33 E5C6       109            mov a, AD0DAT1
0C35 9471       110            subb a, #(123-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
0C37 4004       111            jc ADC_to_PB_L3_2
0C39 756F0B     112            mov keyin, #11
0C3C 22         113            ret
0C3D            114   ADC_to_PB_L3_2:
0C3D            115            ; Check PB2
0C3D C3         116            clr c
0C3E E5C6       117            mov a, AD0DAT1
0C40 9452       118            subb a, #(92-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
0C42 4004       119            jc ADC_to_PB_L2_2
0C44 756F0A     120            mov keyin, #10
0C47 22         121            ret
0C48            122   ADC_to_PB_L2_2:
0C48            123            ; Check PB1
0C48 C3         124            clr c
0C49 E5C6       125            mov a, AD0DAT1
0C4B 9433       126            subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
0C4D 4004       127            jc ADC_to_PB_L1_2
0C4F 756F09     128            mov keyin, #9
0C52 22         129            ret
0C53            130   ADC_to_PB_L1_2:
0C53            131            ; Check PB1
0C53 C3         132            clr c
0C54 E5C6       133            mov a, AD0DAT1
0C56 9414       134            subb a, #(30-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
0C58 4004       135            jc ADC_to_PB_L01
0C5A 756F08     136            mov keyin, #8
0C5D 22         137            ret
0C5E            138   ADC_to_PB_L01:
0C5E            139            ; No pusbutton pressed  
0C5E 22         140            ret
0C5F            188   ;$LIST
0C5F            189   
0C5F            190   cseg
0C5F            191   
0C5F            192   MainProgram:
0C5F 75817F     193       mov SP, #0x7F
0C62 120534     194       lcall Ports_Init
0C65 12024E     195            lcall LCD_4BIT
0C68            196            ;Serial_Initialize()
0C68 120570     196       lcall _Serial_Initialize
0C6B 12054D     197       lcall InitADC
0C6E C0E0       198            push acc
0C70 7401       198            mov a, #1
0C72 14         198            dec a
0C73 120290     198            lcall ?Set_Cursor_1 ; Select column and row
0C76 D0E0       198            pop acc
0C78 C083       198            push dph
0C7A C082       198            push dpl
0C7C C0E0       198            push acc
0C7E 90007F     198            mov dptr, #WELCOME1
0C81 120283     198            lcall ?Send_Constant_String
0C84 D0E0       198            pop acc
0C86 D082       198            pop dpl
0C88 D083       198            pop dph
0C8A C0E0       198            push acc
0C8C 7401       198            mov a, #1
0C8E 14         198            dec a
0C8F 12028E     198            lcall ?Set_Cursor_2 ; Select column and row
0C92 D0E0       198            pop acc
0C94 C083       198            push dph
0C96 C082       198            push dpl
0C98 C0E0       198            push acc
0C9A 900090     198            mov dptr, #WELCOME2
0C9D 120283     198            lcall ?Send_Constant_String
0CA0 D0E0       198            pop acc
0CA2 D082       198            pop dpl
0CA4 D083       198            pop dph
0CA6 120D42     199       lcall Data_Initialization
0CA9 1207B3     200       lcall InitDAC
0CAC 12076B     201       lcall CCU_Init
0CAF 1207C3     202            lcall Init_SPI
0CB2 120CE5     203       lcall External_Interrupt0_Init
0CB5 120CE8     204       lcall External_Interrupt1_Init
0CB8 C2C8       205       clr TMOD20 ; Stop CCU timer
0CBA D2AF       206       setb EA   ; Enable Global interrupts
0CBC C2A7       207       clr OVEN
0CBE            208   
0CBE            209   Main_Loop:
0CBE            210   
0CBE            211   
0CBE            212   
0CBE 3004FD     213       jnb half_seconds_flag, Main_Loop
0CC1            214   
0CC1            215   loop_b:
0CC1 C204       216       clr half_seconds_flag
0CC3 0567       217       inc Count5s
0CC5 E567       218       mov a, Count5s
0CC7 B40506     219       cjne a, #5, skip3
0CCA 756700     220       mov Count5s, #0
0CCD 121210     221       lcall Speak_Process
0CD0            222       skip3:
0CD0            223   
0CD0 80EC       224            sjmp Main_Loop
0CD2            225   
0CD2            226   
0CD2            227   
0CD2            228   
0CD2            229   ;----------------------------;
0CD2            230   ;           Macros           ;
0CD2            231   ;----------------------------; 
                232   Display_3BCD_from_x mac
                233       lcall hex2bcd
                234       ;now the bcd num of time is stored in bcd
                235       LCD_Display_NUM(bcd+1);
                236       LCD_Display_BCD(bcd);
                237   endmac
0CD2            238   
                239   Update_Temp mac
                240       lcall Read_Room_Temp
                241       lcall Read_Oven_Temp
                242       mov32(x, Current_Oven_Temp)
                243       mov32(y, %0)
                244       lcall x_lt_y
                245   endmac
0CD2            247   
0CD2            248   ;----------------------------;
0CD2            249   ;         Functions          ;
0CD2            250   ;----------------------------; 
0CD2            251   
0CD2            252   Timer1_Init:
0CD2 E589       253            mov a, TMOD
0CD4 540F       254            anl a, #0x0f ; Clear the bits for timer 1
0CD6 4410       255            orl a, #0x10 ; Configure timer 1 as 16-timer
0CD8 F589       256            mov TMOD, a
0CDA 758D6F     257            mov TH1, #high(TIMER1_RELOAD)
0CDD 758BFF     258            mov TL1, #low(TIMER1_RELOAD)
0CE0            259            ; Enable the timer and interrupts
0CE0 D2AB       260       setb ET1  ; Enable timer 1 interrupt
0CE2 D28E       261       setb TR1  ; Start timer 1
0CE4 22         262            ret
0CE5            263   
0CE5            264   External_Interrupt0_Init:
0CE5            265            ; Enable the external interrupt
0CE5 D2A8       266       setb EX0  ; Enable timer 1 interrupt
0CE7 22         267            ret
0CE8            268   
0CE8            269   External_Interrupt1_Init:
0CE8            270            ; Enable the external interrupt
0CE8 D2AA       271       setb EX1  ; Enable timer 1 interrupt
0CEA 22         272            ret
0CEB            273   
0CEB            274   Display_Working_Status:
0CEB C0E0       275            push acc
0CED 7406       275            mov a, #6
0CEF 14         275            dec a
0CF0 120290     275            lcall ?Set_Cursor_1 ; Select column and row
0CF3 D0E0       275            pop acc
0CF5            276       ;mov(dst, src)
0CF5 85515D     276            mov x+3, Current_Oven_Temp+3
0CF8 85505C     276       mov x+2, Current_Oven_Temp+2
0CFB 854F5B     276       mov x+1, Current_Oven_Temp+1
0CFE 854E5A     276       mov x,   Current_Oven_Temp
0D01 1202B8     277       lcall hex2bcd
0D04            277       ;now the bcd num of time is stored in bcd
0D04 C000       277            push ar0
0D06 A863       277            mov r0, bcd+1
0D08 1202AB     277            lcall ?Display_NUM
0D0B D000       277            pop ar0;
0D0D C000       277            push ar0
0D0F A862       277            mov r0, bcd
0D11 120295     277            lcall ?Display_BCD
0D14 D000       277            pop ar0;
0D16            278   
0D16 C0E0       279            push acc
0D18 740E       279            mov a, #14
0D1A 14         279            dec a
0D1B 120290     279            lcall ?Set_Cursor_1 ; Select column and row
0D1E D0E0       279            pop acc
0D20 755D00     280       mov x+3, #0
0D23 755C00     281       mov x+2, #0
0D26 755B00     282       mov x+1, #0
0D29 85315A     283       mov x, Time_Global
0D2C 1202B8     284       lcall hex2bcd
0D2F            284       ;now the bcd num of time is stored in bcd
0D2F C000       284            push ar0
0D31 A863       284            mov r0, bcd+1
0D33 1202AB     284            lcall ?Display_NUM
0D36 D000       284            pop ar0;
0D38 C000       284            push ar0
0D3A A862       284            mov r0, bcd
0D3C 120295     284            lcall ?Display_BCD
0D3F D000       284            pop ar0;
0D41 22         285       ret
0D42            286   
0D42            287   Data_Initialization:
0D42 753100     288       mov Time_Global, #0x00
0D45 753900     289       mov TEMP_SOAK+3, #0x00
0D48 753800     290       mov TEMP_SOAK+2, #0x00
0D4B 753700     291       mov TEMP_SOAK+1, #0x00
0D4E 753696     292       mov TEMP_SOAK, #150
0D51 754100     293       mov TEMP_RFLW+3, #0
0D54 754000     294       mov TEMP_RFLW+2, #0
0D57 753F00     295       mov TEMP_RFLW+1, #0
0D5A 753ED9     296       mov TEMP_RFLW, #217
0D5D 753D00     297       mov TIME_SOAK+3, #0
0D60 753C00     298       mov TIME_SOAK+2, #0
0D63 753B00     299       mov TIME_SOAK+1, #0
0D66 753A3C     300       mov TIME_SOAK, #60
0D69 754500     301       mov TIME_RFLW+3, #0
0D6C 754400     302       mov TIME_RFLW+2, #0
0D6F 754300     303       mov TIME_RFLW+1, #0
0D72 75424B     304       mov TIME_RFLW, #75
0D75 754900     305       mov TEMP_SAFE+3, #0
0D78 754800     306       mov TEMP_SAFE+2, #0
0D7B 754700     307       mov TEMP_SAFE+1, #0
0D7E 75463C     308       mov TEMP_SAFE, #60
0D81 753300     309       mov FSM0_State, #0
0D84 753400     310       mov FSM1_State, #0
0D87 756B00     311       mov number, #0x0 ;;not needed
0D8A 756E00     312       mov individual_offest, #0x0
0D8D 756700     313       mov Count5s, #0x00
0D90            314       
0D90 C296       315       clr LED
0D92 C203       316       clr enable_time_global
0D94 C205       317       clr nodigit
0D96 C206       318            clr skiphundred
0D98 C207       319            clr skiptenth
0D9A C201       320       clr Main_State
0D9C            321   
0D9C C0E0       322            push acc
0D9E 7401       322            mov a, #1
0DA0 14         322            dec a
0DA1 120290     322            lcall ?Set_Cursor_1 ; Select column and row
0DA4 D0E0       322            pop acc
0DA6 C083       322            push dph
0DA8 C082       322            push dpl
0DAA C0E0       322            push acc
0DAC 90007F     322            mov dptr, #WELCOME1
0DAF 120283     322            lcall ?Send_Constant_String
0DB2 D0E0       322            pop acc
0DB4 D082       322            pop dpl
0DB6 D083       322            pop dph
0DB8 C0E0       322            push acc
0DBA 7401       322            mov a, #1
0DBC 14         322            dec a
0DBD 12028E     322            lcall ?Set_Cursor_2 ; Select column and row
0DC0 D0E0       322            pop acc
0DC2 C083       322            push dph
0DC4 C082       322            push dpl
0DC6 C0E0       322            push acc
0DC8 900090     322            mov dptr, #WELCOME2
0DCB 120283     322            lcall ?Send_Constant_String
0DCE D0E0       322            pop acc
0DD0 D082       322            pop dpl
0DD2 D083       322            pop dph
0DD4 22         323       ret
0DD5            324   
0DD5            325   ;----------------------------;
0DD5            326   ;     Interrupt Services     ;
0DD5            327   ;----------------------------; 
0DD5            328   Timer1_ISR:
0DD5 758D6F     329            mov TH1, #high(TIMER1_RELOAD)
0DD8 758BFF     330            mov TL1, #low(TIMER1_RELOAD)
0DDB B2A6       331            cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0DDD            332            
0DDD            333            ; The two registers used in the ISR must be saved in the stack
0DDD C0E0       334            push acc
0DDF C0D0       335            push psw
0DE1            336            
0DE1            337            ; Increment the 8-bit 10-mili-second counter
0DE1 0530       338            inc Count10ms
0DE3            339   
0DE3            340   Inc_Done:
0DE3            341            ; Check if half second has passed
0DE3 E530       342            mov a, Count10ms
0DE5 B4640F     343            cjne a, #100, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
0DE8            344            
0DE8            345            ; 500 milliseconds have passed.  Set a flag so the main program knows
0DE8 D204       346            setb half_seconds_flag ; Let the main program know half second had passed
0DEA            347       
0DEA 300302     348       jnb enable_time_global, skip1
0DED 0531       349       inc Time_Global
0DEF            350            skip1:
0DEF 753000     351       mov Count10ms, #0
0DF2            352   
0DF2 B296       353       cpl LED
0DF4 120E39     354       lcall FSM1;call FSM1 here
0DF7            355   
0DF7            356   Timer1_ISR_done:
0DF7 D0D0       357            pop psw
0DF9 D0E0       358            pop acc
0DFB 32         359            reti
0DFC            360   
0DFC            361   EI0_ISR:
0DFC C288       362       clr IT0
0DFE 120CD2     363       lcall Timer1_Init
0E01 32         364       reti
0E02            365   
0E02            366   EI1_ISR:
0E02 C28A       367       clr IT1
0E04 C28E       368       clr TR1; disable  timer 1
0E06 120D42     369       lcall Data_Initialization
0E09 32         370       reti
0E0A            371   
0E0A            372   ;---------------------------------;
0E0A            373   ;      Finite State Machines      ;
0E0A            374   ;---------------------------------;
0E0A            375   FSM0:
0E0A C0E0       376       push acc
0E0C 120BAF     377       lcall Key_Read
0E0F E533       378       mov a, FSM0_State
0E11 755A00     379            mov x+0, #low (0 % 0x10000) 
0E14 755B00     379            mov x+1, #high(0 % 0x10000) 
0E17 755C00     379            mov x+2, #low (0 / 0x10000) 
0E1A 755D00     379            mov x+3, #high(0 / 0x10000) 
0E1D 856F5A     380       mov x, keyin
0E20 1202B8     381       lcall hex2bcd
0E23 C0E0       382            push acc
0E25 740A       382            mov a, #10
0E27 14         382            dec a
0E28 120290     382            lcall ?Set_Cursor_1 ; Select column and row
0E2B D0E0       382            pop acc
0E2D C000       383            push ar0
0E2F A862       383            mov r0, bcd
0E31 120295     383            lcall ?Display_BCD
0E34 D000       383            pop ar0
0E36 D0E0       384       pop acc
0E38 22         385   ret
0E39            386   
0E39            387   
0E39            388       ;---------------------------------;
0E39            389       ; FSM1 using Timer Interrupt      ;
0E39            390       ;---------------------------------;
0E39            391       ;update status and send data to LCD and PC every one/half seconds
0E39            392   FSM1:
0E39            393   
0E39            394   
0E39 E534       395       mov a, FSM1_State
0E3B            396       FSM1_State0:
0E3B B40002     397           cjne a, #0, JUMP_FSM1_State1
0E3E 8003       398           sjmp Start_FSM1_State0
0E40            399           JUMP_FSM1_State1:
0E40 020F01     400           ljmp FSM1_State1
0E43            401           
0E43            402           Start_FSM1_State0:
0E43 D203       403           setb enable_time_global
0E45 D2A7       404           setb OVEN; turn oven on
0E47 1206DC     405       lcall Read_Room_Temp
0E4A 120602     405       lcall Read_Oven_Temp
0E4D            405   
0E4D            405       ;mov(dst, src)
0E4D 85515D     405            mov x+3, Current_Oven_Temp+3
0E50 85505C     405       mov x+2, Current_Oven_Temp+2
0E53 854F5B     405       mov x+1, Current_Oven_Temp+1
0E56 854E5A     405       mov x,   Current_Oven_Temp
0E59            405       ;mov(dst, src)
0E59 853961     405            mov y+3, TEMP_SOAK+3
0E5C 853860     405       mov y+2, TEMP_SOAK+2
0E5F 85375F     405       mov y+1, TEMP_SOAK+1
0E62 85365E     405       mov y,   TEMP_SOAK
0E65            405   
0E65 1203C0     405       lcall x_lt_y    ;Read Temperatures
0E68 C0E0       406            push acc
0E6A 7401       406            mov a, #1
0E6C 14         406            dec a
0E6D 120290     406            lcall ?Set_Cursor_1 ; Select column and row
0E70 D0E0       406            pop acc
0E72 C083       406            push dph
0E74 C082       406            push dpl
0E76 C0E0       406            push acc
0E78 90014B     406            mov dptr, #WORKING
0E7B 120283     406            lcall ?Send_Constant_String
0E7E D0E0       406            pop acc
0E80 D082       406            pop dpl
0E82 D083       406            pop dph
0E84 C0E0       406            push acc
0E86 7401       406            mov a, #1
0E88 14         406            dec a
0E89 12028E     406            lcall ?Set_Cursor_2 ; Select column and row
0E8C D0E0       406            pop acc
0E8E C083       406            push dph
0E90 C082       406            push dpl
0E92 C0E0       406            push acc
0E94 90015C     406            mov dptr, #STEP1
0E97 120283     406            lcall ?Send_Constant_String
0E9A D0E0       406            pop acc
0E9C D082       406            pop dpl
0E9E D083       406            pop dph;display interface
0EA0 120CEB     407           lcall Display_Working_Status
0EA3 C0E0       408            push acc
0EA5 7406       408            mov a, #6
0EA7 14         408            dec a
0EA8 12028E     408            lcall ?Set_Cursor_2 ; Select column and row
0EAB D0E0       408            pop acc
0EAD            409       ;mov(dst, src)
0EAD 85395D     409            mov x+3, TEMP_SOAK+3
0EB0 85385C     409       mov x+2, TEMP_SOAK+2
0EB3 85375B     409       mov x+1, TEMP_SOAK+1
0EB6 85365A     409       mov x,   TEMP_SOAK
0EB9 1202B8     410       lcall hex2bcd
0EBC            410       ;now the bcd num of time is stored in bcd
0EBC C000       410            push ar0
0EBE A863       410            mov r0, bcd+1
0EC0 1202AB     410            lcall ?Display_NUM
0EC3 D000       410            pop ar0;
0EC5 C000       410            push ar0
0EC7 A862       410            mov r0, bcd
0EC9 120295     410            lcall ?Display_BCD
0ECC D000       410            pop ar0;
0ECE            411   
0ECE 200207     412           jb mf, FSM1_State0_Error_Check;check Error and continue if smaller than set time
0ED1            413           ;if temp greater
0ED1 0534       414           inc FSM1_State; go to next state            
0ED3 853A32     415           mov Time_Counter, TIME_SOAK; move the TIME_SOAK in counter and count down
0ED6 8026       416           sjmp FSM1_State0_Done
0ED8            417   
0ED8            418           FSM1_State0_Error_Check:
0ED8 E531       419           mov a, Time_Global
0EDA B43C21     420           cjne a, #QUITTIME, FSM1_State0_Done; not time, done
0EDD            421           ;if time reached, check temp
0EDD            422       ;mov(dst, src)
0EDD 85515D     422            mov x+3, Current_Oven_Temp+3
0EE0 85505C     422       mov x+2, Current_Oven_Temp+2
0EE3 854F5B     422       mov x+1, Current_Oven_Temp+1
0EE6 854E5A     422       mov x,   Current_Oven_Temp;move current oven temp in x
0EE9 756100     423           mov y+3, #0
0EEC 756000     424           mov y+2, #0
0EEF 755F00     425           mov y+1, #0
0EF2 755E32     426           mov y, #QUITTEMP
0EF5 1203C0     427           lcall x_lt_y; check if current oven temp is smaller than quittemp
0EF8            428   
0EF8 300203     429           jnb mf, FSM1_State0_Done; the oven is working properly
0EFB            430           ;if not working right
0EFB 0211D2     431           ljmp FSM1_WARNING
0EFE            432   
0EFE            433   
0EFE            434   
0EFE            435           FSM1_State0_Done:
0EFE 02120F     436               ljmp FSM1_DONE
0F01            437   
0F01            438   
0F01            439       FSM1_State1:
0F01 B40102     440           cjne a, #1, JUMP_FSM1_State2
0F04 8003       441               sjmp Start_FSM1_State1
0F06            442           JUMP_FSM1_State2:
0F06 020FA7     443               ljmp FSM1_State2
0F09            444           
0F09            445           Start_FSM1_State1:
0F09 D53205     446           djnz Time_Counter, FSM1_State1_Continue; decrement every 1 second
0F0C            447           ;time over, change state
0F0C 0534       448           inc FSM1_State; increment states
0F0E 020FA4     449           ljmp FSM1_State1_Done
0F11            450   
0F11            451           FSM1_State1_Continue:
0F11            452           ;next: check temp
0F11            453           ;read temp and compare
0F11 1206DC     454       lcall Read_Room_Temp
0F14 120602     454       lcall Read_Oven_Temp
0F17            454   
0F17            454       ;mov(dst, src)
0F17 85515D     454            mov x+3, Current_Oven_Temp+3
0F1A 85505C     454       mov x+2, Current_Oven_Temp+2
0F1D 854F5B     454       mov x+1, Current_Oven_Temp+1
0F20 854E5A     454       mov x,   Current_Oven_Temp
0F23            454       ;mov(dst, src)
0F23 853961     454            mov y+3, TEMP_SOAK+3
0F26 853860     454       mov y+2, TEMP_SOAK+2
0F29 85375F     454       mov y+1, TEMP_SOAK+1
0F2C 85365E     454       mov y,   TEMP_SOAK
0F2F            454   
0F2F 1203C0     454       lcall x_lt_y   ;Update current temp info
0F32 C0E0       455            push acc
0F34 7401       455            mov a, #1
0F36 14         455            dec a
0F37 120290     455            lcall ?Set_Cursor_1 ; Select column and row
0F3A D0E0       455            pop acc
0F3C C083       455            push dph
0F3E C082       455            push dpl
0F40 C0E0       455            push acc
0F42 90014B     455            mov dptr, #WORKING
0F45 120283     455            lcall ?Send_Constant_String
0F48 D0E0       455            pop acc
0F4A D082       455            pop dpl
0F4C D083       455            pop dph
0F4E C0E0       455            push acc
0F50 7401       455            mov a, #1
0F52 14         455            dec a
0F53 12028E     455            lcall ?Set_Cursor_2 ; Select column and row
0F56 D0E0       455            pop acc
0F58 C083       455            push dph
0F5A C082       455            push dpl
0F5C C0E0       455            push acc
0F5E 90016D     455            mov dptr, #STEP2
0F61 120283     455            lcall ?Send_Constant_String
0F64 D0E0       455            pop acc
0F66 D082       455            pop dpl
0F68 D083       455            pop dph
0F6A 120CEB     456           lcall Display_Working_Status; update time and temp on lcd
0F6D            457           ;if temp is lower than expected, jump to ON
0F6D C0E0       458            push acc
0F6F 7405       458            mov a, #5
0F71 14         458            dec a
0F72 12028E     458            lcall ?Set_Cursor_2 ; Select column and row
0F75 D0E0       458            pop acc
0F77 755A00     459            mov x+0, #low (0 % 0x10000) 
0F7A 755B00     459            mov x+1, #high(0 % 0x10000) 
0F7D 755C00     459            mov x+2, #low (0 / 0x10000) 
0F80 755D00     459            mov x+3, #high(0 / 0x10000) 
0F83 85325A     460           mov x, Time_Counter
0F86 1202B8     461       lcall hex2bcd
0F89            461       ;now the bcd num of time is stored in bcd
0F89 C000       461            push ar0
0F8B A863       461            mov r0, bcd+1
0F8D 1202AB     461            lcall ?Display_NUM
0F90 D000       461            pop ar0;
0F92 C000       461            push ar0
0F94 A862       461            mov r0, bcd
0F96 120295     461            lcall ?Display_BCD
0F99 D000       461            pop ar0;
0F9B            462   
0F9B 200204     463           jb mf, FSM1_State1_ON
0F9E            464           ;if temp is higher, close oven
0F9E C2A7       465           clr OVEN 
0FA0 8002       466           sjmp FSM1_State1_Done
0FA2            467   
0FA2            468           FSM1_State1_ON:
0FA2 D2A7       469           setb OVEN   ;if temp is lower, turn on oven
0FA4            470           FSM1_State1_Done:
0FA4 02120F     471               ljmp FSM1_DONE
0FA7            472   
0FA7            473       FSM1_State2: ;temp ramp up until TEMP_RFLW
0FA7 B40202     474           cjne a, #2, JUMP_FSM1_State3
0FAA 8003       475               sjmp Start_FSM1_State2
0FAC            476           JUMP_FSM1_State3:
0FAC 021046     477               ljmp FSM1_State3
0FAF            478   
0FAF            479           Start_FSM1_State2:
0FAF D2A7       480           setb OVEN; turn on oven
0FB1            481   
0FB1            482           ;read temperature
0FB1 1206DC     483       lcall Read_Room_Temp
0FB4 120602     483       lcall Read_Oven_Temp
0FB7            483   
0FB7            483       ;mov(dst, src)
0FB7 85515D     483            mov x+3, Current_Oven_Temp+3
0FBA 85505C     483       mov x+2, Current_Oven_Temp+2
0FBD 854F5B     483       mov x+1, Current_Oven_Temp+1
0FC0 854E5A     483       mov x,   Current_Oven_Temp
0FC3            483       ;mov(dst, src)
0FC3 854161     483            mov y+3, TEMP_RFLW+3
0FC6 854060     483       mov y+2, TEMP_RFLW+2
0FC9 853F5F     483       mov y+1, TEMP_RFLW+1
0FCC 853E5E     483       mov y,   TEMP_RFLW
0FCF            483   
0FCF 1203C0     483       lcall x_lt_y
0FD2 200208     484           jb mf, FSM1_State2_Continue
0FD5            485           ;if temp reached
0FD5 0534       486           inc FSM1_State
0FD7 854232     487           mov Time_Counter, TIME_RFLW
0FDA 02120F     488           ljmp FSM1_DONE
0FDD            489   
0FDD            490           FSM1_State2_Continue:
0FDD C0E0       491            push acc
0FDF 7401       491            mov a, #1
0FE1 14         491            dec a
0FE2 120290     491            lcall ?Set_Cursor_1 ; Select column and row
0FE5 D0E0       491            pop acc
0FE7 C083       491            push dph
0FE9 C082       491            push dpl
0FEB C0E0       491            push acc
0FED 90014B     491            mov dptr, #WORKING
0FF0 120283     491            lcall ?Send_Constant_String
0FF3 D0E0       491            pop acc
0FF5 D082       491            pop dpl
0FF7 D083       491            pop dph
0FF9 C0E0       491            push acc
0FFB 7401       491            mov a, #1
0FFD 14         491            dec a
0FFE 12028E     491            lcall ?Set_Cursor_2 ; Select column and row
1001 D0E0       491            pop acc
1003 C083       491            push dph
1005 C082       491            push dpl
1007 C0E0       491            push acc
1009 90017E     491            mov dptr, #STEP3
100C 120283     491            lcall ?Send_Constant_String
100F D0E0       491            pop acc
1011 D082       491            pop dpl
1013 D083       491            pop dph
1015 120CEB     492           lcall Display_Working_Status
1018 C0E0       493            push acc
101A 7406       493            mov a, #6
101C 14         493            dec a
101D 12028E     493            lcall ?Set_Cursor_2 ; Select column and row
1020 D0E0       493            pop acc
1022            494       ;mov(dst, src)
1022 85415D     494            mov x+3, TEMP_RFLW+3
1025 85405C     494       mov x+2, TEMP_RFLW+2
1028 853F5B     494       mov x+1, TEMP_RFLW+1
102B 853E5A     494       mov x,   TEMP_RFLW
102E 1202B8     495       lcall hex2bcd
1031            495       ;now the bcd num of time is stored in bcd
1031 C000       495            push ar0
1033 A863       495            mov r0, bcd+1
1035 1202AB     495            lcall ?Display_NUM
1038 D000       495            pop ar0;
103A C000       495            push ar0
103C A862       495            mov r0, bcd
103E 120295     495            lcall ?Display_BCD
1041 D000       495            pop ar0;
1043            496   
1043            497           FSM1_State2_Done:
1043 02120F     498               ljmp FSM1_DONE
1046            499           
1046            500            FSM1_State3: ; keep temp at TEMP_RFLW for a few time
1046 B40302     501           cjne a, #3, JUMP_FSM1_State4
1049 8003       502               sjmp Start_FSM1_State3
104B            503           JUMP_FSM1_State4:
104B 0210EC     504               ljmp FSM1_State4
104E            505           
104E            506           Start_FSM1_State3:
104E D53205     507           djnz Time_Counter, FSM1_State3_Continue
1051            508           ;if time's up
1051 0534       509           inc FSM1_State
1053 0210E9     510           ljmp FSM1_State3_Done
1056            511   
1056            512           FSM1_State3_Continue:
1056 C0E0       513            push acc
1058 7401       513            mov a, #1
105A 14         513            dec a
105B 120290     513            lcall ?Set_Cursor_1 ; Select column and row
105E D0E0       513            pop acc
1060 C083       513            push dph
1062 C082       513            push dpl
1064 C0E0       513            push acc
1066 90014B     513            mov dptr, #WORKING
1069 120283     513            lcall ?Send_Constant_String
106C D0E0       513            pop acc
106E D082       513            pop dpl
1070 D083       513            pop dph
1072 C0E0       513            push acc
1074 7401       513            mov a, #1
1076 14         513            dec a
1077 12028E     513            lcall ?Set_Cursor_2 ; Select column and row
107A D0E0       513            pop acc
107C C083       513            push dph
107E C082       513            push dpl
1080 C0E0       513            push acc
1082 90018F     513            mov dptr, #STEP4
1085 120283     513            lcall ?Send_Constant_String
1088 D0E0       513            pop acc
108A D082       513            pop dpl
108C D083       513            pop dph
108E 120CEB     514           lcall Display_Working_Status
1091 1206DC     515       lcall Read_Room_Temp
1094 120602     515       lcall Read_Oven_Temp
1097            515   
1097            515       ;mov(dst, src)
1097 85515D     515            mov x+3, Current_Oven_Temp+3
109A 85505C     515       mov x+2, Current_Oven_Temp+2
109D 854F5B     515       mov x+1, Current_Oven_Temp+1
10A0 854E5A     515       mov x,   Current_Oven_Temp
10A3            515       ;mov(dst, src)
10A3 854161     515            mov y+3, TEMP_RFLW+3
10A6 854060     515       mov y+2, TEMP_RFLW+2
10A9 853F5F     515       mov y+1, TEMP_RFLW+1
10AC 853E5E     515       mov y,   TEMP_RFLW
10AF            515   
10AF 1203C0     515       lcall x_lt_y; update temp info, set or clr mf flag
10B2 C0E0       516            push acc
10B4 7405       516            mov a, #5
10B6 14         516            dec a
10B7 12028E     516            lcall ?Set_Cursor_2 ; Select column and row
10BA D0E0       516            pop acc
10BC 755A00     517            mov x+0, #low (0 % 0x10000) 
10BF 755B00     517            mov x+1, #high(0 % 0x10000) 
10C2 755C00     517            mov x+2, #low (0 / 0x10000) 
10C5 755D00     517            mov x+3, #high(0 / 0x10000) 
10C8 85325A     518           mov x, Time_Counter
10CB 1202B8     519       lcall hex2bcd
10CE            519       ;now the bcd num of time is stored in bcd
10CE C000       519            push ar0
10D0 A863       519            mov r0, bcd+1
10D2 1202AB     519            lcall ?Display_NUM
10D5 D000       519            pop ar0;
10D7 C000       519            push ar0
10D9 A862       519            mov r0, bcd
10DB 120295     519            lcall ?Display_BCD
10DE D000       519            pop ar0;
10E0            520   
10E0            521           ;if temp is lower than expected, jump to ON
10E0 200204     522           jb mf, FSM1_State3_ON
10E3            523           ;if temp is higher, close oven
10E3 C2A7       524           clr OVEN 
10E5 8002       525           sjmp FSM1_State3_Done
10E7            526   
10E7            527           FSM1_State3_ON:
10E7 D2A7       528           setb OVEN   ;if temp is lower, turn on oven
10E9            529           FSM1_State3_Done:
10E9 02120F     530               ljmp FSM1_DONE
10EC            531           
10EC            532   
10EC            533       
10EC            534       FSM1_State4:; cool down until safe temp
10EC B40402     535           cjne a, #4, JUMP_FSM1_State5
10EF 8003       536               sjmp Start_FSM1_State4
10F1            537           JUMP_FSM1_State5:
10F1 02118E     538               ljmp FSM1_State5
10F4            539           
10F4            540           Start_FSM1_State4:
10F4 C2A7       541           clr OVEN
10F6            542           ;read temperature
10F6 1206DC     543       lcall Read_Room_Temp
10F9 120602     543       lcall Read_Oven_Temp
10FC            543   
10FC            543       ;mov(dst, src)
10FC 85515D     543            mov x+3, Current_Oven_Temp+3
10FF 85505C     543       mov x+2, Current_Oven_Temp+2
1102 854F5B     543       mov x+1, Current_Oven_Temp+1
1105 854E5A     543       mov x,   Current_Oven_Temp
1108            543       ;mov(dst, src)
1108 854961     543            mov y+3, TEMP_SAFE+3
110B 854860     543       mov y+2, TEMP_SAFE+2
110E 85475F     543       mov y+1, TEMP_SAFE+1
1111 85465E     543       mov y,   TEMP_SAFE
1114            543   
1114 1203C0     543       lcall x_lt_y
1117            544           ;if temp is smaller than TEMP_SAFE, go state 5
1117 300205     545           jnb mf, FSM1_State4_Continue
111A            546           ;if temp is smaller than expected
111A 0534       547           inc FSM1_State
111C 753200     548           mov Time_Counter, #0
111F            549   
111F            550           FSM1_State4_Continue:
111F C0E0       551            push acc
1121 7401       551            mov a, #1
1123 14         551            dec a
1124 120290     551            lcall ?Set_Cursor_1 ; Select column and row
1127 D0E0       551            pop acc
1129 C083       551            push dph
112B C082       551            push dpl
112D C0E0       551            push acc
112F 90014B     551            mov dptr, #WORKING
1132 120283     551            lcall ?Send_Constant_String
1135 D0E0       551            pop acc
1137 D082       551            pop dpl
1139 D083       551            pop dph
113B C0E0       551            push acc
113D 7401       551            mov a, #1
113F 14         551            dec a
1140 12028E     551            lcall ?Set_Cursor_2 ; Select column and row
1143 D0E0       551            pop acc
1145 C083       551            push dph
1147 C082       551            push dpl
1149 C0E0       551            push acc
114B 9001A0     551            mov dptr, #STEP5
114E 120283     551            lcall ?Send_Constant_String
1151 D0E0       551            pop acc
1153 D082       551            pop dpl
1155 D083       551            pop dph
1157 120CEB     552           lcall Display_Working_Status
115A C0E0       553            push acc
115C 7405       553            mov a, #5
115E 14         553            dec a
115F 12028E     553            lcall ?Set_Cursor_2 ; Select column and row
1162 D0E0       553            pop acc
1164 755A00     554            mov x+0, #low (0 % 0x10000) 
1167 755B00     554            mov x+1, #high(0 % 0x10000) 
116A 755C00     554            mov x+2, #low (0 / 0x10000) 
116D 755D00     554            mov x+3, #high(0 / 0x10000) 
1170 85465A     555           mov x, TEMP_SAFE
1173 1202B8     556           lcall hex2bcd
1176 1202B8     557       lcall hex2bcd
1179            557       ;now the bcd num of time is stored in bcd
1179 C000       557            push ar0
117B A863       557            mov r0, bcd+1
117D 1202AB     557            lcall ?Display_NUM
1180 D000       557            pop ar0;
1182 C000       557            push ar0
1184 A862       557            mov r0, bcd
1186 120295     557            lcall ?Display_BCD
1189 D000       557            pop ar0;
118B            558   
118B            559           FSM1_State4_Done:
118B 02120F     560               ljmp FSM1_DONE
118E            561   
118E            562       FSM1_State5: ; already cool done, display something, play some music
118E B4057E     563           cjne a, #5, FSM1_DONE
1191 C2A7       564           clr OVEN; double check oven is not on
1193 C203       565           clr enable_time_global; stop counting
1195 C0E0       566            push acc
1197 7401       566            mov a, #1
1199 14         566            dec a
119A 120290     566            lcall ?Set_Cursor_1 ; Select column and row
119D D0E0       566            pop acc
119F C083       566            push dph
11A1 C082       566            push dpl
11A3 C0E0       566            push acc
11A5 90014B     566            mov dptr, #WORKING
11A8 120283     566            lcall ?Send_Constant_String
11AB D0E0       566            pop acc
11AD D082       566            pop dpl
11AF D083       566            pop dph
11B1 C0E0       566            push acc
11B3 7401       566            mov a, #1
11B5 14         566            dec a
11B6 12028E     566            lcall ?Set_Cursor_2 ; Select column and row
11B9 D0E0       566            pop acc
11BB C083       566            push dph
11BD C082       566            push dpl
11BF C0E0       566            push acc
11C1 9001B1     566            mov dptr, #STEP6
11C4 120283     566            lcall ?Send_Constant_String
11C7 D0E0       566            pop acc
11C9 D082       566            pop dpl
11CB D083       566            pop dph
11CD 120CEB     567           lcall Display_Working_Status
11D0 803D       568           sjmp FSM1_Done
11D2            569   
11D2            570   
11D2            571       FSM1_WARNING:
11D2 C2A7       572           clr OVEN
11D4 C0E0       573            push acc
11D6 7401       573            mov a, #1
11D8 14         573            dec a
11D9 120290     573            lcall ?Set_Cursor_1 ; Select column and row
11DC D0E0       573            pop acc
11DE C083       573            push dph
11E0 C082       573            push dpl
11E2 C0E0       573            push acc
11E4 9001C2     573            mov dptr, #WARNING1
11E7 120283     573            lcall ?Send_Constant_String
11EA D0E0       573            pop acc
11EC D082       573            pop dpl
11EE D083       573            pop dph
11F0 C0E0       573            push acc
11F2 7401       573            mov a, #1
11F4 14         573            dec a
11F5 12028E     573            lcall ?Set_Cursor_2 ; Select column and row
11F8 D0E0       573            pop acc
11FA C083       573            push dph
11FC C082       573            push dpl
11FE C0E0       573            push acc
1200 9001D3     573            mov dptr, #WARNING2
1203 120283     573            lcall ?Send_Constant_String
1206 D0E0       573            pop acc
1208 D082       573            pop dpl
120A D083       573            pop dph
120C 753406     574           mov FSM1_State, #6
120F            575   
120F            576       FSM1_DONE:
120F 22         577       ret
1210            578   
1210            579   Speak_Process:
1210 120A6D     580       lcall current_temp_is
1213 854E6B     581       mov number, Current_Oven_Temp+0
1216 120A50     582       lcall playnumbers
1219 120A8C     583       lcall degree
121C 120AAB     584       lcall celsius
121F 22         585       ret
1220            586   
1220            587   EN
