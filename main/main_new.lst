                  2   $LIST
0000              4   
0000              5   ;-------------------;
0000              6   ;    Const Define   ;
0000              7   ;-------------------; 
0000              8   XTAL EQU 7373000
0000              9   BAUD EQU 115200
0000             10   BRVAL EQU ((XTAL/BAUD)-16)
0000             11   
0000             12   CCU_RATE      EQU 22050      ; 100Hz, for an overflow rate of 10ms
0000             13   CCU_RELOAD    EQU ((65536-((XTAL/(2*CCU_RATE)))))
0000             14   
0000             15   ;TIMER0_RATE   EQU 4096    ; 4096Hz
0000             16   ;TIMER0_RELOAD EQU ((65536-(XTAL/(2*TIMER0_RATE))))
0000             17   TIMER1_RATE   EQU 100     ; 1000Hz, for a timer tick of 1ms
0000             18   TIMER1_RELOAD EQU ((65536-(XTAL/(2*TIMER1_RATE))))
0000             19   QUITTIME      EQU 30
0000             20   QUITTEMP      EQU 60
0000             21   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             22   
0000             23   number_off_set EQU 17200 ;the distance between each number
0000             24   ;number start at ff
0000             25   
0000             26   ;starting addressed of different sound tracks
0000             27   decimal_start  EQU 360000
0000             28   decimal_off_set EQU 24100
0000             29   decimal_playtime EQU 50000
0000             30   
0000             31   special_dec_start EQU 174000 ;numbers from 10 to 19
0000             32   special_off_set EQU 21500
0000             33   special_playtime EQU 21500;19000
0000             34   
0000             35   hundreds_start EQU 563000
0000             36   hundreds_off_set EQU 37000
0000             37   
0000             38   current_temp_is_start EQU 674000
0000             39   current_temp_playtime EQU 35000
0000             40   
0000             41   degree_start EQU 710000
0000             42   degree_playtime EQU 11018
0000             43   
0000             44   celsius_start EQU 732236
0000             45   celsius_playtime EQU 17000
0000             46   
0000             47   current_process_is_start EQU 757000
0000             48   current_process_is_playtime EQU 27000
0000             49            
0000             50   ramp_to_soak_start EQU 790000
0000             51   ramp_to_soak_playtime EQU 25000
0000             52   
0000             53   preheat_and_soak_start EQU 822000
0000             54   preheat_and_soak_playtime EQU 27000
0000             55   
0000             56   ramp_to_peak_start EQU 857000
0000             57   ramp_to_peak_playtime EQU 19000
0000             58   
0000             59   reflow_start EQU 885000
0000             60   reflow_playtime EQU 15000
0000             61   
0000             62   cooling_start EQU 906000
0000             63   cooling_playtime EQU 14000
0000             64   ;-------------------;
0000             65   ;    Ports Define   ;
0000             66   ;-------------------; 
0000             67   BUTTON equ P0.1
0000             68   LED    equ P0.2
0000             69   LCD_RS equ P0.5
0000             70   LCD_RW equ P0.6
0000             71   LCD_E  equ P0.7
0000             72   LCD_D4 equ P3.1
0000             73   LCD_D5 equ P1.2
0000             74   LCD_D6 equ P1.3
0000             75   LCD_D7 equ P1.4
0000             76   ;ADC00 equ P1.7; Read Oven Temperature
0000             77   ;ADC01 equ P0.0; Read Room Temperature
0000             78   ;ADC02 equ P2.1; Read Keyboard0
0000             79   ;ADC03 equ P2.0; Read Keyboard1
0000             80   OVEN   equ P2.7
0000             81   ALARM  equ P1.6
0000             82   FLASH_CE    EQU P2.4
0000             83   
0000             84   ;------------------------;
0000             85   ;    Interrupt Vectors   ;
0000             86   ;------------------------; 
0000             87   ; Reset vector
0000             88   org 0x0000
0000 020B82      89       ljmp MainProgram
0003             90   
0003             91   ; External interrupt 0 vector
0003             92   org 0x0003
0003 32          93            reti
0004             94   
0004             95   ; Timer/Counter 0 overflow interrupt vector
000B             96   org 0x000B
000B 32          97            reti
000C             98   
000C             99   ; External interrupt 1 vector
0013            100   org 0x0013
0013 32         101            reti
0014            102   
0014            103   ; Timer/Counter 1 overflow interrupt vector
001B            104   org 0x001B
001B 020C70     105            ljmp Timer1_ISR
001E            106       ; Serial port receive/transmit interrupt vector
0023            107   org 0x0023 
0023 32         108            reti
0024            109       ; CCU interrupt vector
005B            110   org 0x005b 
005B 02075B     111            ljmp CCU_ISR
005E            112   
005E            113   ;-----------------------;
005E            114   ;    Variables Define   ;
005E            115   ;-----------------------; 
005E            116   ;Variable_name: ds n
0030            117   dseg at 0x30
0030            118       Count10ms:    ds 1 ; Used to determine when half second has passed
0031            119       Time_Global:  ds 1 ; to store the time of whole process
0032            120       Time_Counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            121   
0033            122       FSM0_State: ds 1
0034            123       FSM1_State: ds 1
0035            124   
0035            125       Profile_Num: ds 1
0036            126   
0036            127       TEMP_SOAK:  ds 4
003A            128       TIME_SOAK:  ds 4
003E            129       TEMP_RFLW:  ds 4
0042            130       TIME_RFLW:  ds 4
0046            131       TEMP_SAFE:  ds 4
004A            132       Current_Room_Temp: ds 4
004E            133            Current_Oven_Temp: ds 4
0052            134   
0052            135       Cursor:     ds 1
0053            136       NEW_BCD:    ds 3    ; 3 digit BCD used to store current entered number
0056            137       NEW_HEX:    ds 4    ; 32 bit number of new entered number
005A            138       ;for math32.inc
005A            139       x: ds 4
005E            140       y: ds 4
0062            141       bcd: ds 5
0067            142       Count5s: ds 1
0068            143       ;z
0068            144       w:   ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
006B            145            number: ds 1;
006C            146       digits: ds 1;
006D            147            tenth: ds 1;
006E            148            individual_offest: ds 1;
006F            149   
006F            150   
006F            151   ;-------------------;
006F            152   ;    Flags Define   ;
006F            153   ;-------------------; 
006F            154   ;Flag_name: dbit 1
0000            155   bseg
0000            156       FSM0_State_Changed:  dbit 1
0001            157       Main_State:          dbit 1 ; 0 for setting, 1 for reflowing
0002            158       ;for math32.inc
0002            159       mf: dbit 1
0003            160       enable_time_global: dbit 1
0004            161       half_seconds_flag: dbit 1 ; 500ms in double rate mode
0005            162           nodigit: dbit 1 ; if playing from 10 to 19 then we don't need to
0006            163                       ;play the last digit
0006            164            skiphundred: dbit 1
0007            165            skiptenth: dbit 1
0008            166       Speak:     dbit 1
0009            167   ;-----------------------;
0009            168   ;     Include Files     ;
0009            169   ;-----------------------; 
0009            170   ;$NOLIST
                 -1       $include(lcd_4bit.inc) 
005E              1   cseg
005E              2   
005E 30313233     3   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
006E 30313233     4   hex: db '0123456789abcdef',0
     34353637
     38396162
     63646566
     00
007F              5   
007F              6   ;LCD                '1234567890123456'
007F 57454C43     7   WELCOME1:        db 'WELCOME!        '   ,0
     4F4D4521
     20202020
     20202020
     00
0090 53757065     8   WELCOME2:        db 'Super Reflow!   '   ,0
     72205265
     666C6F77
     21202020
     00
00A1 53657474     9   MAIN_FACE1:      db 'Setting: Prof   '   ,0
     696E673A
     2050726F
     66202020
     00
00B2 53746172    10   MAIN_FACE2: db 'Start       Stop'   ,0
     74202020
     20202020
     53746F70
     00
00C3 53544D50    11   SETTING1:        db 'STMP:   STM:   s'   ,0
     3A202020
     53544D3A
     20202073
     00
00D4 52544D50    12   SETTING2:   db 'RTMP:   RTM:   s'   ,0
     3A202020
     52544D3A
     20202073
     00
00E5 4F4C443A    13   MODIFY_DOWN:db 'OLD:    NEW:    '   ,0
     20202020
     4E45573A
     20202020
     00
00F6 4D4F4449    14   MODIFY1:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
0107 4D4F4449    15   MODIFY2:         db 'MODIFY:TIME_SOAK'   ,0
     46593A54
     494D455F
     534F414B
     00
0118 4D4F4449    16   MODIFY3:         db 'MODIFY:TEMP_RFLW'   ,0
     46593A54
     454D505F
     52464C57
     00
0129 4D4F4449    17   MODIFY4:         db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
013A 4D4F4449    18   MODIFY5:    db 'MODIFY:TEMP_SOAK'   ,0
     46593A54
     454D505F
     534F414B
     00
014B 54454D50    19   WORKING:    db 'TEMP:   TIME:   '   ,0
     3A202020
     54494D45
     3A202020
     00
015C 53544D50    20   STEP1:           db 'STMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
016D 53544D3A    21   STEP2:      db 'STM:   s SOAKING'   ,0
     20202073
     20534F41
     4B494E47
     00
017E 52544D50    22   STEP3:      db 'RTMP:    RAMPING'   ,0
     3A202020
     2052414D
     50494E47
     00
018F 52544D3A    23   STEP4:      db 'RTM:   s REFLOW '   ,0
     20202073
     20524546
     4C4F5720
     00
01A0 5346543A    24   STEP5:      db 'SFT:     COOLING'   ,0
     20202020
     20434F4F
     4C494E47
     00
01B1 20202020    25   STEP6:      db '         FINISH '   ,0
     20202020
     2046494E
     49534820
     00
01C2 4572726F    26   WARNING1:   db 'Error Warning!  '   ,0
     72205761
     726E696E
     67212020
     00
01D3 54454D50    27   WARNING2:   db 'TEMP Sensing ERR'   ,0
     2053656E
     73696E67
     20455252
     00
01E4             28   ;---------------------------------;
01E4             29   ;           Basic Macros          ;
01E4             30   ;---------------------------------;
                 31   LCD_Initailize mac
                 32   	lcall LCD_4BIT
                 33   endmac
01E4             34   
                 35   LCD_WriteData mac
                 36   	mov a, %0
                 37   	lcall ?LCD_WriteData
                 38   endmac
01E4             39            
                 40   LCD_WriteCommand mac
                 41   	mov a, %0
                 42   	lcall ?LCD_WriteCommand
                 43   endmac
01E4             44   
                 45   LCD_Send_Constant_String mac
                 46   	push dph
                 47   	push dpl
                 48   	push acc
                 49   	mov dptr, %0
                 50   	lcall ?Send_Constant_String
                 51   	pop acc
                 52   	pop dpl
                 53   	pop dph
                 54   endmac
01E4             55   
                 56   LCD_Set_Cursor mac
                 57   	push acc
                 58   	mov a, #%1
                 59   	dec a
                 60   	lcall ?Set_Cursor_%0 ; Select column and row
                 61   	pop acc
                 62   endmac
01E4             63   
                 64   LCD_Display_BCD mac
                 65   	push ar0
                 66   	mov r0, %0
                 67   	lcall ?Display_BCD
                 68   	pop ar0
                 69   endmac
01E4             70   
                 71   LCD_Display_NUM mac
                 72   	push ar0
                 73   	mov r0, %0
                 74   	lcall ?Display_NUM
                 75   	pop ar0
                 76   endmac
01E4             77   
                 78   LCD_Display_Char mac
                 79   	push acc
                 80   	mov a, %0
                 81   	lcall ?LCD_WriteData
                 82   	pop acc
                 83   endmac
01E4             84   
                 85   Wait_Milli_Seconds mac
                 86   	push AR2
                 87   	mov R2, %0
                 88   	lcall ?Wait_Milli_Seconds
                 89   	pop AR2
                 90   endmac
01E4             91   
01E4             92   ;---------------------------------;
01E4             93   ;         Interface Macros        ;
01E4             94   ;---------------------------------;
01E4             95   
                 96   LCD_INTERFACE_WELCOME mac
                 97   	LCD_Set_Cursor(1,1)
                 98   	LCD_Send_Constant_String(#WELCOME1)
                 99   	LCD_Set_Cursor(2,1)
                100   	LCD_Send_Constant_String(#WELCOME2)
                101   endmac
01E4            102   
                103   LCD_INTERFACE_MAIN mac
                104   	LCD_Set_Cursor(1,1)
                105   	LCD_Send_Constant_String(#MAIN_FACE1)
                106   	LCD_Set_Cursor(2,1)
                107   	LCD_Send_Constant_String(#MAIN_FACE2)
                108   	LCD_Set_Cursor(1,15); Profile number
                109   	LCD_Display_BCD(Profile_Num)
                110   endmac
01E4            112   
                113   LCD_INTERFACE_SETTING mac
                114   	LCD_Set_Cursor(1,1)
                115   	LCD_Send_Constant_String(#SETTING1)
                116   	LCD_Set_Cursor(2,1)
                117   	LCD_Send_Constant_String(#SETTING2)
                118   endmac
01E4            119   
                120   LCD_INTERFACE_MODIFY1 mac
                121   	LCD_Set_Cursor(1,1)
                122   	LCD_Send_Constant_String(#MODIFY1)
                123   	LCD_Set_Cursor(2,1)
                124   	LCD_Send_Constant_String(#MODIFY_DOWN)
                125   endmac
01E4            126   
                127   LCD_INTERFACE_MODIFY2 mac
                128   	LCD_Set_Cursor(1,1)
                129   	LCD_Send_Constant_String(#MODIFY2)
                130   	LCD_Set_Cursor(2,1)
                131   	LCD_Send_Constant_String(#MODIFY_DOWN)
                132   endmac
01E4            133   
                134   LCD_INTERFACE_MODIFY3 mac
                135   	LCD_Set_Cursor(1,1)
                136   	LCD_Send_Constant_String(#MODIFY3)
                137   	LCD_Set_Cursor(2,1)
                138   	LCD_Send_Constant_String(#MODIFY_DOWN)
                139   endmac
01E4            140   
                141   LCD_INTERFACE_MODIFY4 mac
                142   	LCD_Set_Cursor(1,1)
                143   	LCD_Send_Constant_String(#MODIFY4)
                144   	LCD_Set_Cursor(2,1)
                145   	LCD_Send_Constant_String(#MODIFY_DOWN)
                146   endmac
01E4            147   
                148   LCD_INTERFACE_MODIFY5 mac
                149   	LCD_Set_Cursor(1,1)
                150   	LCD_Send_Constant_String(#MODIFY5)
                151   	LCD_Set_Cursor(2,1)
                152   	LCD_Send_Constant_String(#MODIFY_DOWN)
                153   endmac
01E4            154   
                155   LCD_INTERFACE_STEP1 mac
                156   	LCD_Set_Cursor(1,1)
                157   	LCD_Send_Constant_String(#WORKING)
                158   	LCD_Set_Cursor(2,1)
                159   	LCD_Send_Constant_String(#STEP1)
                160   endmac
01E4            161   
                162   LCD_INTERFACE_STEP2 mac
                163   	LCD_Set_Cursor(1,1)
                164   	LCD_Send_Constant_String(#WORKING)
                165   	LCD_Set_Cursor(2,1)
                166   	LCD_Send_Constant_String(#STEP2)
                167   endmac
01E4            168   
                169   LCD_INTERFACE_STEP3 mac
                170   	LCD_Set_Cursor(1,1)
                171   	LCD_Send_Constant_String(#WORKING)
                172   	LCD_Set_Cursor(2,1)
                173   	LCD_Send_Constant_String(#STEP3)
                174   endmac
01E4            175   
                176   LCD_INTERFACE_STEP4 mac
                177   	LCD_Set_Cursor(1,1)
                178   	LCD_Send_Constant_String(#WORKING)
                179   	LCD_Set_Cursor(2,1)
                180   	LCD_Send_Constant_String(#STEP4)
                181   endmac
01E4            182   
                183   LCD_INTERFACE_STEP5 mac
                184   	LCD_Set_Cursor(1,1)
                185   	LCD_Send_Constant_String(#WORKING)
                186   	LCD_Set_Cursor(2,1)
                187   	LCD_Send_Constant_String(#STEP5)
                188   endmac
01E4            189   
                190   LCD_INTERFACE_STEP6 mac
                191   	LCD_Set_Cursor(1,1)
                192   	LCD_Send_Constant_String(#WORKING)
                193   	LCD_Set_Cursor(2,1)
                194   	LCD_Send_Constant_String(#STEP6)
                195   endmac
01E4            196   
                197   LCD_INTERFACE_WARNING mac
                198   	LCD_Set_Cursor(1,1)
                199   	LCD_Send_Constant_String(#WARNING1)
                200   	LCD_Set_Cursor(2,1)
                201   	LCD_Send_Constant_String(#WARNING2)
                202   endmac
01E4            203   
01E4            204   
01E4            205   Wait10us:
01E4 7812       206       mov R0, #18
01E6 D8FE       207       djnz R0, $ ; 2 machine cycles-> 2*0.27126us*18=10us
01E8 22         208            ret
01E9            209   ;---------------------------------;
01E9            210   ; Wait 40 microseconds            ;
01E9            211   ;---------------------------------;
01E9            212   Wait40uSec:
01E9 C000       213            push AR0
01EB 784A       214            mov R0, #74
01ED            215   L0: 
01ED D8FE       216            djnz R0, L0 ; 2 cycles->2*271.26ns*74=40us
01EF D000       217            pop AR0
01F1 22         218       ret
01F2            219   
01F2            220   ;---------------------------------;
01F2            221   ; Wait 500 microseconds           ;
01F2            222   ;---------------------------------;
01F2            223   WaitHalfSec:
01F2 7A28       224       mov R2, #40
01F4 79FA       225   H3: mov R1, #250
01F6 78B8       226   H2: mov R0, #184
01F8 D8FE       227   H1: djnz R0, H1 ; 2 machine cycles-> 2*0.27126us*184=100us
01FA D9FA       228       djnz R1, H2 ; 100us*250=0.025s
01FC DAF6       229       djnz R2, H3 ; 0.025s*20=0.5s
01FE 22         230       ret
01FF            231   
01FF            232   ;---------------------------------;
01FF            233   ; Wait 'R2' milliseconds          ;
01FF            234   ;---------------------------------;
01FF            235   ?Wait_Milli_Seconds:
01FF C000       236            push AR0
0201 C001       237            push AR1
0203 790A       238   L3: mov R1, #10
0205 78B8       239   L2: mov R0, #184
0207 D8FE       240   L1: djnz R0, L1 ; 2 cycles->2*271.26ns*184=100us
0209 D9FA       241       djnz R1, L2 ; 100us*10=1ms
020B DAF6       242       djnz R2, L3 ; number of millisecons to wait passed in R2
020D D001       243       pop AR1
020F D000       244       pop AR0
0211 22         245       ret
0212            246            
0212            247   ;---------------------------------;
0212            248   ; Toggles the 'E' pin in the LCD  ;
0212            249   ;---------------------------------;
0212            250   LCD_pulse:
0212 D287       251            setb LCD_E
0214 1201E9     252            lcall Wait40uSec
0217 C287       253            clr LCD_E
0219 1201E9     254       lcall Wait40uSec
021C 22         255       ret
021D            256   
021D            257   ;---------------------------------;
021D            258   ; Writes acc to LCD in 4-bit mode ;
021D            259   ;---------------------------------;
021D            260   LCD_byte:
021D            261            ; Write high 4 bits first
021D A2E7       262            mov c, ACC.7
021F 9294       263            mov LCD_D7, c
0221 A2E6       264            mov c, ACC.6
0223 9293       265            mov LCD_D6, c
0225 A2E5       266            mov c, ACC.5
0227 9292       267            mov LCD_D5, c
0229 A2E4       268            mov c, ACC.4
022B 92B1       269            mov LCD_D4, c
022D 120212     270       lcall LCD_pulse
0230            271            ; Write low 4 bits next
0230 A2E3       272            mov c, ACC.3
0232 9294       273            mov LCD_D7, c
0234 A2E2       274            mov c, ACC.2
0236 9293       275            mov LCD_D6, c
0238 A2E1       276            mov c, ACC.1
023A 9292       277            mov LCD_D5, c
023C A2E0       278            mov c, ACC.0
023E 92B1       279            mov LCD_D4, c
0240 120212     280       lcall LCD_pulse
0243 22         281            ret
0244            282   
0244            283   ;---------------------------------;
0244            284   ; Write data to LCD               ;
0244            285   ;---------------------------------;
0244            286   ?LCD_WriteData:
0244 D285       287            setb LCD_RS
0246 02021D     288            ljmp LCD_byte
0249            289   
0249            290   ;---------------------------------;
0249            291   ; Write command to LCD            ;
0249            292   ;---------------------------------;
0249            293   ?LCD_WriteCommand:
0249 C285       294            clr LCD_RS
024B 02021D     295            ljmp LCD_byte
024E            296   
024E            297   ;---------------------------------;
024E            298   ; Configure LCD in 4-bit mode     ;
024E            299   ;---------------------------------;
024E            300   LCD_4BIT:
024E C287       301            clr LCD_E   ; Resting state of LCD's enable pin is zero
0250 C286       302            clr LCD_RW  ; We are only writing to the LCD in this program
0252            303            
0252            304            ; After power on, let the LCD start up before initializing
0252 C002       305            push AR2
0254 7A28       305            mov R2, #40
0256 1201FF     305            lcall ?Wait_Milli_Seconds
0259 D002       305            pop AR2
025B            306            
025B            307            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
025B 7433       308            mov a, #0x33
025D 120249     308            lcall ?LCD_WriteCommand
0260 7433       309            mov a, #0x33
0262 120249     309            lcall ?LCD_WriteCommand
0265 7432       310            mov a, #0x32
0267 120249     310            lcall ?LCD_WriteCommand ; change to 4-bit mode
026A            311   
026A            312            ; Configure the LCD
026A 7428       313            mov a, #0x28
026C 120249     313            lcall ?LCD_WriteCommand
026F 740C       314            mov a, #0x0c
0271 120249     314            lcall ?LCD_WriteCommand
0274 7401       315            mov a, #0x01
0276 120249     315            lcall ?LCD_WriteCommand ;  Clear screen command (takes some time)
0279            316   
0279            317       ;Wait for the clear screen command to finish.
0279 C002       318            push AR2
027B 7A02       318            mov R2, #2
027D 1201FF     318            lcall ?Wait_Milli_Seconds
0280 D002       318            pop AR2
0282 22         319       ret
0283            320   
0283            321   ;---------------------------------;
0283            322   ; Send a constant string to LCD   ;
0283            323   ;---------------------------------;
0283            324   ?Send_Constant_String:
0283 E4         325       clr a
0284 93         326       movc a, @a+dptr
0285 6006       327       jz ?Send_Constant_String_Done
0287 120244     328       lcall ?LCD_WriteData
028A A3         329       inc dptr
028B 80F6       330       sjmp ?Send_Constant_String
028D            331   ?Send_Constant_String_Done:
028D 22         332       ret  
028E            333   
028E            334   ;---------------------------------;
028E            335   ; Set LCD cursor at row, column   ;
028E            336   ;---------------------------------;
028E            337   ?Set_Cursor_2:
028E 4440       338            orl a, #01000000B
0290            339   ?Set_Cursor_1:
0290 4480       340            orl a, #10000000B
0292 020249     341            ljmp ?LCD_WriteCommand ; Select column and row
0295            342   
0295            343   ;---------------------------------;
0295            344   ; Display a BCD number in the LCD ;
0295            345   ;---------------------------------;
0295            346   ?Display_BCD:
0295 C0E0       347            push acc
0297            348            ; Write most significant digit
0297 E8         349            mov a, r0
0298 C4         350            swap a
0299 540F       351            anl a, #0fh
029B 4430       352            orl a, #30h
029D 120244     353            lcall ?LCD_WriteData
02A0            354            ; write least significant digit
02A0 E8         355            mov a, r0
02A1 540F       356            anl a, #0fh
02A3 4430       357            orl a, #30h
02A5 120244     358            lcall ?LCD_WriteData
02A8 D0E0       359            pop acc
02AA 22         360            ret
02AB            361   
02AB            362   ?Display_NUM:
02AB C0E0       363            push acc
02AD E8         364            mov a, R0
02AE 540F       365            anl a, #0fh
02B0 4430       366            orl a, #30h
02B2 120244     367            lcall ?LCD_WriteData
02B5 D0E0       368            pop acc
02B7            369   
02B7 22         370            ret
                 -1       $include(math32.inc)
                559   $LIST
                 -1       $include(LPC9351.inc)
0528              1   cseg
0528              2   
0528              3   ;---------------------------------;
0528              4   ;           Basic Macros          ;
0528              5   ;---------------------------------;
                  6   Ports_Initialize mac
                  7       lcall Ports_Init
                  8   endmac
0528              9   
                 10   Clock_Double mac
                 11       lcall _Clock_Double
                 12   endmac
0528             13   
                 14   ADC_Initialize mac
                 15       lcall InitADC
                 16   endmac
0528             17   
0528             18   ;---------------------------------;
0528             19   ;            Functions            ;
0528             20   ;---------------------------------;
0528             21   _Clock_Double:
0528 C0E0        22       push acc
052A 90FFDE      23       mov dptr, #CLKCON
052D E0          24       movx a, @dptr
052E 4408        25       orl a, #00001000B ; double the clock speed to 14.746MHz
0530 F0          26       movx @dptr,a
0531 D0E0        27       pop acc
0533 22          28       ret
0534             29   
0534             30   ;---------------------------------;
0534             31   ; Initial configuration of ports. ;
0534             32   ; After reset the default for the ;
0534             33   ; pins is 'Open Drain'.  This     ;
0534             34   ; routine changes them pins to    ;
0534             35   ; Quasi-bidirectional like in the ;
0534             36   ; original 8051.                  ;
0534             37   ; Notice that P1.2 and P1.3 are   ;
0534             38   ; always 'Open Drain'. If those   ;
0534             39   ; pins are to be used as output   ;
0534             40   ; they need a pull-up resistor.   ;
0534             41   ;---------------------------------;
0534             42   Ports_Init:
0534             43       ; Configure all the ports in bidirectional mode:
0534 758400      44       mov P0M1, #00H
0537 758500      45       mov P0M2, #00H
053A 759100      46       mov P1M1, #00H
053D 759200      47       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0540 75A400      48       mov P2M1, #00H
0543 75A500      49       mov P2M2, #00H
0546 75B100      50       mov P3M1, #00H
0549 75B200      51       mov P3M2, #00H
054C 22          52            ret
054D             53   
054D             54   InitADC:
054D             55            ; ADC0_0 is connected to P1.7
054D             56            ; ADC0_1 is connected to P0.0
054D             57            ; ADC0_2 is connected to P2.1
054D             58            ; ADC0_3 is connected to P2.0
054D             59       ; Configure pins P1.7, P0.0, P2.1, and P2.0 as inputs
054D 438401      60       orl P0M1, #00000001b
0550 5385FE      61       anl P0M2, #11111110b
0553 439180      62       orl P1M1, #10000000b
0556 53927F      63       anl P1M2, #01111111b
0559 43A403      64       orl P2M1, #00000011b
055C 53A5FC      65       anl P2M2, #11111100b
055F             66            ; Setup ADC0
055F D2C2        67            setb BURST0 ; Autoscan continuos conversion mode
0561 75A120      68            mov     ADMODB,#0x20 ;ADC0 clock is 7.3728MHz/2
0564 75A30F      69            mov     ADINS,#0x0f ; Select the four channels of ADC0 for conversion
0567 758E05      70            mov     ADCON0,#0x05 ; Enable the converter and start immediately
056A             71            ; Wait for first conversion to complete
056A             72   InitADC_L1:
056A E58E        73            mov     a,ADCON0
056C 30E3FB      74            jnb     acc.3,InitADC_L1
056F 22          75            ret
                 76   DO_NOTHING mac
                 77   	NOP
                 78   endmac
                 78   $LIST
                 -1       $include(serial.inc)
0570              1   CSEG
0570              2   
0570              3   
0570              4   ;---------------------------------;
0570              5   ;           Basic Macros          ;
0570              6   ;---------------------------------;
                  7   Serial_Initialize mac
                  8   	;Serial_Initialize()
                  9       lcall _Serial_Initialize
                 10   endmac
0570             11   
                 12   Serial_Send_Char mac
                 13       mov a, %0
                 14       lcall putchar
                 15   endmac
0570             16   
                 17   Serial_Read_Char mac
                 18   	;Serial_Read_Char(direct)
                 19       lcall getchar
                 20       mov %0, a
                 21   endmac
0570             22   
                 23   Serial_Send_Newline mac
                 24   	lcall Send_NewLine
                 25   endmac
0570             26   
                 27   Serial_Send_BCD mac
                 28   	push ar0
                 29   	mov r0, %0
                 30   	lcall ?Send_BCD
                 31   	pop ar0
                 32   endmac
0570             33   
                 34   Serial_Send_Constant_String mac
                 35   	mov dptr, %0
                 36   	lcall SendString
                 37   endmac
0570             38   
0570             39   ;---------------------------------;
0570             40   ; Initialize the serial port      ;
0570             41   ;---------------------------------;
0570             42   _Serial_Initialize:
0570 75BD00      43            mov     BRGCON,#0x00
0573 75BF00      44            mov     BRGR1,#high(BRVAL)
0576 75BE30      45            mov     BRGR0,#low(BRVAL)
0579 75BD03      46            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
057C 759852      47            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
057F             48            ; Make sure that TXD(P1.0) and RXD(P1.1) are configured as bidrectional I/O
057F 5391FC      49            anl     P1M1,#11111100B
0582 5392FC      50            anl     P1M2,#11111100B
0585 22          51            ret
0586             52   
0586             53   ;---------------------------------;
0586             54   ; Sends a byte via serial port    ;
0586             55   ;---------------------------------;
0586             56   putchar:
0586 109902      57            jbc     TI,putchar_L1
0589 80FB        58            sjmp putchar
058B             59   putchar_L1:
058B F599        60            mov     SBUF,a
058D 22          61            ret
058E             62   
058E             63   SendString:
058E E4          64       clr a
058F 93          65       movc a, @a+dptr
0590 6006        66       jz SendString_L1
0592 120586      67       lcall putchar
0595 A3          68       inc dptr
0596 80F6        69       sjmp SendString  
0598             70   SendString_L1:
0598 22          71            ret
0599             72   
0599             73   ;---------------------------------;
0599             74   ; Send a BCD number to PuTTY      ;
0599             75   ;---------------------------------;
0599             76   ?Send_BCD:
0599 C0E0        77            push acc
059B             78            ; Write most significant digit
059B E8          79            mov a, r0
059C C4          80            swap a
059D 540F        81            anl a, #0fh
059F 4430        82            orl a, #30h
05A1 120586      83            lcall putchar
05A4             84            ; write least significant digit
05A4 E8          85            mov a, r0
05A5 540F        86            anl a, #0fh
05A7 4430        87            orl a, #30h
05A9 120586      88            lcall putchar
05AC D0E0        89            pop acc
05AE 22          90            ret
05AF             91   
05AF             92   Send_NewLine:
05AF 740D        93            mov a, #'\r'
05B1 120586      94            lcall putchar
05B4 740A        95            mov a, #'\n'
05B6 120586      96            lcall putchar   
05B9 22          97            ret
05BA             98   
05BA             99   
05BA            100   SendTemp0:
05BA 90005E     101            mov dptr, #HexAscii 
05BD            102            
05BD            103            
05BD            104            
05BD E565       105            mov a, bcd+3
05BF C4         106            swap a
05C0 540F       107            anl a, #0xf
05C2 93         108            movc a, @a+dptr
05C3 120586     109            lcall putchar
05C6 E565       110            mov a, bcd+3
05C8 540F       111            anl a, #0xf
05CA 93         112            movc a, @a+dptr
05CB 120586     113            lcall putchar
05CE            114            
05CE E564       115            mov a, bcd+2
05D0 C4         116            swap a
05D1 540F       117            anl a, #0xf
05D3 93         118            movc a, @a+dptr
05D4 120586     119            lcall putchar
05D7 E564       120            mov a, bcd+2
05D9 540F       121            anl a, #0xf
05DB 93         122            movc a, @a+dptr
05DC 120586     123            lcall putchar
05DF            124            
05DF E563       125            mov a, bcd+1
05E1 C4         126            swap a
05E2 540F       127            anl a, #0xf
05E4 93         128            movc a, @a+dptr
05E5 120586     129            lcall putchar
05E8 E563       130            mov a, bcd+1
05EA 540F       131            anl a, #0xf
05EC 93         132            movc a, @a+dptr
05ED 120586     133            lcall putchar
05F0            134   
05F0            135   
05F0 E562       136            mov a, bcd+0
05F2 C4         137            swap a
05F3 540F       138            anl a, #0xf
05F5 93         139            movc a, @a+dptr
05F6 120586     140            lcall putchar
05F9 E562       141            mov a, bcd+0
05FB 540F       142            anl a, #0xf
05FD 93         143            movc a, @a+dptr
05FE 120586     144            lcall putchar
0601 22         145            ret
                 -1       $include(temperature.inc)
0602              1   cseg
0602              2   
0602              3   
0602              4   
0602              5   Read_Oven_Temp:
0602              6            ; Take 256 (4^4) consecutive measurements of ADC0 channel 0 at about 10 us intervals and accumulate in x
0602 755A00       7            mov x+0, #low (0 % 0x10000) 
0605 755B00       7            mov x+1, #high(0 % 0x10000) 
0608 755C00       7            mov x+2, #low (0 / 0x10000) 
060B 755D00       7            mov x+3, #high(0 / 0x10000) 
060E 85C75A       8       mov x+0, ad0dat2
0611 7FFF         9            mov R7, #255
0613 1201E4      10       lcall Wait10us
0616             11   accumulate_loop0:
0616 85C75E      12       mov y+0, ad0dat2
0619 755F00      13       mov y+1, #0
061C 756000      14       mov y+2, #0
061F 756100      15       mov y+3, #0
0622 12037D      16       lcall add32
0625 1201E4      17       lcall Wait10us
0628 DFEC        18            djnz R7, accumulate_loop0
062A             19            
062A             20            ; Now divide by 16 (2^4)
062A 755E10      21            mov y+0, #low (16 % 0x10000) 
062D 755F00      21            mov y+1, #high(16 % 0x10000) 
0630 756000      21            mov y+2, #low (16 / 0x10000) 
0633 756100      21            mov y+3, #high(16 / 0x10000) 
0636 1204BF      22            lcall div32
0639             23            ; x has now the 12-bit representation of the temperature
0639             24            
0639             25            ; Convert to temperature (C)
0639 755EE8      26            mov y+0, #low (33000 % 0x10000) 
063C 755F80      26            mov y+1, #high(33000 % 0x10000) 
063F 756000      26            mov y+2, #low (33000 / 0x10000) 
0642 756100      26            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
0645 120432      27            lcall mul32
0648 755E00      28            mov y+0, #low (((1<<12)) % 0x10000) 
064B 755F10      28            mov y+1, #high(((1<<12)) % 0x10000) 
064E 756000      28            mov y+2, #low (((1<<12)) / 0x10000) 
0651 756100      28            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
0654 1204BF      29            lcall div32
0657 755E3C      30            mov y+0, #low (60 % 0x10000) 
065A 755F00      30            mov y+1, #high(60 % 0x10000) 
065D 756000      30            mov y+2, #low (60 / 0x10000) 
0660 756100      30            mov y+3, #high(60 / 0x10000) 
0663 12039E      31            lcall sub32
0666             32   
0666             33            ;mov32(Current_Oven_Volt,x); store the hex value of voltage
0666             34            
0666 755E0E      35            mov y+0, #low (7438 % 0x10000) 
0669 755F1D      35            mov y+1, #high(7438 % 0x10000) 
066C 756000      35            mov y+2, #low (7438 / 0x10000) 
066F 756100      35            mov y+3, #high(7438 / 0x10000) 
0672 120432      36            lcall mul32
0675 755E10      37            mov y+0, #low (10000 % 0x10000) 
0678 755F27      37            mov y+1, #high(10000 % 0x10000) 
067B 756000      37            mov y+2, #low (10000 / 0x10000) 
067E 756100      37            mov y+3, #high(10000 / 0x10000) 
0681 1204BF      38            lcall div32
0684             39            ;now we got the relateive temp number in hex
0684             40   
0684             41       ;mov(dst, src)
0684 854D61      41            mov y+3, Current_Room_Temp+3
0687 854C60      41       mov y+2, Current_Room_Temp+2
068A 854B5F      41       mov y+1, Current_Room_Temp+1
068D 854A5E      41       mov y,   Current_Room_Temp
0690 12037D      42            lcall add32
0693             43            ;now we got the true value of oven in hex
0693             44            ;lcall hex2bcd
0693             45   
0693 755E64      46            mov y+0, #low (100 % 0x10000) 
0696 755F00      46            mov y+1, #high(100 % 0x10000) 
0699 756000      46            mov y+2, #low (100 / 0x10000) 
069C 756100      46            mov y+3, #high(100 / 0x10000) 
069F 1204BF      47            lcall div32;divide by 100 to get the value in integer
06A2             48            ; now x contains the value in hex
06A2 755EFA      49            mov y+0, #low (250 % 0x10000) 
06A5 755F00      49            mov y+1, #high(250 % 0x10000) 
06A8 756000      49            mov y+2, #low (250 / 0x10000) 
06AB 756100      49            mov y+3, #high(250 / 0x10000) 
06AE 1203C0      50            lcall x_lt_y
06B1 200203      51            jb mf, Temp_OK
06B4             52            ;if not ok
06B4 020602      53            ljmp Read_Oven_Temp;re-read the value
06B7             54   
06B7             55            Temp_OK:
06B7             56       ;mov(dst, src)
06B7 855D51      56            mov Current_Oven_Temp+3, x+3
06BA 855C50      56       mov Current_Oven_Temp+2, x+2
06BD 855B4F      56       mov Current_Oven_Temp+1, x+1
06C0 855A4E      56       mov Current_Oven_Temp,   x
06C3 22          57            ret
06C4             58   
06C4             59   Read_Room_Temp:
06C4             60            
06C4 755A00      61            mov x+0, #low (0 % 0x10000) 
06C7 755B00      61            mov x+1, #high(0 % 0x10000) 
06CA 755C00      61            mov x+2, #low (0 / 0x10000) 
06CD 755D00      61            mov x+3, #high(0 / 0x10000) 
06D0 85C75A      62       mov x+0, ad0dat2
06D3 7FFF        63            mov R7, #255
06D5 1201E4      64       lcall Wait10us
06D8             65       
06D8             66   accumulate_loop1:
06D8 85F45E      67       mov y+0, ad0dat3
06DB 755F00      68       mov y+1, #0
06DE 756000      69       mov y+2, #0
06E1 756100      70       mov y+3, #0
06E4 12037D      71       lcall add32
06E7 1201E4      72       lcall Wait10us
06EA DFEC        73            djnz R7, accumulate_loop1
06EC             74            
06EC             75            ; Now divide by 16 (2^4)
06EC 755E10      76            mov y+0, #low (16 % 0x10000) 
06EF 755F00      76            mov y+1, #high(16 % 0x10000) 
06F2 756000      76            mov y+2, #low (16 / 0x10000) 
06F5 756100      76            mov y+3, #high(16 / 0x10000) 
06F8 1204BF      77            lcall div32
06FB             78            ; x has now the 12-bit representation of the temperature
06FB             79            
06FB             80            ; Convert to temperature (C)
06FB 755EE8      81            mov y+0, #low (33000 % 0x10000) 
06FE 755F80      81            mov y+1, #high(33000 % 0x10000) 
0701 756000      81            mov y+2, #low (33000 / 0x10000) 
0704 756100      81            mov y+3, #high(33000 / 0x10000)  ; Vref is 3.3V
0707 120432      82            lcall mul32
070A 755E00      83            mov y+0, #low (((1<<12)) % 0x10000) 
070D 755F10      83            mov y+1, #high(((1<<12)) % 0x10000) 
0710 756000      83            mov y+2, #low (((1<<12)) / 0x10000) 
0713 756100      83            mov y+3, #high(((1<<12)) / 0x10000)  ; 2^12-1
0716 1204BF      84            lcall div32
0719 755E3C      85            mov y+0, #low (60 % 0x10000) 
071C 755F00      85            mov y+1, #high(60 % 0x10000) 
071F 756000      85            mov y+2, #low (60 / 0x10000) 
0722 756100      85            mov y+3, #high(60 / 0x10000) 
0725 12039E      86            lcall sub32
0728             87            
0728             88            ;now we got the voltage value
0728             89            ;mov32(Current_Room_Volt,x)
0728             90            
0728 755EA4      91            mov y+0, #low (27300 % 0x10000) 
072B 755F6A      91            mov y+1, #high(27300 % 0x10000) 
072E 756000      91            mov y+2, #low (27300 / 0x10000) 
0731 756100      91            mov y+3, #high(27300 / 0x10000) 
0734 12039E      92            lcall sub32
0737             93            ;now we got the temperature
0737             94       ;mov(dst, src)
0737 855D4D      94            mov Current_Room_Temp+3, x+3
073A 855C4C      94       mov Current_Room_Temp+2, x+2
073D 855B4B      94       mov Current_Room_Temp+1, x+1
0740 855A4A      94       mov Current_Room_Temp,   x
0743             95            
0743 22          96            ret
                 -1       $include(num.inc)
                457   $LIST
0B82            177   ;$LIST
0B82            178   
0B82            179   cseg
0B82            180   
0B82            181   
0B82            182   MainProgram:
0B82 75817F     183       mov SP, #0x7F
0B85 120534     184       lcall Ports_Init
0B88 12024E     185            lcall LCD_4BIT
0B8B            186            ;Serial_Initialize()
0B8B 120570     186       lcall _Serial_Initialize
0B8E 12054D     187       lcall InitADC
0B91 753100     188       mov Time_Global, #0x00
0B94 753900     189       mov TEMP_SOAK+3, #0x00
0B97 753800     190       mov TEMP_SOAK+2, #0x00
0B9A 753700     191       mov TEMP_SOAK+1, #0x00
0B9D 753696     192       mov TEMP_SOAK, #150
0BA0 754100     193       mov TEMP_RFLW+3, #0
0BA3 754000     194       mov TEMP_RFLW+2, #0
0BA6 753F00     195       mov TEMP_RFLW+1, #0
0BA9 753ED7     196       mov TEMP_RFLW, #215
0BAC 753D00     197       mov TIME_SOAK+3, #0
0BAF 753C00     198       mov TIME_SOAK+2, #0
0BB2 753B00     199       mov TIME_SOAK+1, #0
0BB5 753A1E     200       mov TIME_SOAK, #30
0BB8 754500     201       mov TIME_RFLW+3, #0
0BBB 754400     202       mov TIME_RFLW+2, #0
0BBE 754300     203       mov TIME_RFLW+1, #0
0BC1 75420A     204       mov TIME_RFLW, #10
0BC4 754900     205       mov TEMP_SAFE+3, #0
0BC7 754800     206       mov TEMP_SAFE+2, #0
0BCA 754700     207       mov TEMP_SAFE+1, #0
0BCD 75463C     208       mov TEMP_SAFE, #60
0BD0 753300     209       mov FSM0_State, #0
0BD3 753400     210       mov FSM1_State, #0
0BD6 756B00     211       mov number, #0x0 ;;not needed
0BD9 756E00     212       mov individual_offest, #0x0
0BDC 756700     213       mov Count5s, #0x00
0BDF            214   
0BDF C296       215       clr ALARM
0BE1 C203       216       clr enable_time_global
0BE3 C205       217       clr nodigit
0BE5 C206       218            clr skiphundred
0BE7 C207       219            clr skiptenth
0BE9            220   
0BE9 C0E0       221            push acc
0BEB 7401       221            mov a, #1
0BED 14         221            dec a
0BEE 120290     221            lcall ?Set_Cursor_1 ; Select column and row
0BF1 D0E0       221            pop acc
0BF3 C083       221            push dph
0BF5 C082       221            push dpl
0BF7 C0E0       221            push acc
0BF9 90007F     221            mov dptr, #WELCOME1
0BFC 120283     221            lcall ?Send_Constant_String
0BFF D0E0       221            pop acc
0C01 D082       221            pop dpl
0C03 D083       221            pop dph
0C05 C0E0       221            push acc
0C07 7401       221            mov a, #1
0C09 14         221            dec a
0C0A 12028E     221            lcall ?Set_Cursor_2 ; Select column and row
0C0D D0E0       221            pop acc
0C0F C083       221            push dph
0C11 C082       221            push dpl
0C13 C0E0       221            push acc
0C15 900090     221            mov dptr, #WELCOME2
0C18 120283     221            lcall ?Send_Constant_String
0C1B D0E0       221            pop acc
0C1D D082       221            pop dpl
0C1F D083       221            pop dph
0C21 12078C     222       lcall InitDAC
0C24 120744     223       lcall CCU_Init
0C27 12079C     224            lcall Init_SPI
0C2A C2C8       225       clr TMOD20 ; Stop CCU timer
0C2C            226   
0C2C D2AF       227       setb EA   ; Enable Global interrupts
0C2E C2A7       228       clr OVEN
0C30            229   
0C30            230   
0C30            231   loop:
0C30 2081FD     232       jb BUTTON, loop
0C33 C002       233            push AR2
0C35 7A4B       233            mov R2, #75
0C37 1201FF     233            lcall ?Wait_Milli_Seconds
0C3A D002       233            pop AR2
0C3C 2081F1     234       jb BUTTON, loop
0C3F 3081FD     235       jnb BUTTON, $
0C42 120C5D     236       lcall Timer1_Init
0C45            237   loop_a:
0C45 3004FD     238       jnb half_seconds_flag, loop_a
0C48            239   loop_b:
0C48 C204       240       clr half_seconds_flag
0C4A 0567       241       inc Count5s
0C4C E567       242       mov a, Count5s
0C4E B40A05     243       cjne a, #10, skip2
0C51 756700     244       mov Count5s, #0
0C54 D208       245       setb Speak
0C56            246       skip2:
0C56 B282       247       cpl LED
0C58 120CE9     248       lcall FSM1
0C5B 80E8       249            sjmp loop_a
0C5D            250   
                251   Display_3BCD_from_x mac
                252       lcall hex2bcd
                253       ;now the bcd num of time is stored in bcd
                254       LCD_Display_NUM(bcd+1);
                255       LCD_Display_BCD(bcd);
                256   endmac
0C5D            257   ;----------------------------;
0C5D            258   ;     Interrupt Services     ;
0C5D            259   ;----------------------------; 
0C5D            260   
0C5D            261   Timer1_Init:
0C5D E589       262            mov a, TMOD
0C5F 540F       263            anl a, #0x0f ; Clear the bits for timer 1
0C61 4410       264            orl a, #0x10 ; Configure timer 1 as 16-timer
0C63 F589       265            mov TMOD, a
0C65 758D6F     266            mov TH1, #high(TIMER1_RELOAD)
0C68 758BFF     267            mov TL1, #low(TIMER1_RELOAD)
0C6B            268            ; Enable the timer and interrupts
0C6B D2AB       269       setb ET1  ; Enable timer 1 interrupt
0C6D D28E       270       setb TR1  ; Start timer 1
0C6F 22         271            ret
0C70            272   
0C70            273   Timer1_ISR:
0C70 758D6F     274            mov TH1, #high(TIMER1_RELOAD)
0C73 758BFF     275            mov TL1, #low(TIMER1_RELOAD)
0C76 B2A6       276            cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0C78            277            
0C78            278            ; The two registers used in the ISR must be saved in the stack
0C78 C0E0       279            push acc
0C7A C0D0       280            push psw
0C7C            281            
0C7C            282            ; Increment the 8-bit 10-mili-second counter
0C7C 0530       283            inc Count10ms
0C7E            284   
0C7E            285   Inc_Done:
0C7E            286            ; Check if half second has passed
0C7E E530       287            mov a, Count10ms
0C80 B4320A     288            cjne a, #50, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
0C83            289            
0C83            290            ; 500 milliseconds have passed.  Set a flag so the main program knows
0C83 D204       291            setb half_seconds_flag ; Let the main program know half second had passed
0C85            292       
0C85 300302     293       jnb enable_time_global, skip1
0C88 0531       294       inc Time_Global
0C8A            295            skip1:
0C8A 753000     296       mov Count10ms, #0
0C8D            297   Timer1_ISR_done:
0C8D D0D0       298            pop psw
0C8F D0E0       299            pop acc
0C91 32         300            reti
0C92            301   
0C92            302   Display_Working_Status:
0C92 C0E0       303            push acc
0C94 7406       303            mov a, #6
0C96 14         303            dec a
0C97 120290     303            lcall ?Set_Cursor_1 ; Select column and row
0C9A D0E0       303            pop acc
0C9C            304       ;mov(dst, src)
0C9C 85515D     304            mov x+3, Current_Oven_Temp+3
0C9F 85505C     304       mov x+2, Current_Oven_Temp+2
0CA2 854F5B     304       mov x+1, Current_Oven_Temp+1
0CA5 854E5A     304       mov x,   Current_Oven_Temp
0CA8 1202B8     305       lcall hex2bcd
0CAB            305       ;now the bcd num of time is stored in bcd
0CAB C000       305            push ar0
0CAD A863       305            mov r0, bcd+1
0CAF 1202AB     305            lcall ?Display_NUM
0CB2 D000       305            pop ar0;
0CB4 C000       305            push ar0
0CB6 A862       305            mov r0, bcd
0CB8 120295     305            lcall ?Display_BCD
0CBB D000       305            pop ar0;
0CBD            306   
0CBD C0E0       307            push acc
0CBF 740E       307            mov a, #14
0CC1 14         307            dec a
0CC2 120290     307            lcall ?Set_Cursor_1 ; Select column and row
0CC5 D0E0       307            pop acc
0CC7 755D00     308       mov x+3, #0
0CCA 755C00     309       mov x+2, #0
0CCD 755B00     310       mov x+1, #0
0CD0 85315A     311       mov x, Time_Global
0CD3 1202B8     312       lcall hex2bcd
0CD6            312       ;now the bcd num of time is stored in bcd
0CD6 C000       312            push ar0
0CD8 A863       312            mov r0, bcd+1
0CDA 1202AB     312            lcall ?Display_NUM
0CDD D000       312            pop ar0;
0CDF C000       312            push ar0
0CE1 A862       312            mov r0, bcd
0CE3 120295     312            lcall ?Display_BCD
0CE6 D000       312            pop ar0;
0CE8            313   
0CE8 22         314       ret
0CE9            315   
                316   Update_Temp mac
                317       lcall Read_Room_Temp
                318       lcall Read_Oven_Temp
                319       mov32(x, Current_Oven_Temp)
                320       mov32(y, %0)
                321       lcall x_lt_y
                322   endmac
0CE9            324   
0CE9            325   FSM1:
0CE9            326       
0CE9            327       ;---------------------------------;
0CE9            328       ; FSM1 using Timer Interrupt      ;
0CE9            329       ;---------------------------------;
0CE9            330       ;update status and send data to LCD and PC every one/half seconds
0CE9            331   
0CE9 E534       332       mov a, FSM1_State
0CEB            333       FSM1_State0:
0CEB B40002     334           cjne a, #0, JUMP_FSM1_State1
0CEE 8003       335           sjmp Start_FSM1_State0
0CF0            336           JUMP_FSM1_State1:
0CF0 020DB1     337           ljmp FSM1_State1
0CF3            338           
0CF3            339           Start_FSM1_State0:
0CF3 D203       340           setb enable_time_global
0CF5 D2A7       341           setb OVEN; turn oven on
0CF7 1206C4     342       lcall Read_Room_Temp
0CFA 120602     342       lcall Read_Oven_Temp
0CFD            342   
0CFD            342       ;mov(dst, src)
0CFD 85515D     342            mov x+3, Current_Oven_Temp+3
0D00 85505C     342       mov x+2, Current_Oven_Temp+2
0D03 854F5B     342       mov x+1, Current_Oven_Temp+1
0D06 854E5A     342       mov x,   Current_Oven_Temp
0D09            342       ;mov(dst, src)
0D09 853961     342            mov y+3, TEMP_SOAK+3
0D0C 853860     342       mov y+2, TEMP_SOAK+2
0D0F 85375F     342       mov y+1, TEMP_SOAK+1
0D12 85365E     342       mov y,   TEMP_SOAK
0D15            342   
0D15 1203C0     342       lcall x_lt_y    ;Read Temperatures
0D18 C0E0       343            push acc
0D1A 7401       343            mov a, #1
0D1C 14         343            dec a
0D1D 120290     343            lcall ?Set_Cursor_1 ; Select column and row
0D20 D0E0       343            pop acc
0D22 C083       343            push dph
0D24 C082       343            push dpl
0D26 C0E0       343            push acc
0D28 90014B     343            mov dptr, #WORKING
0D2B 120283     343            lcall ?Send_Constant_String
0D2E D0E0       343            pop acc
0D30 D082       343            pop dpl
0D32 D083       343            pop dph
0D34 C0E0       343            push acc
0D36 7401       343            mov a, #1
0D38 14         343            dec a
0D39 12028E     343            lcall ?Set_Cursor_2 ; Select column and row
0D3C D0E0       343            pop acc
0D3E C083       343            push dph
0D40 C082       343            push dpl
0D42 C0E0       343            push acc
0D44 90015C     343            mov dptr, #STEP1
0D47 120283     343            lcall ?Send_Constant_String
0D4A D0E0       343            pop acc
0D4C D082       343            pop dpl
0D4E D083       343            pop dph;display interface
0D50 120C92     344           lcall Display_Working_Status
0D53 C0E0       345            push acc
0D55 7406       345            mov a, #6
0D57 14         345            dec a
0D58 12028E     345            lcall ?Set_Cursor_2 ; Select column and row
0D5B D0E0       345            pop acc
0D5D            346       ;mov(dst, src)
0D5D 85395D     346            mov x+3, TEMP_SOAK+3
0D60 85385C     346       mov x+2, TEMP_SOAK+2
0D63 85375B     346       mov x+1, TEMP_SOAK+1
0D66 85365A     346       mov x,   TEMP_SOAK
0D69 1202B8     347       lcall hex2bcd
0D6C            347       ;now the bcd num of time is stored in bcd
0D6C C000       347            push ar0
0D6E A863       347            mov r0, bcd+1
0D70 1202AB     347            lcall ?Display_NUM
0D73 D000       347            pop ar0;
0D75 C000       347            push ar0
0D77 A862       347            mov r0, bcd
0D79 120295     347            lcall ?Display_BCD
0D7C D000       347            pop ar0;
0D7E            348   
0D7E 200207     349           jb mf, FSM1_State0_Error_Check;check Error and continue if smaller than set time
0D81            350           ;if temp greater
0D81 0534       351           inc FSM1_State; go to next state            
0D83 853A32     352           mov Time_Counter, TIME_SOAK; move the TIME_SOAK in counter and count down
0D86 8026       353           sjmp FSM1_State0_Done
0D88            354   
0D88            355           FSM1_State0_Error_Check:
0D88 E531       356           mov a, Time_Global
0D8A B41E21     357           cjne a, #QUITTIME, FSM1_State0_Done; not time, done
0D8D            358           ;if time reached, check temp
0D8D            359       ;mov(dst, src)
0D8D 85515D     359            mov x+3, Current_Oven_Temp+3
0D90 85505C     359       mov x+2, Current_Oven_Temp+2
0D93 854F5B     359       mov x+1, Current_Oven_Temp+1
0D96 854E5A     359       mov x,   Current_Oven_Temp;move current oven temp in x
0D99 756100     360           mov y+3, #0
0D9C 756000     361           mov y+2, #0
0D9F 755F00     362           mov y+1, #0
0DA2 755E3C     363           mov y, #QUITTEMP
0DA5 1203C0     364           lcall x_lt_y; check if current oven temp is smaller than quittemp
0DA8            365   
0DA8 300203     366           jnb mf, FSM1_State0_Done; the oven is working properly
0DAB            367           ;if not working right
0DAB 021082     368           ljmp FSM1_WARNING
0DAE            369   
0DAE            370   
0DAE            371   
0DAE            372           FSM1_State0_Done:
0DAE 0210C0     373               ljmp FSM1_DONE
0DB1            374   
0DB1            375   
0DB1            376       FSM1_State1:
0DB1 B40102     377           cjne a, #1, JUMP_FSM1_State2
0DB4 8003       378               sjmp Start_FSM1_State1
0DB6            379           JUMP_FSM1_State2:
0DB6 020E57     380               ljmp FSM1_State2
0DB9            381           
0DB9            382           Start_FSM1_State1:
0DB9 D53205     383           djnz Time_Counter, FSM1_State1_Continue; decrement every 1 second
0DBC            384           ;time over, change state
0DBC 0534       385           inc FSM1_State; increment states
0DBE 020E54     386           ljmp FSM1_State1_Done
0DC1            387   
0DC1            388           FSM1_State1_Continue:
0DC1            389           ;next: check temp
0DC1            390           ;read temp and compare
0DC1 1206C4     391       lcall Read_Room_Temp
0DC4 120602     391       lcall Read_Oven_Temp
0DC7            391   
0DC7            391       ;mov(dst, src)
0DC7 85515D     391            mov x+3, Current_Oven_Temp+3
0DCA 85505C     391       mov x+2, Current_Oven_Temp+2
0DCD 854F5B     391       mov x+1, Current_Oven_Temp+1
0DD0 854E5A     391       mov x,   Current_Oven_Temp
0DD3            391       ;mov(dst, src)
0DD3 853961     391            mov y+3, TEMP_SOAK+3
0DD6 853860     391       mov y+2, TEMP_SOAK+2
0DD9 85375F     391       mov y+1, TEMP_SOAK+1
0DDC 85365E     391       mov y,   TEMP_SOAK
0DDF            391   
0DDF 1203C0     391       lcall x_lt_y   ;Update current temp info
0DE2 C0E0       392            push acc
0DE4 7401       392            mov a, #1
0DE6 14         392            dec a
0DE7 120290     392            lcall ?Set_Cursor_1 ; Select column and row
0DEA D0E0       392            pop acc
0DEC C083       392            push dph
0DEE C082       392            push dpl
0DF0 C0E0       392            push acc
0DF2 90014B     392            mov dptr, #WORKING
0DF5 120283     392            lcall ?Send_Constant_String
0DF8 D0E0       392            pop acc
0DFA D082       392            pop dpl
0DFC D083       392            pop dph
0DFE C0E0       392            push acc
0E00 7401       392            mov a, #1
0E02 14         392            dec a
0E03 12028E     392            lcall ?Set_Cursor_2 ; Select column and row
0E06 D0E0       392            pop acc
0E08 C083       392            push dph
0E0A C082       392            push dpl
0E0C C0E0       392            push acc
0E0E 90016D     392            mov dptr, #STEP2
0E11 120283     392            lcall ?Send_Constant_String
0E14 D0E0       392            pop acc
0E16 D082       392            pop dpl
0E18 D083       392            pop dph
0E1A 120C92     393           lcall Display_Working_Status; update time and temp on lcd
0E1D            394           ;if temp is lower than expected, jump to ON
0E1D C0E0       395            push acc
0E1F 7405       395            mov a, #5
0E21 14         395            dec a
0E22 12028E     395            lcall ?Set_Cursor_2 ; Select column and row
0E25 D0E0       395            pop acc
0E27 755A00     396            mov x+0, #low (0 % 0x10000) 
0E2A 755B00     396            mov x+1, #high(0 % 0x10000) 
0E2D 755C00     396            mov x+2, #low (0 / 0x10000) 
0E30 755D00     396            mov x+3, #high(0 / 0x10000) 
0E33 85325A     397           mov x, Time_Counter
0E36 1202B8     398       lcall hex2bcd
0E39            398       ;now the bcd num of time is stored in bcd
0E39 C000       398            push ar0
0E3B A863       398            mov r0, bcd+1
0E3D 1202AB     398            lcall ?Display_NUM
0E40 D000       398            pop ar0;
0E42 C000       398            push ar0
0E44 A862       398            mov r0, bcd
0E46 120295     398            lcall ?Display_BCD
0E49 D000       398            pop ar0;
0E4B            399   
0E4B 200204     400           jb mf, FSM1_State1_ON
0E4E            401           ;if temp is higher, close oven
0E4E C2A7       402           clr OVEN 
0E50 8002       403           sjmp FSM1_State1_Done
0E52            404   
0E52            405           FSM1_State1_ON:
0E52 D2A7       406           setb OVEN   ;if temp is lower, turn on oven
0E54            407           FSM1_State1_Done:
0E54 0210C0     408               ljmp FSM1_DONE
0E57            409   
0E57            410       FSM1_State2: ;temp ramp up until TEMP_RFLW
0E57 B40202     411           cjne a, #2, JUMP_FSM1_State3
0E5A 8003       412               sjmp Start_FSM1_State2
0E5C            413           JUMP_FSM1_State3:
0E5C 020EF6     414               ljmp FSM1_State3
0E5F            415   
0E5F            416           Start_FSM1_State2:
0E5F D2A7       417           setb OVEN; turn on oven
0E61            418   
0E61            419           ;read temperature
0E61 1206C4     420       lcall Read_Room_Temp
0E64 120602     420       lcall Read_Oven_Temp
0E67            420   
0E67            420       ;mov(dst, src)
0E67 85515D     420            mov x+3, Current_Oven_Temp+3
0E6A 85505C     420       mov x+2, Current_Oven_Temp+2
0E6D 854F5B     420       mov x+1, Current_Oven_Temp+1
0E70 854E5A     420       mov x,   Current_Oven_Temp
0E73            420       ;mov(dst, src)
0E73 854161     420            mov y+3, TEMP_RFLW+3
0E76 854060     420       mov y+2, TEMP_RFLW+2
0E79 853F5F     420       mov y+1, TEMP_RFLW+1
0E7C 853E5E     420       mov y,   TEMP_RFLW
0E7F            420   
0E7F 1203C0     420       lcall x_lt_y
0E82 200208     421           jb mf, FSM1_State2_Continue
0E85            422           ;if temp reached
0E85 0534       423           inc FSM1_State
0E87 854232     424           mov Time_Counter, TIME_RFLW
0E8A 0210C0     425           ljmp FSM1_DONE
0E8D            426   
0E8D            427           FSM1_State2_Continue:
0E8D C0E0       428            push acc
0E8F 7401       428            mov a, #1
0E91 14         428            dec a
0E92 120290     428            lcall ?Set_Cursor_1 ; Select column and row
0E95 D0E0       428            pop acc
0E97 C083       428            push dph
0E99 C082       428            push dpl
0E9B C0E0       428            push acc
0E9D 90014B     428            mov dptr, #WORKING
0EA0 120283     428            lcall ?Send_Constant_String
0EA3 D0E0       428            pop acc
0EA5 D082       428            pop dpl
0EA7 D083       428            pop dph
0EA9 C0E0       428            push acc
0EAB 7401       428            mov a, #1
0EAD 14         428            dec a
0EAE 12028E     428            lcall ?Set_Cursor_2 ; Select column and row
0EB1 D0E0       428            pop acc
0EB3 C083       428            push dph
0EB5 C082       428            push dpl
0EB7 C0E0       428            push acc
0EB9 90017E     428            mov dptr, #STEP3
0EBC 120283     428            lcall ?Send_Constant_String
0EBF D0E0       428            pop acc
0EC1 D082       428            pop dpl
0EC3 D083       428            pop dph
0EC5 120C92     429           lcall Display_Working_Status
0EC8 C0E0       430            push acc
0ECA 7406       430            mov a, #6
0ECC 14         430            dec a
0ECD 12028E     430            lcall ?Set_Cursor_2 ; Select column and row
0ED0 D0E0       430            pop acc
0ED2            431       ;mov(dst, src)
0ED2 85415D     431            mov x+3, TEMP_RFLW+3
0ED5 85405C     431       mov x+2, TEMP_RFLW+2
0ED8 853F5B     431       mov x+1, TEMP_RFLW+1
0EDB 853E5A     431       mov x,   TEMP_RFLW
0EDE 1202B8     432       lcall hex2bcd
0EE1            432       ;now the bcd num of time is stored in bcd
0EE1 C000       432            push ar0
0EE3 A863       432            mov r0, bcd+1
0EE5 1202AB     432            lcall ?Display_NUM
0EE8 D000       432            pop ar0;
0EEA C000       432            push ar0
0EEC A862       432            mov r0, bcd
0EEE 120295     432            lcall ?Display_BCD
0EF1 D000       432            pop ar0;
0EF3            433   
0EF3            434           FSM1_State2_Done:
0EF3 0210C0     435               ljmp FSM1_DONE
0EF6            436           
0EF6            437            FSM1_State3: ; keep temp at TEMP_RFLW for a few time
0EF6 B40302     438           cjne a, #3, JUMP_FSM1_State4
0EF9 8003       439               sjmp Start_FSM1_State3
0EFB            440           JUMP_FSM1_State4:
0EFB 020F9C     441               ljmp FSM1_State4
0EFE            442           
0EFE            443           Start_FSM1_State3:
0EFE D53205     444           djnz Time_Counter, FSM1_State3_Continue
0F01            445           ;if time's up
0F01 0534       446           inc FSM1_State
0F03 020F99     447           ljmp FSM1_State3_Done
0F06            448   
0F06            449           FSM1_State3_Continue:
0F06 C0E0       450            push acc
0F08 7401       450            mov a, #1
0F0A 14         450            dec a
0F0B 120290     450            lcall ?Set_Cursor_1 ; Select column and row
0F0E D0E0       450            pop acc
0F10 C083       450            push dph
0F12 C082       450            push dpl
0F14 C0E0       450            push acc
0F16 90014B     450            mov dptr, #WORKING
0F19 120283     450            lcall ?Send_Constant_String
0F1C D0E0       450            pop acc
0F1E D082       450            pop dpl
0F20 D083       450            pop dph
0F22 C0E0       450            push acc
0F24 7401       450            mov a, #1
0F26 14         450            dec a
0F27 12028E     450            lcall ?Set_Cursor_2 ; Select column and row
0F2A D0E0       450            pop acc
0F2C C083       450            push dph
0F2E C082       450            push dpl
0F30 C0E0       450            push acc
0F32 90018F     450            mov dptr, #STEP4
0F35 120283     450            lcall ?Send_Constant_String
0F38 D0E0       450            pop acc
0F3A D082       450            pop dpl
0F3C D083       450            pop dph
0F3E 120C92     451           lcall Display_Working_Status
0F41 1206C4     452       lcall Read_Room_Temp
0F44 120602     452       lcall Read_Oven_Temp
0F47            452   
0F47            452       ;mov(dst, src)
0F47 85515D     452            mov x+3, Current_Oven_Temp+3
0F4A 85505C     452       mov x+2, Current_Oven_Temp+2
0F4D 854F5B     452       mov x+1, Current_Oven_Temp+1
0F50 854E5A     452       mov x,   Current_Oven_Temp
0F53            452       ;mov(dst, src)
0F53 854161     452            mov y+3, TEMP_RFLW+3
0F56 854060     452       mov y+2, TEMP_RFLW+2
0F59 853F5F     452       mov y+1, TEMP_RFLW+1
0F5C 853E5E     452       mov y,   TEMP_RFLW
0F5F            452   
0F5F 1203C0     452       lcall x_lt_y; update temp info, set or clr mf flag
0F62 C0E0       453            push acc
0F64 7405       453            mov a, #5
0F66 14         453            dec a
0F67 12028E     453            lcall ?Set_Cursor_2 ; Select column and row
0F6A D0E0       453            pop acc
0F6C 755A00     454            mov x+0, #low (0 % 0x10000) 
0F6F 755B00     454            mov x+1, #high(0 % 0x10000) 
0F72 755C00     454            mov x+2, #low (0 / 0x10000) 
0F75 755D00     454            mov x+3, #high(0 / 0x10000) 
0F78 85325A     455           mov x, Time_Counter
0F7B 1202B8     456       lcall hex2bcd
0F7E            456       ;now the bcd num of time is stored in bcd
0F7E C000       456            push ar0
0F80 A863       456            mov r0, bcd+1
0F82 1202AB     456            lcall ?Display_NUM
0F85 D000       456            pop ar0;
0F87 C000       456            push ar0
0F89 A862       456            mov r0, bcd
0F8B 120295     456            lcall ?Display_BCD
0F8E D000       456            pop ar0;
0F90            457   
0F90            458           ;if temp is lower than expected, jump to ON
0F90 200204     459           jb mf, FSM1_State3_ON
0F93            460           ;if temp is higher, close oven
0F93 C2A7       461           clr OVEN 
0F95 8002       462           sjmp FSM1_State3_Done
0F97            463   
0F97            464           FSM1_State3_ON:
0F97 D2A7       465           setb OVEN   ;if temp is lower, turn on oven
0F99            466           FSM1_State3_Done:
0F99 0210C0     467               ljmp FSM1_DONE
0F9C            468           
0F9C            469   
0F9C            470       
0F9C            471       FSM1_State4:; cool down until safe temp
0F9C B40402     472           cjne a, #4, JUMP_FSM1_State5
0F9F 8003       473               sjmp Start_FSM1_State4
0FA1            474           JUMP_FSM1_State5:
0FA1 02103E     475               ljmp FSM1_State5
0FA4            476           
0FA4            477           Start_FSM1_State4:
0FA4 C2A7       478           clr OVEN
0FA6            479           ;read temperature
0FA6 1206C4     480       lcall Read_Room_Temp
0FA9 120602     480       lcall Read_Oven_Temp
0FAC            480   
0FAC            480       ;mov(dst, src)
0FAC 85515D     480            mov x+3, Current_Oven_Temp+3
0FAF 85505C     480       mov x+2, Current_Oven_Temp+2
0FB2 854F5B     480       mov x+1, Current_Oven_Temp+1
0FB5 854E5A     480       mov x,   Current_Oven_Temp
0FB8            480       ;mov(dst, src)
0FB8 854961     480            mov y+3, TEMP_SAFE+3
0FBB 854860     480       mov y+2, TEMP_SAFE+2
0FBE 85475F     480       mov y+1, TEMP_SAFE+1
0FC1 85465E     480       mov y,   TEMP_SAFE
0FC4            480   
0FC4 1203C0     480       lcall x_lt_y
0FC7            481           ;if temp is smaller than TEMP_SAFE, go state 5
0FC7 300205     482           jnb mf, FSM1_State4_Continue
0FCA            483           ;if temp is smaller than expected
0FCA 0534       484           inc FSM1_State
0FCC 753200     485           mov Time_Counter, #0
0FCF            486   
0FCF            487           FSM1_State4_Continue:
0FCF C0E0       488            push acc
0FD1 7401       488            mov a, #1
0FD3 14         488            dec a
0FD4 120290     488            lcall ?Set_Cursor_1 ; Select column and row
0FD7 D0E0       488            pop acc
0FD9 C083       488            push dph
0FDB C082       488            push dpl
0FDD C0E0       488            push acc
0FDF 90014B     488            mov dptr, #WORKING
0FE2 120283     488            lcall ?Send_Constant_String
0FE5 D0E0       488            pop acc
0FE7 D082       488            pop dpl
0FE9 D083       488            pop dph
0FEB C0E0       488            push acc
0FED 7401       488            mov a, #1
0FEF 14         488            dec a
0FF0 12028E     488            lcall ?Set_Cursor_2 ; Select column and row
0FF3 D0E0       488            pop acc
0FF5 C083       488            push dph
0FF7 C082       488            push dpl
0FF9 C0E0       488            push acc
0FFB 9001A0     488            mov dptr, #STEP5
0FFE 120283     488            lcall ?Send_Constant_String
1001 D0E0       488            pop acc
1003 D082       488            pop dpl
1005 D083       488            pop dph
1007 120C92     489           lcall Display_Working_Status
100A C0E0       490            push acc
100C 7405       490            mov a, #5
100E 14         490            dec a
100F 12028E     490            lcall ?Set_Cursor_2 ; Select column and row
1012 D0E0       490            pop acc
1014 755A00     491            mov x+0, #low (0 % 0x10000) 
1017 755B00     491            mov x+1, #high(0 % 0x10000) 
101A 755C00     491            mov x+2, #low (0 / 0x10000) 
101D 755D00     491            mov x+3, #high(0 / 0x10000) 
1020 85465A     492           mov x, TEMP_SAFE
1023 1202B8     493           lcall hex2bcd
1026 1202B8     494       lcall hex2bcd
1029            494       ;now the bcd num of time is stored in bcd
1029 C000       494            push ar0
102B A863       494            mov r0, bcd+1
102D 1202AB     494            lcall ?Display_NUM
1030 D000       494            pop ar0;
1032 C000       494            push ar0
1034 A862       494            mov r0, bcd
1036 120295     494            lcall ?Display_BCD
1039 D000       494            pop ar0;
103B            495   
103B            496           FSM1_State4_Done:
103B 0210C0     497               ljmp FSM1_DONE
103E            498   
103E            499       FSM1_State5: ; already cool done, display something, play some music
103E B4057F     500           cjne a, #5, FSM1_DONE
1041 C2A7       501           clr OVEN; double check oven is not on
1043 C203       502           clr enable_time_global; stop counting
1045 C0E0       503            push acc
1047 7401       503            mov a, #1
1049 14         503            dec a
104A 120290     503            lcall ?Set_Cursor_1 ; Select column and row
104D D0E0       503            pop acc
104F C083       503            push dph
1051 C082       503            push dpl
1053 C0E0       503            push acc
1055 90014B     503            mov dptr, #WORKING
1058 120283     503            lcall ?Send_Constant_String
105B D0E0       503            pop acc
105D D082       503            pop dpl
105F D083       503            pop dph
1061 C0E0       503            push acc
1063 7401       503            mov a, #1
1065 14         503            dec a
1066 12028E     503            lcall ?Set_Cursor_2 ; Select column and row
1069 D0E0       503            pop acc
106B C083       503            push dph
106D C082       503            push dpl
106F C0E0       503            push acc
1071 9001B1     503            mov dptr, #STEP6
1074 120283     503            lcall ?Send_Constant_String
1077 D0E0       503            pop acc
1079 D082       503            pop dpl
107B D083       503            pop dph
107D 120C92     504           lcall Display_Working_Status
1080            505   
1080            506   
1080 803E       507           sjmp FSM1_Done
1082            508   
1082            509   
1082            510       FSM1_WARNING:
1082 C2A7       511           clr OVEN
1084 C0E0       512            push acc
1086 7401       512            mov a, #1
1088 14         512            dec a
1089 120290     512            lcall ?Set_Cursor_1 ; Select column and row
108C D0E0       512            pop acc
108E C083       512            push dph
1090 C082       512            push dpl
1092 C0E0       512            push acc
1094 9001C2     512            mov dptr, #WARNING1
1097 120283     512            lcall ?Send_Constant_String
109A D0E0       512            pop acc
109C D082       512            pop dpl
109E D083       512            pop dph
10A0 C0E0       512            push acc
10A2 7401       512            mov a, #1
10A4 14         512            dec a
10A5 12028E     512            lcall ?Set_Cursor_2 ; Select column and row
10A8 D0E0       512            pop acc
10AA C083       512            push dph
10AC C082       512            push dpl
10AE C0E0       512            push acc
10B0 9001D3     512            mov dptr, #WARNING2
10B3 120283     512            lcall ?Send_Constant_String
10B6 D0E0       512            pop acc
10B8 D082       512            pop dpl
10BA D083       512            pop dph
10BC D296       513           setb ALARM
10BE 80FE       514           sjmp $
10C0            515   
10C0            516   
10C0            517       FSM1_DONE:
10C0 100801     518       jbc Speak, Speak_Process
10C3 22         519       ret
10C4            520   
10C4            521       Speak_Process:
10C4 120A43     522       lcall current_temp_is
10C7 854E6B     523       mov number, Current_Oven_Temp+0
10CA 120A26     524       lcall playnumbers
10CD 120A62     525       lcall degree
10D0 120A7E     526       lcall celsius
10D3 22         527       ret
10D4            528   EN
